{"ast":null,"code":"import { useMemo, useEffect } from \"react\";\nimport { useThree, addEffect, addAfterEffect, addTail } from \"@react-three/fiber\";\nimport { GLPerf, overLimitFps } from \"../internal.mjs\";\nimport * as THREE from \"three\";\nimport { countGeoDrawCalls } from \"../helpers/countGeoDrawCalls.mjs\";\nimport { setPerf, getPerf } from \"../store.mjs\";\nimport { emitEvent } from \"@utsubo/events\";\nconst updateMatrixWorldTemp = THREE.Object3D.prototype.updateMatrixWorld;\nconst updateWorldMatrixTemp = THREE.Object3D.prototype.updateWorldMatrix;\nconst updateMatrixTemp = THREE.Object3D.prototype.updateMatrix;\nconst maxGl = [\"calls\", \"triangles\", \"points\", \"lines\"];\nconst maxLog = [\"gpu\", \"cpu\", \"mem\", \"fps\"];\nlet matriceWorldCount = {\n  value: 0\n};\nlet matriceCount = {\n  value: 0\n};\nconst isUUID = uuid => {\n  let s = \"\" + uuid;\n  s = s.match(\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\");\n  if (s === null) {\n    return false;\n  }\n  return true;\n};\nconst addMuiPerfID = (material, currentObjectWithMaterials) => {\n  if (!material.defines) {\n    material.defines = {};\n  }\n  if (material.defines && !material.defines.muiPerf) {\n    material.defines = Object.assign(material.defines || {}, {\n      muiPerf: material.uuid\n    });\n  }\n  const uuid = material.uuid;\n  if (!currentObjectWithMaterials[uuid]) {\n    currentObjectWithMaterials[uuid] = {\n      meshes: {},\n      material\n    };\n    material.needsUpdate = true;\n  }\n  material.needsUpdate = false;\n  return uuid;\n};\nconst getMUIIndex = muid => muid === \"muiPerf\";\nconst PerfHeadless = ({\n  overClock,\n  logsPerSecond,\n  chart,\n  deepAnalyze,\n  matrixUpdate\n}) => {\n  const {\n    gl,\n    scene\n  } = useThree();\n  setPerf({\n    gl,\n    scene\n  });\n  const PerfLib = useMemo(() => {\n    const PerfLib2 = new GLPerf({\n      trackGPU: true,\n      overClock,\n      chartLen: chart ? chart.length : 120,\n      chartHz: chart ? chart.hz : 60,\n      logsPerSecond: logsPerSecond || 10,\n      gl: gl.getContext(),\n      chartLogger: chart2 => {\n        setPerf({\n          chart: chart2\n        });\n      },\n      paramLogger: logger => {\n        const log = {\n          maxMemory: logger.maxMemory,\n          gpu: logger.gpu,\n          cpu: logger.cpu,\n          mem: logger.mem,\n          fps: logger.fps,\n          totalTime: logger.duration,\n          frameCount: logger.frameCount\n        };\n        setPerf({\n          log\n        });\n        const {\n          accumulated\n        } = getPerf();\n        const glRender = gl.info.render;\n        accumulated.totalFrames++;\n        accumulated.gl.calls += glRender.calls;\n        accumulated.gl.triangles += glRender.triangles;\n        accumulated.gl.points += glRender.points;\n        accumulated.gl.lines += glRender.lines;\n        accumulated.log.gpu += logger.gpu;\n        accumulated.log.cpu += logger.cpu;\n        accumulated.log.mem += logger.mem;\n        accumulated.log.fps += logger.fps;\n        for (let i = 0; i < maxGl.length; i++) {\n          const key = maxGl[i];\n          const value = glRender[key];\n          if (value > accumulated.max.gl[key]) {\n            accumulated.max.gl[key] = value;\n          }\n        }\n        for (let i = 0; i < maxLog.length; i++) {\n          const key = maxLog[i];\n          const value = logger[key];\n          if (value > accumulated.max.log[key]) {\n            accumulated.max.log[key] = value;\n          }\n        }\n        setPerf({\n          accumulated\n        });\n        emitEvent(\"log\", [log, gl]);\n      }\n    });\n    const ctx = gl.getContext();\n    let glRenderer = null;\n    let glVendor = null;\n    const rendererInfo = ctx.getExtension(\"WEBGL_debug_renderer_info\");\n    const glVersion = ctx.getParameter(ctx.VERSION);\n    if (rendererInfo != null) {\n      glRenderer = ctx.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);\n      glVendor = ctx.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);\n    }\n    if (!glVendor) {\n      glVendor = \"Unknown vendor\";\n    }\n    if (!glRenderer) {\n      glRenderer = ctx.getParameter(ctx.RENDERER);\n    }\n    setPerf({\n      startTime: window.performance.now(),\n      infos: {\n        version: glVersion,\n        renderer: glRenderer,\n        vendor: glVendor\n      }\n    });\n    const callbacks = /* @__PURE__ */new Map();\n    const callbacksAfter = /* @__PURE__ */new Map();\n    Object.defineProperty(THREE.Scene.prototype, \"onBeforeRender\", {\n      get() {\n        return (...args) => {\n          var _a;\n          if (PerfLib2) {\n            PerfLib2.begin(\"profiler\");\n          }\n          (_a = callbacks.get(this)) == null ? void 0 : _a(...args);\n        };\n      },\n      set(callback) {\n        callbacks.set(this, callback);\n      },\n      configurable: true\n    });\n    Object.defineProperty(THREE.Scene.prototype, \"onAfterRender\", {\n      get() {\n        return (...args) => {\n          var _a;\n          if (PerfLib2) {\n            PerfLib2.end(\"profiler\");\n          }\n          (_a = callbacksAfter.get(this)) == null ? void 0 : _a(...args);\n        };\n      },\n      set(callback) {\n        callbacksAfter.set(this, callback);\n      },\n      configurable: true\n    });\n    return PerfLib2;\n  }, []);\n  useEffect(() => {\n    if (PerfLib) {\n      PerfLib.overClock = overClock || false;\n      if (overClock === false) {\n        setPerf({\n          overclockingFps: false\n        });\n        overLimitFps.value = 0;\n        overLimitFps.isOverLimit = 0;\n      }\n      PerfLib.chartHz = (chart == null ? void 0 : chart.hz) || 60;\n      PerfLib.chartLen = (chart == null ? void 0 : chart.length) || 120;\n    }\n  }, [overClock, PerfLib, chart == null ? void 0 : chart.length, chart == null ? void 0 : chart.hz]);\n  useEffect(() => {\n    if (matrixUpdate) {\n      THREE.Object3D.prototype.updateMatrixWorld = function () {\n        if (this.matrixWorldNeedsUpdate || arguments[0]) {\n          matriceWorldCount.value++;\n        }\n        updateMatrixWorldTemp.apply(this, arguments);\n      };\n      THREE.Object3D.prototype.updateWorldMatrix = function () {\n        matriceWorldCount.value++;\n        updateWorldMatrixTemp.apply(this, arguments);\n      };\n      THREE.Object3D.prototype.updateMatrix = function () {\n        matriceCount.value++;\n        updateMatrixTemp.apply(this, arguments);\n      };\n    }\n    gl.info.autoReset = false;\n    let effectSub = null;\n    let afterEffectSub = null;\n    if (!gl.info) return;\n    effectSub = addEffect(function preRafR3FPerf() {\n      if (getPerf().paused) {\n        setPerf({\n          paused: false\n        });\n      }\n      if (window.performance) {\n        window.performance.mark(\"cpu-started\");\n        PerfLib.startCpuProfiling = true;\n      }\n      matriceCount.value -= 1;\n      matriceWorldCount.value = 0;\n      matriceCount.value = 0;\n      if (gl.info) {\n        gl.info.reset();\n      }\n    });\n    afterEffectSub = addAfterEffect(function postRafR3FPerf() {\n      var _a, _b;\n      if (PerfLib && !PerfLib.paused) {\n        PerfLib.nextFrame(window.performance.now());\n        if (overClock && typeof window.requestIdleCallback !== \"undefined\") {\n          PerfLib.idleCbId = requestIdleCallback(PerfLib.nextFps);\n        }\n      }\n      if (deepAnalyze) {\n        const currentObjectWithMaterials = {};\n        const programs = /* @__PURE__ */new Map();\n        scene.traverse(function deepAnalyzeR3FPerf(object) {\n          if (object instanceof THREE.Mesh || object instanceof THREE.Points) {\n            if (object.material) {\n              let uuid = object.material.uuid;\n              const isTroika = Array.isArray(object.material) && object.material.length > 1;\n              if (isTroika) {\n                uuid = addMuiPerfID(object.material[1], currentObjectWithMaterials);\n              } else {\n                uuid = addMuiPerfID(object.material, currentObjectWithMaterials);\n              }\n              currentObjectWithMaterials[uuid].meshes[object.uuid] = object;\n            }\n          }\n        });\n        (_b = (_a = gl == null ? void 0 : gl.info) == null ? void 0 : _a.programs) == null ? void 0 : _b.forEach(program => {\n          const cacheKeySplited = program.cacheKey.split(\",\");\n          const muiPerfTracker = cacheKeySplited[cacheKeySplited.findIndex(getMUIIndex) + 1];\n          if (isUUID(muiPerfTracker) && currentObjectWithMaterials[muiPerfTracker]) {\n            const {\n              material,\n              meshes\n            } = currentObjectWithMaterials[muiPerfTracker];\n            programs.set(muiPerfTracker, {\n              program,\n              material,\n              meshes,\n              drawCounts: {\n                total: 0,\n                type: \"triangle\",\n                data: []\n              },\n              expand: false,\n              visible: true\n            });\n          }\n        });\n        if (programs.size !== getPerf().programs.size) {\n          countGeoDrawCalls(programs);\n          setPerf({\n            programs,\n            triggerProgramsUpdate: getPerf().triggerProgramsUpdate++\n          });\n        }\n      }\n    });\n    return () => {\n      if (PerfLib) {\n        if (typeof window.cancelIdleCallback !== \"undefined\") {\n          window.cancelIdleCallback(PerfLib.idleCbId);\n        }\n        window.cancelAnimationFrame(PerfLib.rafId);\n        window.cancelAnimationFrame(PerfLib.checkQueryId);\n      }\n      if (matrixUpdate) {\n        THREE.Object3D.prototype.updateMatrixWorld = updateMatrixTemp;\n      }\n      effectSub();\n      afterEffectSub();\n    };\n  }, [PerfLib, gl, chart, matrixUpdate]);\n  useEffect(() => {\n    const unsub = addTail(function postRafTailR3FPerf() {\n      if (PerfLib) {\n        PerfLib.paused = true;\n        matriceCount.value = 0;\n        matriceWorldCount.value = 0;\n        setPerf({\n          paused: true,\n          log: {\n            maxMemory: 0,\n            gpu: 0,\n            mem: 0,\n            cpu: 0,\n            fps: 0,\n            totalTime: 0,\n            frameCount: 0\n          }\n        });\n      }\n      return false;\n    });\n    return () => {\n      unsub();\n    };\n  }, []);\n  return null;\n};\nexport { PerfHeadless, matriceCount, matriceWorldCount };","map":{"version":3,"names":["updateMatrixWorldTemp","THREE","Object3D","prototype","updateMatrixWorld","updateWorldMatrixTemp","updateWorldMatrix","updateMatrixTemp","updateMatrix","maxGl","maxLog","matriceWorldCount","value","matriceCount","isUUID","uuid","s","match","addMuiPerfID","material","currentObjectWithMaterials","defines","muiPerf","Object","assign","meshes","needsUpdate","getMUIIndex","muid","PerfHeadless","overClock","logsPerSecond","chart","deepAnalyze","matrixUpdate","gl","scene","useThree","setPerf","PerfLib","useMemo","PerfLib2","GLPerf","trackGPU","chartLen","length","chartHz","hz","getContext","chartLogger","chart2","paramLogger","logger","log","maxMemory","gpu","cpu","mem","fps","totalTime","duration","frameCount","accumulated","getPerf","glRender","info","render","totalFrames","calls","triangles","points","lines","i","key","max","emitEvent","ctx","glRenderer","glVendor","rendererInfo","getExtension","glVersion","getParameter","VERSION","UNMASKED_RENDERER_WEBGL","UNMASKED_VENDOR_WEBGL","RENDERER","startTime","window","performance","now","infos","version","renderer","vendor","callbacks","Map","callbacksAfter","defineProperty","Scene","get","args","begin","_a","set","callback","configurable","end","useEffect","overclockingFps","overLimitFps","isOverLimit","matrixWorldNeedsUpdate","arguments","apply","autoReset","effectSub","afterEffectSub","addEffect","preRafR3FPerf","paused","mark","startCpuProfiling","reset","addAfterEffect","postRafR3FPerf","nextFrame","requestIdleCallback","idleCbId","nextFps","programs","traverse","deepAnalyzeR3FPerf","object","Mesh","Points","isTroika","Array","isArray","_b","forEach","program","cacheKeySplited","cacheKey","split","muiPerfTracker","findIndex","drawCounts","total","type","data","expand","visible","size","countGeoDrawCalls","triggerProgramsUpdate","cancelIdleCallback","cancelAnimationFrame","rafId","checkQueryId","unsub","addTail","postRafTailR3FPerf"],"sources":["/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/r3f-perf/src/components/PerfHeadless.tsx"],"sourcesContent":["import { FC, HTMLAttributes, useEffect, useMemo } from 'react'\nimport { addEffect, addAfterEffect, useThree, addTail } from '@react-three/fiber'\nimport { overLimitFps, GLPerf } from '../internal'\n\nimport * as THREE from 'three'\nimport { countGeoDrawCalls } from '../helpers/countGeoDrawCalls'\nimport { getPerf, ProgramsPerfs, setPerf } from '../store'\nimport { PerfProps } from '../typings'\nimport { emitEvent } from '@utsubo/events'\n\n// cameras from r3f-perf scene\n\n// @ts-ignore\nconst updateMatrixWorldTemp = THREE.Object3D.prototype.updateMatrixWorld\nconst updateWorldMatrixTemp = THREE.Object3D.prototype.updateWorldMatrix\nconst updateMatrixTemp = THREE.Object3D.prototype.updateMatrix\n\nconst maxGl = ['calls', 'triangles', 'points', 'lines']\nconst maxLog = ['gpu', 'cpu', 'mem', 'fps']\n\nexport let matriceWorldCount = {\n  value: 0,\n}\nexport let matriceCount = {\n  value: 0,\n}\n\nconst isUUID = (uuid: string) => {\n  let s: any = '' + uuid\n\n  s = s.match('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')\n  if (s === null) {\n    return false\n  }\n  return true\n}\n\nconst addMuiPerfID = (material: THREE.Material, currentObjectWithMaterials: any) => {\n  if (!material.defines) {\n    material.defines = {}\n  }\n\n  if (material.defines && !material.defines.muiPerf) {\n    material.defines = Object.assign(material.defines || {}, {\n      muiPerf: material.uuid,\n    })\n  }\n\n  const uuid = material.uuid\n\n  if (!currentObjectWithMaterials[uuid]) {\n    currentObjectWithMaterials[uuid] = {\n      meshes: {},\n      material: material,\n    }\n    material.needsUpdate = true\n  }\n  material.needsUpdate = false\n  return uuid\n}\n\ntype Chart = {\n  data: {\n    [index: string]: number[]\n  }\n  id: number\n  circularId: number\n}\n\nconst getMUIIndex = (muid: string) => muid === 'muiPerf'\n\nexport interface Props extends HTMLAttributes<HTMLDivElement> {}\n\n/**\n * Performance profiler component\n */\nexport const PerfHeadless: FC<PerfProps> = ({ overClock, logsPerSecond, chart, deepAnalyze, matrixUpdate }) => {\n  const { gl, scene } = useThree()\n  setPerf({ gl, scene })\n\n  const PerfLib = useMemo(() => {\n    const PerfLib = new GLPerf({\n      trackGPU: true,\n      overClock: overClock,\n      chartLen: chart ? chart.length : 120,\n      chartHz: chart ? chart.hz : 60,\n      logsPerSecond: logsPerSecond || 10,\n      gl: gl.getContext(),\n      chartLogger: (chart: Chart) => {\n        setPerf({ chart })\n      },\n      paramLogger: (logger: any) => {\n        const log = {\n          maxMemory: logger.maxMemory,\n          gpu: logger.gpu,\n          cpu: logger.cpu,\n          mem: logger.mem,\n          fps: logger.fps,\n          totalTime: logger.duration,\n          frameCount: logger.frameCount,\n        }\n        setPerf({\n          log,\n        })\n        const { accumulated }: any = getPerf()\n        const glRender: any = gl.info.render\n\n        accumulated.totalFrames++\n        accumulated.gl.calls += glRender.calls\n        accumulated.gl.triangles += glRender.triangles\n        accumulated.gl.points += glRender.points\n        accumulated.gl.lines += glRender.lines\n\n        accumulated.log.gpu += logger.gpu\n        accumulated.log.cpu += logger.cpu\n        accumulated.log.mem += logger.mem\n        accumulated.log.fps += logger.fps\n        // calculate max\n        for (let i = 0; i < maxGl.length; i++) {\n          const key = maxGl[i]\n          const value = glRender[key]\n          if (value > accumulated.max.gl[key]) {\n            accumulated.max.gl[key] = value\n          }\n        }\n\n        for (let i = 0; i < maxLog.length; i++) {\n          const key = maxLog[i]\n          const value = logger[key]\n          if (value > accumulated.max.log[key]) {\n            accumulated.max.log[key] = value\n          }\n        }\n\n        // TODO CONVERT TO OBJECT AND VALUE ALWAYS 0 THIS IS NOT CALL\n        setPerf({ accumulated })\n\n        emitEvent('log', [log, gl])\n      },\n    })\n\n    // Infos\n\n    const ctx = gl.getContext()\n    let glRenderer = null\n    let glVendor = null\n\n    const rendererInfo: any = ctx.getExtension('WEBGL_debug_renderer_info')\n    const glVersion = ctx.getParameter(ctx.VERSION)\n\n    if (rendererInfo != null) {\n      glRenderer = ctx.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL)\n      glVendor = ctx.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL)\n    }\n\n    if (!glVendor) {\n      glVendor = 'Unknown vendor'\n    }\n\n    if (!glRenderer) {\n      glRenderer = ctx.getParameter(ctx.RENDERER)\n    }\n\n    setPerf({\n      startTime: window.performance.now(),\n      infos: {\n        version: glVersion,\n        renderer: glRenderer,\n        vendor: glVendor,\n      },\n    })\n\n    const callbacks = new Map()\n    const callbacksAfter = new Map()\n    Object.defineProperty(THREE.Scene.prototype, 'onBeforeRender', {\n      get() {\n        return (...args: any) => {\n          if (PerfLib) {\n            PerfLib.begin('profiler')\n          }\n          callbacks.get(this)?.(...args)\n        }\n      },\n      set(callback) {\n        callbacks.set(this, callback)\n      },\n      configurable: true,\n    })\n\n    Object.defineProperty(THREE.Scene.prototype, 'onAfterRender', {\n      get() {\n        return (...args: any) => {\n          if (PerfLib) {\n            PerfLib.end('profiler')\n          }\n          callbacksAfter.get(this)?.(...args)\n        }\n      },\n      set(callback) {\n        callbacksAfter.set(this, callback)\n      },\n      configurable: true,\n    })\n\n    return PerfLib\n  }, [])\n\n  useEffect(() => {\n    if (PerfLib) {\n      PerfLib.overClock = overClock || false\n      if (overClock === false) {\n        setPerf({ overclockingFps: false })\n        overLimitFps.value = 0\n        overLimitFps.isOverLimit = 0\n      }\n      PerfLib.chartHz = chart?.hz || 60\n      PerfLib.chartLen = chart?.length || 120\n    }\n  }, [overClock, PerfLib, chart?.length, chart?.hz])\n\n  useEffect(() => {\n    if (matrixUpdate) {\n      THREE.Object3D.prototype.updateMatrixWorld = function () {\n        if (this.matrixWorldNeedsUpdate || arguments[0] /*force*/) {\n          matriceWorldCount.value++\n        }\n        // @ts-ignore\n        updateMatrixWorldTemp.apply(this, arguments)\n      }\n      THREE.Object3D.prototype.updateWorldMatrix = function () {\n        matriceWorldCount.value++\n        // @ts-ignore\n        updateWorldMatrixTemp.apply(this, arguments)\n      }\n      THREE.Object3D.prototype.updateMatrix = function () {\n        matriceCount.value++\n        // @ts-ignore\n        updateMatrixTemp.apply(this, arguments)\n      }\n    }\n\n    gl.info.autoReset = false\n    let effectSub: any = null\n    let afterEffectSub: any = null\n    if (!gl.info) return\n\n    effectSub = addEffect(function preRafR3FPerf() {\n      if (getPerf().paused) {\n        setPerf({ paused: false })\n      }\n\n      if (window.performance) {\n        window.performance.mark('cpu-started')\n        PerfLib.startCpuProfiling = true\n      }\n\n      matriceCount.value -= 1\n      matriceWorldCount.value = 0\n      matriceCount.value = 0\n\n      if (gl.info) {\n        gl.info.reset()\n      }\n    })\n\n    afterEffectSub = addAfterEffect(function postRafR3FPerf() {\n      if (PerfLib && !PerfLib.paused) {\n        PerfLib.nextFrame(window.performance.now())\n\n        if (overClock && typeof window.requestIdleCallback !== 'undefined') {\n          PerfLib.idleCbId = requestIdleCallback(PerfLib.nextFps)\n        }\n      }\n      if (deepAnalyze) {\n        const currentObjectWithMaterials: any = {}\n        const programs: ProgramsPerfs = new Map()\n\n        scene.traverse(function deepAnalyzeR3FPerf(object) {\n          if (object instanceof THREE.Mesh || object instanceof THREE.Points) {\n            if (object.material) {\n              let uuid = object.material.uuid\n              // troika generate and attach 2 materials\n              const isTroika = Array.isArray(object.material) && object.material.length > 1\n              if (isTroika) {\n                uuid = addMuiPerfID(object.material[1], currentObjectWithMaterials)\n              } else {\n                uuid = addMuiPerfID(object.material, currentObjectWithMaterials)\n              }\n\n              currentObjectWithMaterials[uuid].meshes[object.uuid] = object\n            }\n          }\n        })\n\n        gl?.info?.programs?.forEach((program: any) => {\n          const cacheKeySplited = program.cacheKey.split(',')\n          const muiPerfTracker = cacheKeySplited[cacheKeySplited.findIndex(getMUIIndex) + 1]\n          if (isUUID(muiPerfTracker) && currentObjectWithMaterials[muiPerfTracker]) {\n            const { material, meshes } = currentObjectWithMaterials[muiPerfTracker]\n            programs.set(muiPerfTracker, {\n              program,\n              material,\n              meshes,\n              drawCounts: {\n                total: 0,\n                type: 'triangle',\n                data: [],\n              },\n              expand: false,\n              visible: true,\n            })\n          }\n        })\n\n        if (programs.size !== getPerf().programs.size) {\n          countGeoDrawCalls(programs)\n          setPerf({\n            programs: programs,\n            triggerProgramsUpdate: getPerf().triggerProgramsUpdate++,\n          })\n        }\n      }\n    })\n\n    return () => {\n      if (PerfLib) {\n        if (typeof window.cancelIdleCallback !== 'undefined') {\n          window.cancelIdleCallback(PerfLib.idleCbId)\n        }\n        window.cancelAnimationFrame(PerfLib.rafId)\n        window.cancelAnimationFrame(PerfLib.checkQueryId)\n      }\n\n      if (matrixUpdate) {\n        THREE.Object3D.prototype.updateMatrixWorld = updateMatrixTemp\n      }\n\n      effectSub()\n      afterEffectSub()\n    }\n  }, [PerfLib, gl, chart, matrixUpdate])\n\n  useEffect(() => {\n    const unsub = addTail(function postRafTailR3FPerf() {\n      if (PerfLib) {\n        PerfLib.paused = true\n        matriceCount.value = 0\n        matriceWorldCount.value = 0\n        setPerf({\n          paused: true,\n          log: {\n            maxMemory: 0,\n            gpu: 0,\n            mem: 0,\n            cpu: 0,\n            fps: 0,\n            totalTime: 0,\n            frameCount: 0,\n          },\n        })\n      }\n      return false\n    })\n\n    return () => {\n      unsub()\n    }\n  }, [])\n\n  return null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}