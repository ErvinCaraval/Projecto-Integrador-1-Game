{"ast":null,"code":"import * as THREE from 'three';\nimport { potpack } from '../libs/potpack.module.js';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new THREE.Scene();\n    this.scene.background = null;\n    this.tinyTarget = new THREE.WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n\n    // Create the Progressive LightMap Texture\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2.texture.channel = 1;\n\n    // Inject some spicy new logic into a standard phong material\n    this.uvMat = new THREE.MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'attribute vec2 uv1;\\n' + '#define USE_LIGHTMAP\\n' + '#define LIGHTMAP_UV uv1\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_LIGHTMAP\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms;\n\n      // Set the new Shader to this\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob];\n\n      // If this object is a light, simply add it to the internal scene\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!');\n        continue;\n      }\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      }\n\n      // Apply the lightmap to the object\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1000 + ob;\n\n      // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object: object\n      });\n      this.compiled = false;\n    }\n\n    // Pack the objects' lightmap UVs into the same global space\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv1 = objects[box.index].geometry.getAttribute('uv').clone();\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute('uv1', uv1);\n      objects[box.index].geometry.getAttribute('uv1').needsUpdate = true;\n    });\n  }\n\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    }\n\n    // Store the original Render Target\n    const oldTarget = this.renderer.getRenderTarget();\n\n    // The blurring plane applies blur to the seams of the lightmap\n    this.blurringPlane.visible = blurEdges;\n\n    // Steal the Object3D from the real world to our special dimension\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    }\n\n    // Render once normally to initialize everything\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    }\n\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    }\n\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n\n    // Render the object's surface maps\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n\n    // Restore the object's Real-time Material and add it back to the original world\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    }\n\n    // Restore the original Render Target\n    this.renderer.setRenderTarget(oldTarget);\n  }\n\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n  */\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!');\n        this.warned = true;\n      }\n      return;\n    }\n    if (this.labelMesh == null) {\n      this.labelMaterial = new THREE.MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: THREE.DoubleSide\n      });\n      this.labelPlane = new THREE.PlaneGeometry(100, 100);\n      this.labelMesh = new THREE.Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position != undefined) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new THREE.MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1.0 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0\n    };\n    blurMaterial.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}`;\n\n      // Set the LightMap Accumulation Buffer\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms;\n\n      // Set the new Shader to this\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n    this.blurringPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = 'Blurring Plane';\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n}\nexport { ProgressiveLightMap };","map":{"version":3,"names":["THREE","potpack","ProgressiveLightMap","constructor","renderer","res","lightMapContainers","compiled","scene","Scene","background","tinyTarget","WebGLRenderTarget","buffer1Active","firstUpdate","warned","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","type","progressiveLightMap2","texture","channel","uvMat","MeshPhongMaterial","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","averagingWindow","userData","addObjectsToLightMap","objects","uv_boxes","padding","ob","length","object","isLight","attach","geometry","hasAttribute","console","warn","blurringPlane","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","forEach","box","uv1","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","setRenderTarget","render","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","showDebugLightmap","position","undefined","labelMesh","labelMaterial","MeshBasicMaterial","map","side","DoubleSide","labelPlane","PlaneGeometry","Mesh","add","copy","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/misc/ProgressiveLightMap.js"],"sourcesContent":["import * as THREE from 'three';\nimport { potpack } from '../libs/potpack.module.js';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nclass ProgressiveLightMap {\n\n\tconstructor( renderer, res = 1024 ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.res = res;\n\t\tthis.lightMapContainers = [];\n\t\tthis.compiled = false;\n\t\tthis.scene = new THREE.Scene();\n\t\tthis.scene.background = null;\n\t\tthis.tinyTarget = new THREE.WebGLRenderTarget( 1, 1 );\n\t\tthis.buffer1Active = false;\n\t\tthis.firstUpdate = true;\n\t\tthis.warned = false;\n\n\t\t// Create the Progressive LightMap Texture\n\t\tconst format = /(Android|iPad|iPhone|iPod)/g.test( navigator.userAgent ) ? THREE.HalfFloatType : THREE.FloatType;\n\t\tthis.progressiveLightMap1 = new THREE.WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2 = new THREE.WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2.texture.channel = 1;\n\n\t\t// Inject some spicy new logic into a standard phong material\n\t\tthis.uvMat = new THREE.MeshPhongMaterial();\n\t\tthis.uvMat.uniforms = {};\n\t\tthis.uvMat.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'attribute vec2 uv1;\\n' +\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\t'#define LIGHTMAP_UV uv1\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\t\t\tconst bodyStart = shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t`\\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n\n\t\t\t// Set the Previous Frame's Texture Buffer and Averaging Window\n\t\t\tshader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };\n\t\t\tshader.uniforms.averagingWindow = { value: 100 };\n\n\t\t\tthis.uvMat.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tthis.uvMat.userData.shader = shader;\n\n\t\t\tthis.compiled = true;\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets these objects' materials' lightmaps and modifies their uv1's.\n\t * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n\t */\n\taddObjectsToLightMap( objects ) {\n\n\t\t// Prepare list of UV bounding boxes for packing later...\n\t\tthis.uv_boxes = []; const padding = 3 / this.res;\n\n\t\tfor ( let ob = 0; ob < objects.length; ob ++ ) {\n\n\t\t\tconst object = objects[ ob ];\n\n\t\t\t// If this object is a light, simply add it to the internal scene\n\t\t\tif ( object.isLight ) {\n\n\t\t\t\tthis.scene.attach( object ); continue;\n\n\t\t\t}\n\n\t\t\tif ( ! object.geometry.hasAttribute( 'uv' ) ) {\n\n\t\t\t\tconsole.warn( 'All lightmap objects need UVs!' ); continue;\n\n\t\t\t}\n\n\t\t\tif ( this.blurringPlane == null ) {\n\n\t\t\t\tthis._initializeBlurPlane( this.res, this.progressiveLightMap1 );\n\n\t\t\t}\n\n\t\t\t// Apply the lightmap to the object\n\t\t\tobject.material.lightMap = this.progressiveLightMap2.texture;\n\t\t\tobject.material.dithering = true;\n\t\t\tobject.castShadow = true;\n\t\t\tobject.receiveShadow = true;\n\t\t\tobject.renderOrder = 1000 + ob;\n\n\t\t\t// Prepare UV boxes for potpack\n\t\t\t// TODO: Size these by object surface area\n\t\t\tthis.uv_boxes.push( { w: 1 + ( padding * 2 ),\n\t\t\t\t\t\t\t\t  h: 1 + ( padding * 2 ), index: ob } );\n\n\t\t\tthis.lightMapContainers.push( { basicMat: object.material, object: object } );\n\n\t\t\tthis.compiled = false;\n\n\t\t}\n\n\t\t// Pack the objects' lightmap UVs into the same global space\n\t\tconst dimensions = potpack( this.uv_boxes );\n\t\tthis.uv_boxes.forEach( ( box ) => {\n\n\t\t\tconst uv1 = objects[ box.index ].geometry.getAttribute( 'uv' ).clone();\n\t\t\tfor ( let i = 0; i < uv1.array.length; i += uv1.itemSize ) {\n\n\t\t\t\tuv1.array[ i ] = ( uv1.array[ i ] + box.x + padding ) / dimensions.w;\n\t\t\t\tuv1.array[ i + 1 ] = ( uv1.array[ i + 1 ] + box.y + padding ) / dimensions.h;\n\n\t\t\t}\n\n\t\t\tobjects[ box.index ].geometry.setAttribute( 'uv1', uv1 );\n\t\t\tobjects[ box.index ].geometry.getAttribute( 'uv1' ).needsUpdate = true;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * This function renders each mesh one at a time into their respective surface maps\n\t * @param {Camera} camera Standard Rendering Camera\n\t * @param {number} blendWindow When >1, samples will accumulate over time.\n\t * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n\t */\n\tupdate( camera, blendWindow = 100, blurEdges = true ) {\n\n\t\tif ( this.blurringPlane == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Store the original Render Target\n\t\tconst oldTarget = this.renderer.getRenderTarget();\n\n\t\t// The blurring plane applies blur to the seams of the lightmap\n\t\tthis.blurringPlane.visible = blurEdges;\n\n\t\t// Steal the Object3D from the real world to our special dimension\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.oldScene =\n\t\t\t\tthis.lightMapContainers[ l ].object.parent;\n\t\t\tthis.scene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Render once normally to initialize everything\n\t\tif ( this.firstUpdate ) {\n\n\t\t\tthis.renderer.setRenderTarget( this.tinyTarget ); // Tiny for Speed\n\t\t\tthis.renderer.render( this.scene, camera );\n\t\t\tthis.firstUpdate = false;\n\n\t\t}\n\n\t\t// Set each object's material to the UV Unwrapped Surface Mapping Version\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.uvMat.uniforms.averagingWindow = { value: blendWindow };\n\t\t\tthis.lightMapContainers[ l ].object.material = this.uvMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.frustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled = false;\n\n\t\t}\n\n\t\t// Ping-pong two surface buffers for reading/writing\n\t\tconst activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n\t\tconst inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n\n\t\t// Render the object's surface maps\n\t\tthis.renderer.setRenderTarget( activeMap );\n\t\tthis.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.buffer1Active = ! this.buffer1Active;\n\t\tthis.renderer.render( this.scene, camera );\n\n\t\t// Restore the object's Real-time Material and add it back to the original world\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.material = this.lightMapContainers[ l ].basicMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldScene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Restore the original Render Target\n\t\tthis.renderer.setRenderTarget( oldTarget );\n\n\t}\n\n\t/** DEBUG\n\t * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n\t * @param {boolean} visible Whether the debug plane should be visible\n\t * @param {Vector3} position Where the debug plane should be drawn\n\t*/\n\tshowDebugLightmap( visible, position = undefined ) {\n\n\t\tif ( this.lightMapContainers.length == 0 ) {\n\n\t\t\tif ( ! this.warned ) {\n\n\t\t\t\tconsole.warn( 'Call this after adding the objects!' ); this.warned = true;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.labelMesh == null ) {\n\n\t\t\tthis.labelMaterial = new THREE.MeshBasicMaterial(\n\t\t\t\t{ map: this.progressiveLightMap1.texture, side: THREE.DoubleSide } );\n\t\t\tthis.labelPlane = new THREE.PlaneGeometry( 100, 100 );\n\t\t\tthis.labelMesh = new THREE.Mesh( this.labelPlane, this.labelMaterial );\n\t\t\tthis.labelMesh.position.y = 250;\n\t\t\tthis.lightMapContainers[ 0 ].object.parent.add( this.labelMesh );\n\n\t\t}\n\n\t\tif ( position != undefined ) {\n\n\t\t\tthis.labelMesh.position.copy( position );\n\n\t\t}\n\n\t\tthis.labelMesh.visible = visible;\n\n\t}\n\n\t/**\n\t * INTERNAL Creates the Blurring Plane\n\t * @param {number} res The square resolution of this object's lightMap.\n\t * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n\t */\n\t_initializeBlurPlane( res, lightMap = null ) {\n\n\t\tconst blurMaterial = new THREE.MeshBasicMaterial();\n\t\tblurMaterial.uniforms = { previousShadowMap: { value: null },\n\t\t\t\t\t\t\t\t  pixelOffset: { value: 1.0 / res },\n\t\t\t\t\t\t\t\t  polygonOffset: true, polygonOffsetFactor: - 1, polygonOffsetUnits: 3.0 };\n\t\tblurMaterial.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\t\t\tconst bodyStart\t= shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t\t`\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}`;\n\n\t\t\t// Set the LightMap Accumulation Buffer\n\t\t\tshader.uniforms.previousShadowMap = { value: lightMap.texture };\n\t\t\tshader.uniforms.pixelOffset = { value: 0.5 / res };\n\t\t\tblurMaterial.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tblurMaterial.userData.shader = shader;\n\n\t\t\tthis.compiled = true;\n\n\t\t};\n\n\t\tthis.blurringPlane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), blurMaterial );\n\t\tthis.blurringPlane.name = 'Blurring Plane';\n\t\tthis.blurringPlane.frustumCulled = false;\n\t\tthis.blurringPlane.renderOrder = 0;\n\t\tthis.blurringPlane.material.depthWrite = false;\n\t\tthis.scene.add( this.blurringPlane );\n\n\t}\n\n}\n\nexport { ProgressiveLightMap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}