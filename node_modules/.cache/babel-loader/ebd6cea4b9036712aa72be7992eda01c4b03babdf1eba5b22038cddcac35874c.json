{"ast":null,"code":"/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\nimport { MeshPhongMaterial, ShaderChunk, ShaderLib, UniformsUtils } from 'three';\nclass PackedPhongMaterial extends MeshPhongMaterial {\n  constructor(parameters) {\n    super();\n    this.defines = {};\n    this.type = 'PackedPhongMaterial';\n    this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.normal_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, `#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, 'void main() {', ShaderChunk.uv_vertex, `#ifdef USE_MAP\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvMapUv = decodeUV(vMapUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.color_vertex, ShaderChunk.morphcolor_vertex, ShaderChunk.beginnormal_vertex, `#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`, ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, ShaderChunk.normal_vertex, ShaderChunk.begin_vertex, `#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`, ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, '}'].join('\\n');\n\n    // Use the original MeshPhongMaterial's fragmentShader.\n    this.fragmentShader = ShaderLib.phong.fragmentShader;\n    this.setValues(parameters);\n  }\n}\nexport { PackedPhongMaterial };","map":{"version":3,"names":["MeshPhongMaterial","ShaderChunk","ShaderLib","UniformsUtils","PackedPhongMaterial","constructor","parameters","defines","type","uniforms","merge","phong","quantizeMatPos","value","quantizeMatUV","vertexShader","common","uv_pars_vertex","displacementmap_pars_vertex","envmap_pars_vertex","color_pars_vertex","fog_pars_vertex","normal_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","color_vertex","morphcolor_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","normal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","envmap_vertex","shadowmap_vertex","fog_vertex","join","fragmentShader","setValues"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/utils/PackedPhongMaterial.js"],"sourcesContent":["\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\nimport {\n\tMeshPhongMaterial,\n\tShaderChunk,\n\tShaderLib,\n\tUniformsUtils,\n} from 'three';\n\nclass PackedPhongMaterial extends MeshPhongMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = {};\n\t\tthis.type = 'PackedPhongMaterial';\n\t\tthis.uniforms = UniformsUtils.merge( [\n\n\t\t\tShaderLib.phong.uniforms,\n\n\t\t\t{\n\t\t\t\tquantizeMatPos: { value: null },\n\t\t\t\tquantizeMatUV: { value: null }\n\t\t\t}\n\n\t\t] );\n\n\t\tthis.vertexShader = [\n\t\t\t'#define PHONG',\n\n\t\t\t'varying vec3 vViewPosition;',\n\n\t\t\tShaderChunk.common,\n\t\t\tShaderChunk.uv_pars_vertex,\n\t\t\tShaderChunk.displacementmap_pars_vertex,\n\t\t\tShaderChunk.envmap_pars_vertex,\n\t\t\tShaderChunk.color_pars_vertex,\n\t\t\tShaderChunk.fog_pars_vertex,\n\t\t\tShaderChunk.normal_pars_vertex,\n\t\t\tShaderChunk.morphtarget_pars_vertex,\n\t\t\tShaderChunk.skinning_pars_vertex,\n\t\t\tShaderChunk.shadowmap_pars_vertex,\n\t\t\tShaderChunk.logdepthbuf_pars_vertex,\n\t\t\tShaderChunk.clipping_planes_pars_vertex,\n\n\t\t\t`#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t`#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t`#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t`#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t'void main() {',\n\n\t\t\tShaderChunk.uv_vertex,\n\n\t\t\t`#ifdef USE_MAP\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvMapUv = decodeUV(vMapUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\tShaderChunk.color_vertex,\n\t\t\tShaderChunk.morphcolor_vertex,\n\n\t\t\tShaderChunk.beginnormal_vertex,\n\n\t\t\t`#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`,\n\n\t\t\tShaderChunk.morphnormal_vertex,\n\t\t\tShaderChunk.skinbase_vertex,\n\t\t\tShaderChunk.skinnormal_vertex,\n\t\t\tShaderChunk.defaultnormal_vertex,\n\t\t\tShaderChunk.normal_vertex,\n\n\t\t\tShaderChunk.begin_vertex,\n\n\t\t\t`#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\tShaderChunk.morphtarget_vertex,\n\t\t\tShaderChunk.skinning_vertex,\n\t\t\tShaderChunk.displacementmap_vertex,\n\t\t\tShaderChunk.project_vertex,\n\t\t\tShaderChunk.logdepthbuf_vertex,\n\t\t\tShaderChunk.clipping_planes_vertex,\n\n\t\t\t'vViewPosition = - mvPosition.xyz;',\n\n\t\t\tShaderChunk.worldpos_vertex,\n\t\t\tShaderChunk.envmap_vertex,\n\t\t\tShaderChunk.shadowmap_vertex,\n\t\t\tShaderChunk.fog_vertex,\n\n\t\t\t'}',\n\t\t].join( '\\n' );\n\n\t\t// Use the original MeshPhongMaterial's fragmentShader.\n\t\tthis.fragmentShader = ShaderLib.phong.fragmentShader;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nexport { PackedPhongMaterial };\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA,SACCA,iBAAiB,EACjBC,WAAW,EACXC,SAAS,EACTC,aAAa,QACP,OAAO;AAEd,MAAMC,mBAAmB,SAASJ,iBAAiB,CAAC;EAEnDK,WAAWA,CAAEC,UAAU,EAAG;IAEzB,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAACC,IAAI,GAAG,qBAAqB;IACjC,IAAI,CAACC,QAAQ,GAAGN,aAAa,CAACO,KAAK,CAAE,CAEpCR,SAAS,CAACS,KAAK,CAACF,QAAQ,EAExB;MACCG,cAAc,EAAE;QAAEC,KAAK,EAAE;MAAK,CAAC;MAC/BC,aAAa,EAAE;QAAED,KAAK,EAAE;MAAK;IAC9B,CAAC,CAEA,CAAC;IAEH,IAAI,CAACE,YAAY,GAAG,CACnB,eAAe,EAEf,6BAA6B,EAE7Bd,WAAW,CAACe,MAAM,EAClBf,WAAW,CAACgB,cAAc,EAC1BhB,WAAW,CAACiB,2BAA2B,EACvCjB,WAAW,CAACkB,kBAAkB,EAC9BlB,WAAW,CAACmB,iBAAiB,EAC7BnB,WAAW,CAACoB,eAAe,EAC3BpB,WAAW,CAACqB,kBAAkB,EAC9BrB,WAAW,CAACsB,uBAAuB,EACnCtB,WAAW,CAACuB,oBAAoB,EAChCvB,WAAW,CAACwB,qBAAqB,EACjCxB,WAAW,CAACyB,uBAAuB,EACnCzB,WAAW,CAAC0B,2BAA2B,EAEtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAEP;AACJ;AACA;AACA;AACA,WAAW,EAEP;AACJ;AACA;AACA;AACA,WAAW,EAEP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAER,eAAe,EAEf1B,WAAW,CAAC2B,SAAS,EAEpB;AACJ;AACA;AACA;AACA,WAAW,EAER3B,WAAW,CAAC4B,YAAY,EACxB5B,WAAW,CAAC6B,iBAAiB,EAE7B7B,WAAW,CAAC8B,kBAAkB,EAE7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAEF9B,WAAW,CAAC+B,kBAAkB,EAC9B/B,WAAW,CAACgC,eAAe,EAC3BhC,WAAW,CAACiC,iBAAiB,EAC7BjC,WAAW,CAACkC,oBAAoB,EAChClC,WAAW,CAACmC,aAAa,EAEzBnC,WAAW,CAACoC,YAAY,EAEvB;AACJ;AACA;AACA;AACA,WAAW,EAERpC,WAAW,CAACqC,kBAAkB,EAC9BrC,WAAW,CAACsC,eAAe,EAC3BtC,WAAW,CAACuC,sBAAsB,EAClCvC,WAAW,CAACwC,cAAc,EAC1BxC,WAAW,CAACyC,kBAAkB,EAC9BzC,WAAW,CAAC0C,sBAAsB,EAElC,mCAAmC,EAEnC1C,WAAW,CAAC2C,eAAe,EAC3B3C,WAAW,CAAC4C,aAAa,EACzB5C,WAAW,CAAC6C,gBAAgB,EAC5B7C,WAAW,CAAC8C,UAAU,EAEtB,GAAG,CACH,CAACC,IAAI,CAAE,IAAK,CAAC;;IAEd;IACA,IAAI,CAACC,cAAc,GAAG/C,SAAS,CAACS,KAAK,CAACsC,cAAc;IAEpD,IAAI,CAACC,SAAS,CAAE5C,UAAW,CAAC;EAE7B;AAED;AAEA,SAASF,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}