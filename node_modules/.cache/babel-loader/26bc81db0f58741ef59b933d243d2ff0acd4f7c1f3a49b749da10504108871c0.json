{"ast":null,"code":"import { BackSide, BoxGeometry, Mesh, PerspectiveCamera, Scene, ShaderLib, ShaderMaterial, UniformsUtils } from 'three';\nimport { Pass } from './Pass.js';\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube, opacity = 1) {\n    super();\n    this.camera = camera;\n    this.needsSwap = false;\n    this.cubeShader = ShaderLib['cube'];\n    this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n      vertexShader: this.cubeShader.vertexShader,\n      fragmentShader: this.cubeShader.fragmentShader,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    }));\n    Object.defineProperty(this.cubeMesh.material, 'envMap', {\n      get: function () {\n        return this.uniforms.tCube.value;\n      }\n    });\n    this.tCube = tCube;\n    this.opacity = opacity;\n    this.cubeScene = new Scene();\n    this.cubeCamera = new PerspectiveCamera();\n    this.cubeScene.add(this.cubeMesh);\n  }\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive*/) {\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube;\n    this.cubeMesh.material.uniforms.tFlip.value = this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n  dispose() {\n    this.cubeMesh.geometry.dispose();\n    this.cubeMesh.material.dispose();\n  }\n}\nexport { CubeTexturePass };","map":{"version":3,"names":["BackSide","BoxGeometry","Mesh","PerspectiveCamera","Scene","ShaderLib","ShaderMaterial","UniformsUtils","Pass","CubeTexturePass","constructor","camera","tCube","opacity","needsSwap","cubeShader","cubeMesh","uniforms","clone","vertexShader","fragmentShader","depthTest","depthWrite","side","Object","defineProperty","material","get","value","cubeScene","cubeCamera","add","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","tFlip","isCubeTexture","isRenderTargetTexture","transparent","setRenderTarget","renderToScreen","clear","dispose","geometry"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/postprocessing/CubeTexturePass.js"],"sourcesContent":["import {\n\tBackSide,\n\tBoxGeometry,\n\tMesh,\n\tPerspectiveCamera,\n\tScene,\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass } from './Pass.js';\n\nclass CubeTexturePass extends Pass {\n\n\tconstructor( camera, tCube, opacity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.camera = camera;\n\n\t\tthis.needsSwap = false;\n\n\t\tthis.cubeShader = ShaderLib[ 'cube' ];\n\t\tthis.cubeMesh = new Mesh(\n\t\t\tnew BoxGeometry( 10, 10, 10 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: UniformsUtils.clone( this.cubeShader.uniforms ),\n\t\t\t\tvertexShader: this.cubeShader.vertexShader,\n\t\t\t\tfragmentShader: this.cubeShader.fragmentShader,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tside: BackSide\n\t\t\t} )\n\t\t);\n\n\t\tObject.defineProperty( this.cubeMesh.material, 'envMap', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.tCube.value;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.tCube = tCube;\n\t\tthis.opacity = opacity;\n\n\t\tthis.cubeScene = new Scene();\n\t\tthis.cubeCamera = new PerspectiveCamera();\n\t\tthis.cubeScene.add( this.cubeMesh );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\tthis.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );\n\n\t\tthis.cubeMesh.material.uniforms.tCube.value = this.tCube;\n\t\tthis.cubeMesh.material.uniforms.tFlip.value = ( this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\tthis.cubeMesh.material.uniforms.opacity.value = this.opacity;\n\t\tthis.cubeMesh.material.transparent = ( this.opacity < 1.0 );\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.cubeScene, this.cubeCamera );\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cubeMesh.geometry.dispose();\n\t\tthis.cubeMesh.material.dispose();\n\n\t}\n\n}\n\nexport { CubeTexturePass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}