{"ast":null,"code":"/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n *  https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n *  https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html\n *\n **/\n\nimport { AddOperation, BackSide, BufferGeometry, ClampToEdgeWrapping, Color, DoubleSide, EquirectangularReflectionMapping, EquirectangularRefractionMapping, FileLoader, Float32BufferAttribute, FrontSide, LineBasicMaterial, LineSegments, Loader, Mesh, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MirroredRepeatWrapping, Points, PointsMaterial, RepeatWrapping, SRGBColorSpace, TextureLoader, Vector2 } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\nlet _lwoTree;\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path;\n\n    // give the mesh a default name based on the filename\n    const modelName = url.split(path).pop().split('.')[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n\n      // console.timeEnd( 'Total parsing: ' );\n    }, onProgress, onError);\n  }\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n\n    // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = [];\n\n    // final array containing meshes with scene graph hierarchy set up\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n\n    // convert materials to line or point mats if required\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n\n    // if there is only one material, return that directly instead of array\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    if (materialType !== MeshPhongMaterial) delete params.refractionRatio; // PBR materials do not support \"refractionRatio\"\n\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name /*, textures*/) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          maps.map.colorSpace = SRGBColorSpace;\n          break;\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 1;\n          break;\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specularMap.colorSpace = SRGBColorSpace;\n          maps.specular = 0xffffff;\n          break;\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissiveMap.colorSpace = SRGBColorSpace;\n          maps.emissive = 0x808080;\n          break;\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 1;\n          break;\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n\n    // LWO BSDF materials can have both spec and rough, but this is not valid in three\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  }\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            maps.map.colorSpace = SRGBColorSpace;\n            break;\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specularMap.colorSpace = SRGBColorSpace;\n            maps.specular = 0xffffff;\n            break;\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissiveMap.colorSpace = SRGBColorSpace;\n            maps.emissive = 0x808080;\n            break;\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n\n    // don't use color data if color map is present\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes /*, maps*/) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes['Refraction Index']) params.refractionRatio = 0.98 / attributes['Refraction Index'].value;\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n\n        // Reflectivity and refraction mapping don't work well together in Phong materials\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== undefined) {\n          attributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible\n        }\n        attributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave.\n      } else envMap.mapping = EquirectangularReflectionMapping;\n      maps.envMap = envMap;\n    }\n  }\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = '';\n    if (!_lwoTree.textures) return fileName;\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.');\n    });\n    return texture;\n  }\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n\n    // TODO: z may need to be reversed to account for coordinate system change\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n\n    // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  }\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0; // create new indices in numerical order\n    const indexPairs = {}; // original indices mapped to numerical indices\n\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n\n    // the loop above doesn't add the last group, do that here.\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n\n    // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.slice(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"names":["AddOperation","BackSide","BufferGeometry","ClampToEdgeWrapping","Color","DoubleSide","EquirectangularReflectionMapping","EquirectangularRefractionMapping","FileLoader","Float32BufferAttribute","FrontSide","LineBasicMaterial","LineSegments","Loader","Mesh","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MirroredRepeatWrapping","Points","PointsMaterial","RepeatWrapping","SRGBColorSpace","TextureLoader","Vector2","IFFParser","_lwoTree","LWOLoader","constructor","manager","parameters","resourcePath","undefined","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","filtered","filter","Boolean","length","m","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","attributes","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","refractionRatio","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","colorSpace","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","aoMap","fromArray","value","Transparency","opacity","bumpScale","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","setAttribute","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","Array","from","count","uvs","uvIndices","j","morphTargets","remappedPoints","array","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/loaders/LWOLoader.js"],"sourcesContent":["/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n *  https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n *  https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html\n *\n **/\n\nimport {\n\tAddOperation,\n\tBackSide,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMesh,\n\tMeshPhongMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tPoints,\n\tPointsMaterial,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tVector2\n} from 'three';\n\nimport { IFFParser } from './lwo/IFFParser.js';\n\nlet _lwoTree;\n\nclass LWOLoader extends Loader {\n\n\tconstructor( manager, parameters = {} ) {\n\n\t\tsuper( manager );\n\n\t\tthis.resourcePath = ( parameters.resourcePath !== undefined ) ? parameters.resourcePath : '';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? extractParentUrl( url, 'Objects' ) : scope.path;\n\n\t\t// give the mesh a default name based on the filename\n\t\tconst modelName = url.split( path ).pop().split( '.' )[ 0 ];\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t// console.time( 'Total parsing: ' );\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer, path, modelName ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'Total parsing: ' );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( iffBuffer, path, modelName ) {\n\n\t\t_lwoTree = new IFFParser().parse( iffBuffer );\n\n\t\t// console.log( 'lwoTree', lwoTree );\n\n\t\tconst textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\treturn new LWOTreeParser( textureLoader ).parse( modelName );\n\n\t}\n\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n\n\tconstructor( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tparse( modelName ) {\n\n\t\tthis.materials = new MaterialParser( this.textureLoader ).parse();\n\t\tthis.defaultLayerName = modelName;\n\n\t\tthis.meshes = this.parseLayers();\n\n\t\treturn {\n\t\t\tmaterials: this.materials,\n\t\t\tmeshes: this.meshes,\n\t\t};\n\n\t}\n\n\tparseLayers() {\n\n\t\t// array of all meshes for building hierarchy\n\t\tconst meshes = [];\n\n\t\t// final array containing meshes with scene graph hierarchy set up\n\t\tconst finalMeshes = [];\n\n\t\tconst geometryParser = new GeometryParser();\n\n\t\tconst scope = this;\n\t\t_lwoTree.layers.forEach( function ( layer ) {\n\n\t\t\tconst geometry = geometryParser.parse( layer.geometry, layer );\n\n\t\t\tconst mesh = scope.parseMesh( geometry, layer );\n\n\t\t\tmeshes[ layer.number ] = mesh;\n\n\t\t\tif ( layer.parent === - 1 ) finalMeshes.push( mesh );\n\t\t\telse meshes[ layer.parent ].add( mesh );\n\n\n\t\t} );\n\n\t\tthis.applyPivots( finalMeshes );\n\n\t\treturn finalMeshes;\n\n\t}\n\n\tparseMesh( geometry, layer ) {\n\n\t\tlet mesh;\n\n\t\tconst materials = this.getMaterials( geometry.userData.matNames, layer.geometry.type );\n\n\t\tif ( layer.geometry.type === 'points' ) mesh = new Points( geometry, materials );\n\t\telse if ( layer.geometry.type === 'lines' ) mesh = new LineSegments( geometry, materials );\n\t\telse mesh = new Mesh( geometry, materials );\n\n\t\tif ( layer.name ) mesh.name = layer.name;\n\t\telse mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n\n\t\tmesh.userData.pivot = layer.pivot;\n\n\t\treturn mesh;\n\n\t}\n\n\t// TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\tapplyPivots( meshes ) {\n\n\t\tmeshes.forEach( function ( mesh ) {\n\n\t\t\tmesh.traverse( function ( child ) {\n\n\t\t\t\tconst pivot = child.userData.pivot;\n\n\t\t\t\tchild.position.x += pivot[ 0 ];\n\t\t\t\tchild.position.y += pivot[ 1 ];\n\t\t\t\tchild.position.z += pivot[ 2 ];\n\n\t\t\t\tif ( child.parent ) {\n\n\t\t\t\t\tconst parentPivot = child.parent.userData.pivot;\n\n\t\t\t\t\tchild.position.x -= parentPivot[ 0 ];\n\t\t\t\t\tchild.position.y -= parentPivot[ 1 ];\n\t\t\t\t\tchild.position.z -= parentPivot[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tgetMaterials( namesArray, type ) {\n\n\t\tconst materials = [];\n\n\t\tconst scope = this;\n\n\t\tnamesArray.forEach( function ( name, i ) {\n\n\t\t\tmaterials[ i ] = scope.getMaterialByName( name );\n\n\t\t} );\n\n\t\t// convert materials to line or point mats if required\n\t\tif ( type === 'points' || type === 'lines' ) {\n\n\t\t\tmaterials.forEach( function ( mat, i ) {\n\n\t\t\t\tconst spec = {\n\t\t\t\t\tcolor: mat.color,\n\t\t\t\t};\n\n\t\t\t\tif ( type === 'points' ) {\n\n\t\t\t\t\tspec.size = 0.1;\n\t\t\t\t\tspec.map = mat.map;\n\t\t\t\t\tmaterials[ i ] = new PointsMaterial( spec );\n\n\t\t\t\t} else if ( type === 'lines' ) {\n\n\t\t\t\t\tmaterials[ i ] = new LineBasicMaterial( spec );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// if there is only one material, return that directly instead of array\n\t\tconst filtered = materials.filter( Boolean );\n\t\tif ( filtered.length === 1 ) return filtered[ 0 ];\n\n\t\treturn materials;\n\n\t}\n\n\tgetMaterialByName( name ) {\n\n\t\treturn this.materials.filter( function ( m ) {\n\n\t\t\treturn m.name === name;\n\n\t\t} )[ 0 ];\n\n\t}\n\n}\n\nclass MaterialParser {\n\n\tconstructor( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tparse() {\n\n\t\tconst materials = [];\n\t\tthis.textures = {};\n\n\t\tfor ( const name in _lwoTree.materials ) {\n\n\t\t\tif ( _lwoTree.format === 'LWO3' ) {\n\n\t\t\t\tmaterials.push( this.parseMaterial( _lwoTree.materials[ name ], name, _lwoTree.textures ) );\n\n\t\t\t} else if ( _lwoTree.format === 'LWO2' ) {\n\n\t\t\t\tmaterials.push( this.parseMaterialLwo2( _lwoTree.materials[ name ], name, _lwoTree.textures ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseMaterial( materialData, name, textures ) {\n\n\t\tlet params = {\n\t\t\tname: name,\n\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t};\n\n\t\tconst connections = this.parseConnections( materialData.connections, materialData.nodes );\n\n\t\tconst maps = this.parseTextureNodes( connections.maps );\n\n\t\tthis.parseAttributeImageMaps( connections.attributes, textures, maps, materialData.maps );\n\n\t\tconst attributes = this.parseAttributes( connections.attributes, maps );\n\n\t\tthis.parseEnvMap( connections, maps, attributes );\n\n\t\tparams = Object.assign( maps, params );\n\t\tparams = Object.assign( params, attributes );\n\n\t\tconst materialType = this.getMaterialType( connections.attributes );\n\n\t\tif ( materialType !== MeshPhongMaterial ) delete params.refractionRatio; // PBR materials do not support \"refractionRatio\"\n\n\t\treturn new materialType( params );\n\n\t}\n\n\tparseMaterialLwo2( materialData, name/*, textures*/ ) {\n\n\t\tlet params = {\n\t\t\tname: name,\n\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t};\n\n\t\tconst attributes = this.parseAttributes( materialData.attributes, {} );\n\t\tparams = Object.assign( params, attributes );\n\t\treturn new MeshPhongMaterial( params );\n\n\t}\n\n\t// Note: converting from left to right handed coords by switching x -> -x in vertices, and\n\t// then switching mat FrontSide -> BackSide\n\t// NB: this means that FrontSide and BackSide have been switched!\n\tgetSide( attributes ) {\n\n\t\tif ( ! attributes.side ) return BackSide;\n\n\t\tswitch ( attributes.side ) {\n\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\treturn BackSide;\n\t\t\tcase 2: return FrontSide;\n\t\t\tcase 3: return DoubleSide;\n\n\t\t}\n\n\t}\n\n\tgetSmooth( attributes ) {\n\n\t\tif ( ! attributes.smooth ) return true;\n\t\treturn ! attributes.smooth;\n\n\t}\n\n\tparseConnections( connections, nodes ) {\n\n\t\tconst materialConnections = {\n\t\t\tmaps: {}\n\t\t};\n\n\t\tconst inputName = connections.inputName;\n\t\tconst inputNodeName = connections.inputNodeName;\n\t\tconst nodeName = connections.nodeName;\n\n\t\tconst scope = this;\n\t\tinputName.forEach( function ( name, index ) {\n\n\t\t\tif ( name === 'Material' ) {\n\n\t\t\t\tconst matNode = scope.getNodeByRefName( inputNodeName[ index ], nodes );\n\t\t\t\tmaterialConnections.attributes = matNode.attributes;\n\t\t\t\tmaterialConnections.envMap = matNode.fileName;\n\t\t\t\tmaterialConnections.name = inputNodeName[ index ];\n\n\t\t\t}\n\n\t\t} );\n\n\t\tnodeName.forEach( function ( name, index ) {\n\n\t\t\tif ( name === materialConnections.name ) {\n\n\t\t\t\tmaterialConnections.maps[ inputName[ index ] ] = scope.getNodeByRefName( inputNodeName[ index ], nodes );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn materialConnections;\n\n\t}\n\n\tgetNodeByRefName( refName, nodes ) {\n\n\t\tfor ( const name in nodes ) {\n\n\t\t\tif ( nodes[ name ].refName === refName ) return nodes[ name ];\n\n\t\t}\n\n\t}\n\n\tparseTextureNodes( textureNodes ) {\n\n\t\tconst maps = {};\n\n\t\tfor ( const name in textureNodes ) {\n\n\t\t\tconst node = textureNodes[ name ];\n\t\t\tconst path = node.fileName;\n\n\t\t\tif ( ! path ) return;\n\n\t\t\tconst texture = this.loadTexture( path );\n\n\t\t\tif ( node.widthWrappingMode !== undefined ) texture.wrapS = this.getWrappingType( node.widthWrappingMode );\n\t\t\tif ( node.heightWrappingMode !== undefined ) texture.wrapT = this.getWrappingType( node.heightWrappingMode );\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'Color':\n\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\tmaps.map.colorSpace = SRGBColorSpace;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Roughness':\n\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Specular':\n\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\tmaps.specularMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Luminous':\n\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\tmaps.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Luminous Color':\n\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Metallic':\n\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Transparency':\n\t\t\t\tcase 'Alpha':\n\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Normal':\n\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\tif ( node.amplitude !== undefined ) maps.normalScale = new Vector2( node.amplitude, node.amplitude );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// LWO BSDF materials can have both spec and rough, but this is not valid in three\n\t\tif ( maps.roughnessMap && maps.specularMap ) delete maps.specularMap;\n\n\t\treturn maps;\n\n\t}\n\n\t// maps can also be defined on individual material attributes, parse those here\n\t// This occurs on Standard (Phong) surfaces\n\tparseAttributeImageMaps( attributes, textures, maps ) {\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute.maps ) {\n\n\t\t\t\tconst mapData = attribute.maps[ 0 ];\n\n\t\t\t\tconst path = this.getTexturePathByIndex( mapData.imageIndex, textures );\n\t\t\t\tif ( ! path ) return;\n\n\t\t\t\tconst texture = this.loadTexture( path );\n\n\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapS = this.getWrappingType( mapData.wrap.w );\n\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapT = this.getWrappingType( mapData.wrap.h );\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\t\tmaps.map.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Diffuse':\n\t\t\t\t\t\tmaps.aoMap = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Roughness':\n\t\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Specular':\n\t\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\t\tmaps.specularMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Luminosity':\n\t\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\t\tmaps.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Metallic':\n\t\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Transparency':\n\t\t\t\t\tcase 'Alpha':\n\t\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseAttributes( attributes, maps ) {\n\n\t\tconst params = {};\n\n\t\t// don't use color data if color map is present\n\t\tif ( attributes.Color && ! maps.map ) {\n\n\t\t\tparams.color = new Color().fromArray( attributes.Color.value );\n\n\t\t} else {\n\n\t\t\tparams.color = new Color();\n\n\t\t}\n\n\n\t\tif ( attributes.Transparency && attributes.Transparency.value !== 0 ) {\n\n\t\t\tparams.opacity = 1 - attributes.Transparency.value;\n\t\t\tparams.transparent = true;\n\n\t\t}\n\n\t\tif ( attributes[ 'Bump Height' ] ) params.bumpScale = attributes[ 'Bump Height' ].value * 0.1;\n\n\t\tthis.parsePhysicalAttributes( params, attributes, maps );\n\t\tthis.parseStandardAttributes( params, attributes, maps );\n\t\tthis.parsePhongAttributes( params, attributes, maps );\n\n\t\treturn params;\n\n\t}\n\n\tparsePhysicalAttributes( params, attributes/*, maps*/ ) {\n\n\t\tif ( attributes.Clearcoat && attributes.Clearcoat.value > 0 ) {\n\n\t\t\tparams.clearcoat = attributes.Clearcoat.value;\n\n\t\t\tif ( attributes[ 'Clearcoat Gloss' ] ) {\n\n\t\t\t\tparams.clearcoatRoughness = 0.5 * ( 1 - attributes[ 'Clearcoat Gloss' ].value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseStandardAttributes( params, attributes, maps ) {\n\n\n\t\tif ( attributes.Luminous ) {\n\n\t\t\tparams.emissiveIntensity = attributes.Luminous.value;\n\n\t\t\tif ( attributes[ 'Luminous Color' ] && ! maps.emissive ) {\n\n\t\t\t\tparams.emissive = new Color().fromArray( attributes[ 'Luminous Color' ].value );\n\n\t\t\t} else {\n\n\t\t\t\tparams.emissive = new Color( 0x808080 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( attributes.Roughness && ! maps.roughnessMap ) params.roughness = attributes.Roughness.value;\n\t\tif ( attributes.Metallic && ! maps.metalnessMap ) params.metalness = attributes.Metallic.value;\n\n\t}\n\n\tparsePhongAttributes( params, attributes, maps ) {\n\n\t\tif ( attributes[ 'Refraction Index' ] ) params.refractionRatio = 0.98 / attributes[ 'Refraction Index' ].value;\n\n\t\tif ( attributes.Diffuse ) params.color.multiplyScalar( attributes.Diffuse.value );\n\n\t\tif ( attributes.Reflection ) {\n\n\t\t\tparams.reflectivity = attributes.Reflection.value;\n\t\t\tparams.combine = AddOperation;\n\n\t\t}\n\n\t\tif ( attributes.Luminosity ) {\n\n\t\t\tparams.emissiveIntensity = attributes.Luminosity.value;\n\n\t\t\tif ( ! maps.emissiveMap && ! maps.map ) {\n\n\t\t\t\tparams.emissive = params.color;\n\n\t\t\t} else {\n\n\t\t\t\tparams.emissive = new Color( 0x808080 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\t\tif ( ! attributes.Roughness && attributes.Specular && ! maps.specularMap ) {\n\n\t\t\tif ( attributes[ 'Color Highlight' ] ) {\n\n\t\t\t\tparams.specular = new Color().setScalar( attributes.Specular.value ).lerp( params.color.clone().multiplyScalar( attributes.Specular.value ), attributes[ 'Color Highlight' ].value );\n\n\t\t\t} else {\n\n\t\t\t\tparams.specular = new Color().setScalar( attributes.Specular.value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.specular && attributes.Glossiness ) params.shininess = 7 + Math.pow( 2, attributes.Glossiness.value * 12 + 2 );\n\n\t}\n\n\tparseEnvMap( connections, maps, attributes ) {\n\n\t\tif ( connections.envMap ) {\n\n\t\t\tconst envMap = this.loadTexture( connections.envMap );\n\n\t\t\tif ( attributes.transparent && attributes.opacity < 0.999 ) {\n\n\t\t\t\tenvMap.mapping = EquirectangularRefractionMapping;\n\n\t\t\t\t// Reflectivity and refraction mapping don't work well together in Phong materials\n\t\t\t\tif ( attributes.reflectivity !== undefined ) {\n\n\t\t\t\t\tdelete attributes.reflectivity;\n\t\t\t\t\tdelete attributes.combine;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes.metalness !== undefined ) {\n\n\t\t\t\t\tattributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible\n\n\t\t\t\t}\n\n\t\t\t\tattributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave.\n\n\t\t\t} else envMap.mapping = EquirectangularReflectionMapping;\n\n\t\t\tmaps.envMap = envMap;\n\n\t\t}\n\n\t}\n\n\t// get texture defined at top level by its index\n\tgetTexturePathByIndex( index ) {\n\n\t\tlet fileName = '';\n\n\t\tif ( ! _lwoTree.textures ) return fileName;\n\n\t\t_lwoTree.textures.forEach( function ( texture ) {\n\n\t\t\tif ( texture.index === index ) fileName = texture.fileName;\n\n\t\t} );\n\n\t\treturn fileName;\n\n\t}\n\n\tloadTexture( path ) {\n\n\t\tif ( ! path ) return null;\n\n\t\tconst texture = this.textureLoader.load(\n\t\t\tpath,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfunction () {\n\n\t\t\t\tconsole.warn( 'LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.' );\n\n\t\t\t}\n\t\t);\n\n\t\treturn texture;\n\n\t}\n\n\t// 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\tgetWrappingType( num ) {\n\n\t\tswitch ( num ) {\n\n\t\t\tcase 0:\n\t\t\t\tconsole.warn( 'LWOLoader: \"Reset\" texture wrapping type is not supported in three.js' );\n\t\t\t\treturn ClampToEdgeWrapping;\n\t\t\tcase 1: return RepeatWrapping;\n\t\t\tcase 2: return MirroredRepeatWrapping;\n\t\t\tcase 3: return ClampToEdgeWrapping;\n\n\t\t}\n\n\t}\n\n\tgetMaterialType( nodeData ) {\n\n\t\tif ( nodeData.Clearcoat && nodeData.Clearcoat.value > 0 ) return MeshPhysicalMaterial;\n\t\tif ( nodeData.Roughness ) return MeshStandardMaterial;\n\t\treturn MeshPhongMaterial;\n\n\t}\n\n}\n\nclass GeometryParser {\n\n\tparse( geoData, layer ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( geoData.points, 3 ) );\n\n\t\tconst indices = this.splitIndices( geoData.vertexIndices, geoData.polygonDimensions );\n\t\tgeometry.setIndex( indices );\n\n\t\tthis.parseGroups( geometry, geoData );\n\n\t\tgeometry.computeVertexNormals();\n\n\t\tthis.parseUVs( geometry, layer, indices );\n\t\tthis.parseMorphTargets( geometry, layer, indices );\n\n\t\t// TODO: z may need to be reversed to account for coordinate system change\n\t\tgeometry.translate( - layer.pivot[ 0 ], - layer.pivot[ 1 ], - layer.pivot[ 2 ] );\n\n\t\t// let userData = geometry.userData;\n\t\t// geometry = geometry.toNonIndexed()\n\t\t// geometry.userData = userData;\n\n\t\treturn geometry;\n\n\t}\n\n\t// split quads into tris\n\tsplitIndices( indices, polygonDimensions ) {\n\n\t\tconst remappedIndices = [];\n\n\t\tlet i = 0;\n\t\tpolygonDimensions.forEach( function ( dim ) {\n\n\t\t\tif ( dim < 4 ) {\n\n\t\t\t\tfor ( let k = 0; k < dim; k ++ ) remappedIndices.push( indices[ i + k ] );\n\n\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\tremappedIndices.push(\n\t\t\t\t\tindices[ i ],\n\t\t\t\t\tindices[ i + 1 ],\n\t\t\t\t\tindices[ i + 2 ],\n\n\t\t\t\t\tindices[ i ],\n\t\t\t\t\tindices[ i + 2 ],\n\t\t\t\t\tindices[ i + 3 ]\n\n\t\t\t\t);\n\n\t\t\t} else if ( dim > 4 ) {\n\n\t\t\t\tfor ( let k = 1; k < dim - 1; k ++ ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i ], indices[ i + k ], indices[ i + k + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'LWOLoader: polygons with greater than 4 sides are not supported' );\n\n\t\t\t}\n\n\t\t\ti += dim;\n\n\t\t} );\n\n\t\treturn remappedIndices;\n\n\t}\n\n\t// NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\tparseGroups( geometry, geoData ) {\n\n\t\tconst tags = _lwoTree.tags;\n\t\tconst matNames = [];\n\n\t\tlet elemSize = 3;\n\t\tif ( geoData.type === 'lines' ) elemSize = 2;\n\t\tif ( geoData.type === 'points' ) elemSize = 1;\n\n\t\tconst remappedIndices = this.splitMaterialIndices( geoData.polygonDimensions, geoData.materialIndices );\n\n\t\tlet indexNum = 0; // create new indices in numerical order\n\t\tconst indexPairs = {}; // original indices mapped to numerical indices\n\n\t\tlet prevMaterialIndex;\n\t\tlet materialIndex;\n\n\t\tlet prevStart = 0;\n\t\tlet currentCount = 0;\n\n\t\tfor ( let i = 0; i < remappedIndices.length; i += 2 ) {\n\n\t\t\tmaterialIndex = remappedIndices[ i + 1 ];\n\n\t\t\tif ( i === 0 ) matNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\tif ( prevMaterialIndex === undefined ) prevMaterialIndex = materialIndex;\n\n\t\t\tif ( materialIndex !== prevMaterialIndex ) {\n\n\t\t\t\tlet currentIndex;\n\t\t\t\tif ( indexPairs[ tags[ prevMaterialIndex ] ] ) {\n\n\t\t\t\t\tcurrentIndex = indexPairs[ tags[ prevMaterialIndex ] ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\t\tindexPairs[ tags[ prevMaterialIndex ] ] = indexNum;\n\t\t\t\t\tmatNames[ indexNum ] = tags[ prevMaterialIndex ];\n\t\t\t\t\tindexNum ++;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t\t\tprevStart += currentCount;\n\n\t\t\t\tprevMaterialIndex = materialIndex;\n\t\t\t\tcurrentCount = 0;\n\n\t\t\t}\n\n\t\t\tcurrentCount += elemSize;\n\n\t\t}\n\n\t\t// the loop above doesn't add the last group, do that here.\n\t\tif ( geometry.groups.length > 0 ) {\n\n\t\t\tlet currentIndex;\n\t\t\tif ( indexPairs[ tags[ materialIndex ] ] ) {\n\n\t\t\t\tcurrentIndex = indexPairs[ tags[ materialIndex ] ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\tindexPairs[ tags[ materialIndex ] ] = indexNum;\n\t\t\t\tmatNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\t}\n\n\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t}\n\n\t\t// Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\t\tgeometry.userData.matNames = matNames;\n\n\t}\n\n\tsplitMaterialIndices( polygonDimensions, indices ) {\n\n\t\tconst remappedIndices = [];\n\n\t\tpolygonDimensions.forEach( function ( dim, i ) {\n\n\t\t\tif ( dim <= 3 ) {\n\n\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ], indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t} else {\n\n\t\t\t\t // ignore > 4 for now\n\t\t\t\tfor ( let k = 0; k < dim - 2; k ++ ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn remappedIndices;\n\n\t}\n\n\t// UV maps:\n\t// 1: are defined via index into an array of points, not into a geometry\n\t// - the geometry is also defined by an index into this array, but the indexes may not match\n\t// 2: there can be any number of UV maps for a single geometry. Here these are combined,\n\t// \twith preference given to the first map encountered\n\t// 3: UV maps can be partial - that is, defined for only a part of the geometry\n\t// 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n\t// UV maps are defined as partially VMAP and partially VMAD\n\t// VMADs are currently not supported\n\tparseUVs( geometry, layer ) {\n\n\t\t// start by creating a UV map set to zero for the whole geometry\n\t\tconst remappedUVs = Array.from( Array( geometry.attributes.position.count * 2 ), function () {\n\n\t\t\treturn 0;\n\n\t\t} );\n\n\t\tfor ( const name in layer.uvs ) {\n\n\t\t\tconst uvs = layer.uvs[ name ].uvs;\n\t\t\tconst uvIndices = layer.uvs[ name ].uvIndices;\n\n\t\t\tuvIndices.forEach( function ( i, j ) {\n\n\t\t\t\tremappedUVs[ i * 2 ] = uvs[ j * 2 ];\n\t\t\t\tremappedUVs[ i * 2 + 1 ] = uvs[ j * 2 + 1 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( remappedUVs, 2 ) );\n\n\t}\n\n\tparseMorphTargets( geometry, layer ) {\n\n\t\tlet num = 0;\n\t\tfor ( const name in layer.morphTargets ) {\n\n\t\t\tconst remappedPoints = geometry.attributes.position.array.slice();\n\n\t\t\tif ( ! geometry.morphAttributes.position ) geometry.morphAttributes.position = [];\n\n\t\t\tconst morphPoints = layer.morphTargets[ name ].points;\n\t\t\tconst morphIndices = layer.morphTargets[ name ].indices;\n\t\t\tconst type = layer.morphTargets[ name ].type;\n\n\t\t\tmorphIndices.forEach( function ( i, j ) {\n\n\t\t\t\tif ( type === 'relative' ) {\n\n\t\t\t\t\tremappedPoints[ i * 3 ] += morphPoints[ j * 3 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 1 ] += morphPoints[ j * 3 + 1 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 2 ] += morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tremappedPoints[ i * 3 ] = morphPoints[ j * 3 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 1 ] = morphPoints[ j * 3 + 1 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 2 ] = morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tgeometry.morphAttributes.position[ num ] = new Float32BufferAttribute( remappedPoints, 3 );\n\t\t\tgeometry.morphAttributes.position[ num ].name = name;\n\n\t\t\tnum ++;\n\n\t\t}\n\n\t\tgeometry.morphTargetsRelative = false;\n\n\t}\n\n}\n\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl( url, dir ) {\n\n\tconst index = url.indexOf( dir );\n\n\tif ( index === - 1 ) return './';\n\n\treturn url.slice( 0, index );\n\n}\n\nexport { LWOLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}