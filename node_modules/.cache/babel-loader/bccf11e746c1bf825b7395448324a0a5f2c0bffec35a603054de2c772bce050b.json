{"ast":null,"code":"import { jsxs, Fragment, jsx } from \"react/jsx-runtime\";\nimport { useMemo, useRef } from \"react\";\nimport { matriceCount, matriceWorldCount } from \"./PerfHeadless.mjs\";\nimport { Graph, Graphpc } from \"../styles.mjs\";\nimport { PauseIcon } from \"@radix-ui/react-icons\";\nimport { useFrame, Canvas } from \"@react-three/fiber\";\nimport \"../index.mjs\";\nimport { colorsGraph } from \"./Perf.mjs\";\nimport * as THREE from \"three\";\nimport { TextsHighHZ } from \"./TextsHighHZ.mjs\";\nimport { getPerf, usePerf } from \"../store.mjs\";\nconst ChartCurve = ({\n  colorBlind,\n  minimal,\n  chart = {\n    length: 120,\n    hz: 60\n  }\n}) => {\n  const curves = useMemo(() => {\n    return {\n      fps: new Float32Array(chart.length * 3),\n      cpu: new Float32Array(chart.length * 3),\n      // mem: new Float32Array(chart.length * 3),\n      gpu: new Float32Array(chart.length * 3)\n    };\n  }, [chart]);\n  const fpsRef = useRef(null);\n  const fpsMatRef = useRef(null);\n  const gpuRef = useRef(null);\n  const cpuRef = useRef(null);\n  const dummyVec3 = useMemo(() => new THREE.Vector3(0, 0, 0), []);\n  const updatePoints = (element, factor = 1, ref, viewport) => {\n    let maxVal = 0;\n    const {\n      width: w,\n      height: h\n    } = viewport;\n    const chart2 = getPerf().chart.data[element];\n    if (!chart2 || chart2.length === 0) {\n      return;\n    }\n    const padding = minimal ? 2 : 6;\n    const paddingTop = minimal ? 12 : 50;\n    let len = chart2.length;\n    for (let i = 0; i < len; i++) {\n      let id = (getPerf().chart.circularId + i + 1) % len;\n      if (chart2[id] !== void 0) {\n        if (chart2[id] > maxVal) {\n          maxVal = chart2[id] * factor;\n        }\n        dummyVec3.set(padding + i / (len - 1) * (w - padding * 2) - w / 2, Math.min(100, chart2[id]) * factor / 100 * (h - padding * 2 - paddingTop) - h / 2, 0);\n        dummyVec3.toArray(ref.attributes.position.array, i * 3);\n      }\n    }\n    ref.attributes.position.needsUpdate = true;\n  };\n  useFrame(function updateChartCurve({\n    viewport\n  }) {\n    updatePoints(\"fps\", 1, fpsRef.current, viewport);\n    if (fpsMatRef.current) {\n      fpsMatRef.current.color.set(getPerf().overclockingFps ? colorsGraph(colorBlind).overClock.toString() : `rgb(${colorsGraph(colorBlind).fps.toString()})`);\n    }\n    updatePoints(\"gpu\", 5, gpuRef.current, viewport);\n    updatePoints(\"cpu\", 5, cpuRef.current, viewport);\n  });\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsxs(\"line\", {\n      onUpdate: self => {\n        self.updateMatrix();\n        matriceCount.value -= 1;\n        self.matrixWorld.copy(self.matrix);\n      },\n      children: [/* @__PURE__ */jsx(\"bufferGeometry\", {\n        ref: fpsRef,\n        children: /* @__PURE__ */jsx(\"bufferAttribute\", {\n          attach: \"attributes-position\",\n          count: chart.length,\n          array: curves.fps,\n          itemSize: 3,\n          usage: THREE.DynamicDrawUsage,\n          needsUpdate: true\n        })\n      }), /* @__PURE__ */jsx(\"lineBasicMaterial\", {\n        ref: fpsMatRef,\n        color: `rgb(${colorsGraph(colorBlind).fps.toString()})`,\n        transparent: true,\n        opacity: 0.5\n      })]\n    }), /* @__PURE__ */jsxs(\"line\", {\n      onUpdate: self => {\n        self.updateMatrix();\n        matriceCount.value -= 1;\n        self.matrixWorld.copy(self.matrix);\n      },\n      children: [/* @__PURE__ */jsx(\"bufferGeometry\", {\n        ref: gpuRef,\n        children: /* @__PURE__ */jsx(\"bufferAttribute\", {\n          attach: \"attributes-position\",\n          count: chart.length,\n          array: curves.gpu,\n          itemSize: 3,\n          usage: THREE.DynamicDrawUsage,\n          needsUpdate: true\n        })\n      }), /* @__PURE__ */jsx(\"lineBasicMaterial\", {\n        color: `rgb(${colorsGraph(colorBlind).gpu.toString()})`,\n        transparent: true,\n        opacity: 0.5\n      })]\n    }), /* @__PURE__ */jsxs(\"line\", {\n      onUpdate: self => {\n        self.updateMatrix();\n        matriceCount.value -= 1;\n        self.matrixWorld.copy(self.matrix);\n      },\n      children: [/* @__PURE__ */jsx(\"bufferGeometry\", {\n        ref: cpuRef,\n        children: /* @__PURE__ */jsx(\"bufferAttribute\", {\n          attach: \"attributes-position\",\n          count: chart.length,\n          array: curves.cpu,\n          itemSize: 3,\n          usage: THREE.DynamicDrawUsage,\n          needsUpdate: true\n        })\n      }), /* @__PURE__ */jsx(\"lineBasicMaterial\", {\n        color: `rgb(${colorsGraph(colorBlind).cpu.toString()})`,\n        transparent: true,\n        opacity: 0.5\n      })]\n    })]\n  });\n};\nconst ChartUI = ({\n  colorBlind,\n  chart,\n  customData,\n  matrixUpdate,\n  showGraph = true,\n  antialias = true,\n  minimal\n}) => {\n  const canvas = useRef(void 0);\n  const paused = usePerf(state => state.paused);\n  return /* @__PURE__ */jsxs(Graph, {\n    style: {\n      display: \"flex\",\n      position: \"absolute\",\n      height: `${minimal ? 37 : showGraph ? 100 : 60}px`,\n      minWidth: `${minimal ? \"100px\" : customData ? \"370px\" : \"310px\"}`\n    },\n    children: [/* @__PURE__ */jsx(Canvas, {\n      ref: canvas,\n      orthographic: true,\n      dpr: antialias ? [1, 2] : 1,\n      gl: {\n        antialias: true,\n        alpha: true,\n        stencil: false,\n        depth: false\n      },\n      onCreated: ({\n        scene\n      }) => {\n        scene.traverse(obj => {\n          obj.matrixWorldAutoUpdate = false;\n          obj.matrixAutoUpdate = false;\n        });\n      },\n      flat: true,\n      style: {\n        marginBottom: `-42px`,\n        position: \"relative\",\n        pointerEvents: \"none\",\n        background: \"transparent !important\",\n        height: `${minimal ? 37 : showGraph ? 100 : 60}px`\n      },\n      children: !paused ? /* @__PURE__ */jsxs(Fragment, {\n        children: [/* @__PURE__ */jsx(Renderer, {}), /* @__PURE__ */jsx(TextsHighHZ, {\n          customData,\n          minimal,\n          matrixUpdate\n        }), showGraph && /* @__PURE__ */jsx(ChartCurve, {\n          colorBlind,\n          minimal,\n          chart\n        })]\n      }) : null\n    }), paused && /* @__PURE__ */jsxs(Graphpc, {\n      children: [/* @__PURE__ */jsx(PauseIcon, {}), \" PAUSED\"]\n    })]\n  });\n};\nconst Renderer = () => {\n  useFrame(function updateR3FPerf({\n    gl,\n    scene,\n    camera\n  }) {\n    camera.updateMatrix();\n    matriceCount.value -= 1;\n    camera.matrixWorld.copy(camera.matrix);\n    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    gl.render(scene, camera);\n    matriceWorldCount.value = 0;\n    matriceCount.value = 0;\n  }, Infinity);\n  return null;\n};\nexport { ChartUI };","map":{"version":3,"names":["ChartCurve","colorBlind","minimal","chart","length","hz","curves","useMemo","fps","Float32Array","cpu","gpu","fpsRef","useRef","fpsMatRef","gpuRef","cpuRef","dummyVec3","THREE","Vector3","updatePoints","element","factor","ref","viewport","maxVal","width","w","height","h","chart2","getPerf","data","padding","paddingTop","len","i","id","circularId","set","Math","min","toArray","attributes","position","array","needsUpdate","useFrame","updateChartCurve","current","color","overclockingFps","colorsGraph","overClock","toString","jsxs","Fragment","children","onUpdate","self","updateMatrix","matriceCount","value","matrixWorld","copy","matrix","jsx","attach","count","itemSize","usage","DynamicDrawUsage","transparent","opacity","ChartUI","customData","matrixUpdate","showGraph","antialias","canvas","paused","usePerf","state","Graph","style","display","minWidth","Canvas","orthographic","dpr","gl","alpha","stencil","depth","onCreated","scene","traverse","obj","matrixWorldAutoUpdate","matrixAutoUpdate","flat","marginBottom","pointerEvents","background","Renderer","TextsHighHZ","Graphpc","PauseIcon","updateR3FPerf","camera","matrixWorldInverse","invert","render","matriceWorldCount","Infinity"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/r3f-perf/src/components/Graph.tsx"],"sourcesContent":["import { FC, useMemo, useRef } from 'react';\nimport { matriceCount, matriceWorldCount } from './PerfHeadless';\nimport { Graph, Graphpc } from '../styles';\nimport { PauseIcon } from '@radix-ui/react-icons';\nimport { Canvas, useFrame, Viewport } from '@react-three/fiber';\nimport { getPerf, usePerf } from '..';\nimport { colorsGraph } from './Perf';\nimport * as THREE from 'three';\nimport { PerfUIProps } from '../typings';\nimport { TextsHighHZ } from './TextsHighHZ';\n\nexport interface graphData {\n  curve: THREE.SplineCurve;\n  maxVal: number;\n  element: string;\n}\n\n\nconst ChartCurve:FC<PerfUIProps> = ({colorBlind, minimal, chart= {length: 120, hz: 60}}) => {\n\n  const curves: any = useMemo(() => {\n    return {\n      fps: new Float32Array(chart.length * 3),\n      cpu: new Float32Array(chart.length * 3),\n      // mem: new Float32Array(chart.length * 3),\n      gpu: new Float32Array(chart.length * 3)\n    }\n  }, [chart])\n\n  const fpsRef= useRef<any>(null)\n  const fpsMatRef= useRef<any>(null)\n  const gpuRef= useRef<any>(null)\n  const cpuRef= useRef<any>(null)\n\n  const dummyVec3 = useMemo(() => new THREE.Vector3(0,0,0), [])\n  const updatePoints = (element: string, factor: number = 1, ref: any, viewport: Viewport) => {\n    let maxVal = 0;\n    const {width: w, height: h} = viewport\n    \n    const chart = getPerf().chart.data[element];\n    if (!chart || chart.length === 0) {\n      return\n    }\n    const padding = minimal ? 2 : 6\n    const paddingTop = minimal ? 12 : 50\n    let len = chart.length;\n    for (let i = 0; i < len; i++) {\n      let id = (getPerf().chart.circularId + i + 1) % len;\n      if (chart[id] !== undefined) {\n        if (chart[id] > maxVal) {\n          maxVal = chart[id] * factor;\n        }\n        dummyVec3.set(padding + i / (len - 1) * (w - padding * 2) - w / 2, (Math.min(100, chart[id]) * factor) / 100 * (h - padding * 2 - paddingTop) - h / 2, 0)\n        \n        dummyVec3.toArray(ref.attributes.position.array, i * 3)\n      }\n    }\n    \n    ref.attributes.position.needsUpdate = true;\n  };\n\n  // const [supportMemory] = useState(window.performance.memory)\n  useFrame(function updateChartCurve({viewport}) {\n    \n    updatePoints('fps', 1, fpsRef.current, viewport)\n    if (fpsMatRef.current) {\n      fpsMatRef.current.color.set(getPerf().overclockingFps ? colorsGraph(colorBlind).overClock.toString() : `rgb(${colorsGraph(colorBlind).fps.toString()})`)\n    }\n    updatePoints('gpu', 5, gpuRef.current, viewport)\n    // if (supportMemory) {\n      updatePoints('cpu', 5, cpuRef.current, viewport)\n    // }\n  })\n  return (\n    <>\n      {/* @ts-ignore */}\n      <line onUpdate={(self)=>{\n          self.updateMatrix()\n          matriceCount.value -= 1\n          self.matrixWorld.copy(self.matrix)\n        }}>\n        <bufferGeometry ref={fpsRef}>\n          <bufferAttribute\n              attach={'attributes-position'}\n              count={chart.length}\n              array={curves.fps}\n              itemSize={3}\n              usage={THREE.DynamicDrawUsage}\n              needsUpdate\n            />\n        </bufferGeometry>\n        <lineBasicMaterial ref={fpsMatRef} color={`rgb(${colorsGraph(colorBlind).fps.toString()})`} transparent opacity={0.5} />\n      </line>\n      {/* @ts-ignore */}\n      <line onUpdate={(self)=>{\n          self.updateMatrix()\n          matriceCount.value -= 1\n          self.matrixWorld.copy(self.matrix)\n        }}>\n        <bufferGeometry ref={gpuRef}>\n          <bufferAttribute\n              attach={'attributes-position'}\n              count={chart.length}\n              array={curves.gpu}\n              itemSize={3}\n              usage={THREE.DynamicDrawUsage}\n              needsUpdate\n            />\n        </bufferGeometry>\n        <lineBasicMaterial color={`rgb(${colorsGraph(colorBlind).gpu.toString()})`} transparent opacity={0.5} />\n      </line>\n      {/* @ts-ignore */}\n      <line onUpdate={(self)=>{\n          self.updateMatrix()\n          matriceCount.value -= 1\n          self.matrixWorld.copy(self.matrix)\n        }}>\n        <bufferGeometry ref={cpuRef}>\n          <bufferAttribute\n            attach={'attributes-position'}\n            count={chart.length}\n            array={curves.cpu}\n            itemSize={3}\n            usage={THREE.DynamicDrawUsage}\n            needsUpdate\n          />\n        </bufferGeometry>\n        <lineBasicMaterial color={`rgb(${colorsGraph(colorBlind).cpu.toString()})`} transparent opacity={0.5} />\n      </line>\n    </>\n  );\n};\n\nexport const ChartUI: FC<PerfUIProps> = ({\n  colorBlind,\n  chart,\n  customData,\n  matrixUpdate,\n  showGraph= true,\n  antialias= true,\n  minimal,\n}) => {\n  const canvas = useRef<any>(undefined);\n\n  const paused = usePerf((state) => state.paused);\n  return (\n    <Graph\n      style={{\n        display: 'flex',\n        position: 'absolute',\n        height: `${minimal ? 37 : showGraph ? 100 : 60 }px`,\n        minWidth: `${minimal ? '100px' : customData ? '370px' : '310px'}`\n      }}\n    >\n      <Canvas\n        ref={canvas}\n        orthographic\n        dpr={antialias ? [1,2] : 1}\n        gl={{\n          antialias: true,\n          alpha: true,\n          stencil: false,\n          depth: false,\n        }}\n        onCreated={({scene}) => {\n          scene.traverse((obj: THREE.Object3D)=>{\n            //@ts-ignore\n            obj.matrixWorldAutoUpdate=false\n            obj.matrixAutoUpdate=false\n          })\n        }}\n        flat={true}\n        style={{\n          marginBottom: `-42px`,\n          position: 'relative',\n          pointerEvents: 'none',\n          background: 'transparent !important',\n          height: `${minimal ? 37 : showGraph ? 100 : 60 }px`\n        }}\n      >\n        {!paused ? (\n          <>\n            <Renderer />\n            <TextsHighHZ customData={customData} minimal={minimal} matrixUpdate={matrixUpdate} />\n            {showGraph && <ChartCurve\n              colorBlind={colorBlind}\n              minimal={minimal}\n              chart={chart}\n            />}\n          </>\n        ) : null}\n      </Canvas>\n      {paused && (\n        <Graphpc>\n          <PauseIcon /> PAUSED\n        </Graphpc>\n      )}\n    </Graph>\n  );\n};\n\nconst Renderer = () =>{\n\n  useFrame(function updateR3FPerf({ gl, scene, camera }) {\n    camera.updateMatrix()\n    matriceCount.value -= 1\n    camera.matrixWorld.copy(camera.matrix)\n    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    gl.render(scene,camera)\n    matriceWorldCount.value = 0\n    matriceCount.value = 0\n  }, Infinity)\n\n  \n  return null\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}