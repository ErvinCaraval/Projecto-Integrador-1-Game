{"ast":null,"code":"import { BufferGeometry, Color, FileLoader, Float32BufferAttribute, Int32BufferAttribute, Loader, Points, PointsMaterial } from 'three';\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n      do {\n        ctrl = inData[inPtr++];\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n      return outData;\n    }\n    function parseHeader(data) {\n      const PCDheader = {};\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.slice(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.slice(0, PCDheader.headerLen);\n\n      // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/#.*/gi, '');\n\n      // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str);\n\n      // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      PCDheader.fields = PCDheader.fields !== null ? PCDheader.fields[1].split(' ') : [];\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n      PCDheader.offset = {};\n      let sizeSum = 0;\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i;\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum;\n          sizeSum += PCDheader.size[i] * PCDheader.count[i];\n        }\n      }\n\n      // for binary only\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n    const textData = new TextDecoder().decode(data);\n\n    // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData);\n\n    // parse data\n\n    const position = [];\n    const normal = [];\n    const color = [];\n    const intensity = [];\n    const label = [];\n    const c = new Color();\n\n    // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset;\n      const pcdData = textData.slice(PCDheader.headerLen);\n      const lines = pcdData.split('\\n');\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        const line = lines[i].split(' ');\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n        if (offset.rgb !== undefined) {\n          const rgb_field_index = PCDheader.fields.findIndex(field => field === 'rgb');\n          const rgb_type = PCDheader.type[rgb_field_index];\n          const float = parseFloat(line[offset.rgb]);\n          let rgb = float;\n          if (rgb_type === 'F') {\n            // treat float values as int\n            // https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518\n            const farr = new Float32Array(1);\n            farr[0] = float;\n            rgb = new Int32Array(farr.buffer)[0];\n          }\n          const r = (rgb >> 16 & 0x0000ff) / 255;\n          const g = (rgb >> 8 & 0x0000ff) / 255;\n          const b = (rgb >> 0 & 0x0000ff) / 255;\n          c.set(r, g, b).convertSRGBToLinear();\n          color.push(c.r, c.g, c.b);\n        }\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n        if (offset.intensity !== undefined) {\n          intensity.push(parseFloat(line[offset.intensity]));\n        }\n        if (offset.label !== undefined) {\n          label.push(parseInt(line[offset.label]));\n        }\n      }\n    }\n\n    // binary-compressed\n\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          const xIndex = PCDheader.fields.indexOf('x');\n          const yIndex = PCDheader.fields.indexOf('y');\n          const zIndex = PCDheader.fields.indexOf('z');\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[xIndex] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[yIndex] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[zIndex] * i, this.littleEndian));\n        }\n        if (offset.rgb !== undefined) {\n          const rgbIndex = PCDheader.fields.indexOf('rgb');\n          const r = dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[rgbIndex] * i + 2) / 255.0;\n          const g = dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[rgbIndex] * i + 1) / 255.0;\n          const b = dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[rgbIndex] * i + 0) / 255.0;\n          c.set(r, g, b).convertSRGBToLinear();\n          color.push(c.r, c.g, c.b);\n        }\n        if (offset.normal_x !== undefined) {\n          const xIndex = PCDheader.fields.indexOf('normal_x');\n          const yIndex = PCDheader.fields.indexOf('normal_y');\n          const zIndex = PCDheader.fields.indexOf('normal_z');\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[xIndex] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[yIndex] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[zIndex] * i, this.littleEndian));\n        }\n        if (offset.intensity !== undefined) {\n          const intensityIndex = PCDheader.fields.indexOf('intensity');\n          intensity.push(dataview.getFloat32(PCDheader.points * offset.intensity + PCDheader.size[intensityIndex] * i, this.littleEndian));\n        }\n        if (offset.label !== undefined) {\n          const labelIndex = PCDheader.fields.indexOf('label');\n          label.push(dataview.getInt32(PCDheader.points * offset.label + PCDheader.size[labelIndex] * i, this.littleEndian));\n        }\n      }\n    }\n\n    // binary\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n        if (offset.rgb !== undefined) {\n          const r = dataview.getUint8(row + offset.rgb + 2) / 255.0;\n          const g = dataview.getUint8(row + offset.rgb + 1) / 255.0;\n          const b = dataview.getUint8(row + offset.rgb + 0) / 255.0;\n          c.set(r, g, b).convertSRGBToLinear();\n          color.push(c.r, c.g, c.b);\n        }\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n        if (offset.intensity !== undefined) {\n          intensity.push(dataview.getFloat32(row + offset.intensity, this.littleEndian));\n        }\n        if (offset.label !== undefined) {\n          label.push(dataview.getInt32(row + offset.label, this.littleEndian));\n        }\n      }\n    }\n\n    // build geometry\n\n    const geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    if (intensity.length > 0) geometry.setAttribute('intensity', new Float32BufferAttribute(intensity, 1));\n    if (label.length > 0) geometry.setAttribute('label', new Int32BufferAttribute(label, 1));\n    geometry.computeBoundingSphere();\n\n    // build material\n\n    const material = new PointsMaterial({\n      size: 0.005\n    });\n    if (color.length > 0) {\n      material.vertexColors = true;\n    }\n\n    // build point cloud\n\n    return new Points(geometry, material);\n  }\n}\nexport { PCDLoader };","map":{"version":3,"names":["BufferGeometry","Color","FileLoader","Float32BufferAttribute","Int32BufferAttribute","Loader","Points","PointsMaterial","PCDLoader","constructor","manager","littleEndian","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","PCDheader","result1","search","result2","exec","slice","headerLen","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","textData","TextDecoder","decode","position","normal","color","intensity","label","c","pcdData","lines","line","undefined","y","z","rgb","rgb_field_index","findIndex","field","rgb_type","float","farr","Float32Array","Int32Array","buffer","r","g","b","set","convertSRGBToLinear","normal_x","normal_y","normal_z","sizes","Uint32Array","compressedSize","decompressedSize","decompressed","dataview","DataView","xIndex","indexOf","yIndex","zIndex","getFloat32","rgbIndex","getUint8","intensityIndex","labelIndex","getInt32","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/loaders/PCDLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tInt32BufferAttribute,\n\tLoader,\n\tPoints,\n\tPointsMaterial\n} from 'three';\n\nclass PCDLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.littleEndian = true;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\tconst inLength = inData.length;\n\t\t\tconst outData = new Uint8Array( outLength );\n\t\t\tlet inPtr = 0;\n\t\t\tlet outPtr = 0;\n\t\t\tlet ctrl;\n\t\t\tlet len;\n\t\t\tlet ref;\n\t\t\tdo {\n\n\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\tctrl ++;\n\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t}\n\n\t\t\t} while ( inPtr < inLength );\n\n\t\t\treturn outData;\n\n\t\t}\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tconst PCDheader = {};\n\t\t\tconst result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\tconst result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.slice( result1 - 1 ) );\n\n\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\tPCDheader.str = data.slice( 0, PCDheader.headerLen );\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace( /#.*/gi, '' );\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t// evaluate\n\n\t\t\tif ( PCDheader.version !== null )\n\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\tPCDheader.fields = ( PCDheader.fields !== null ) ? PCDheader.fields[ 1 ].split( ' ' ) : [];\n\n\t\t\tif ( PCDheader.type !== null )\n\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.width !== null )\n\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\tif ( PCDheader.height !== null )\n\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\tif ( PCDheader.points !== null )\n\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\tif ( PCDheader.points === null )\n\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tlet sizeSum = 0;\n\n\t\t\tfor ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\n\t\t}\n\n\t\tconst textData = new TextDecoder().decode( data );\n\n\t\t// parse header (always ascii format)\n\n\t\tconst PCDheader = parseHeader( textData );\n\n\t\t// parse data\n\n\t\tconst position = [];\n\t\tconst normal = [];\n\t\tconst color = [];\n\t\tconst intensity = [];\n\t\tconst label = [];\n\n\t\tconst c = new Color();\n\n\t\t// ascii\n\n\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\tconst offset = PCDheader.offset;\n\t\t\tconst pcdData = textData.slice( PCDheader.headerLen );\n\t\t\tconst lines = pcdData.split( '\\n' );\n\n\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\tconst line = lines[ i ].split( ' ' );\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst rgb_field_index = PCDheader.fields.findIndex( ( field ) => field === 'rgb' );\n\t\t\t\t\tconst rgb_type = PCDheader.type[ rgb_field_index ];\n\n\t\t\t\t\tconst float = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\tlet rgb = float;\n\n\t\t\t\t\tif ( rgb_type === 'F' ) {\n\n\t\t\t\t\t\t// treat float values as int\n\t\t\t\t\t\t// https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518\n\t\t\t\t\t\tconst farr = new Float32Array( 1 );\n\t\t\t\t\t\tfarr[ 0 ] = float;\n\t\t\t\t\t\trgb = new Int32Array( farr.buffer )[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst r = ( ( rgb >> 16 ) & 0x0000ff ) / 255;\n\t\t\t\t\tconst g = ( ( rgb >> 8 ) & 0x0000ff ) / 255;\n\t\t\t\t\tconst b = ( ( rgb >> 0 ) & 0x0000ff ) / 255;\n\n\t\t\t\t\tc.set( r, g, b ).convertSRGBToLinear();\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tintensity.push( parseFloat( line[ offset.intensity ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tlabel.push( parseInt( line[ offset.label ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary-compressed\n\n\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\tconst sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\tconst compressedSize = sizes[ 0 ];\n\t\t\tconst decompressedSize = sizes[ 1 ];\n\t\t\tconst decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\tconst dataview = new DataView( decompressed.buffer );\n\n\t\t\tconst offset = PCDheader.offset;\n\n\t\t\tfor ( let i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'z' );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst rgbIndex = PCDheader.fields.indexOf( 'rgb' );\n\n\t\t\t\t\tconst r = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 2 ) / 255.0;\n\t\t\t\t\tconst g = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 1 ) / 255.0;\n\t\t\t\t\tconst b = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 0 ) / 255.0;\n\n\t\t\t\t\tc.set( r, g, b ).convertSRGBToLinear();\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'normal_x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'normal_y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'normal_z' );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tconst intensityIndex = PCDheader.fields.indexOf( 'intensity' );\n\t\t\t\t\tintensity.push( dataview.getFloat32( ( PCDheader.points * offset.intensity ) + PCDheader.size[ intensityIndex ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tconst labelIndex = PCDheader.fields.indexOf( 'label' );\n\t\t\t\t\tlabel.push( dataview.getInt32( ( PCDheader.points * offset.label ) + PCDheader.size[ labelIndex ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary\n\n\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\tconst dataview = new DataView( data, PCDheader.headerLen );\n\t\t\tconst offset = PCDheader.offset;\n\n\t\t\tfor ( let i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst r = dataview.getUint8( row + offset.rgb + 2 ) / 255.0;\n\t\t\t\t\tconst g = dataview.getUint8( row + offset.rgb + 1 ) / 255.0;\n\t\t\t\t\tconst b = dataview.getUint8( row + offset.rgb + 0 ) / 255.0;\n\n\t\t\t\t\tc.set( r, g, b ).convertSRGBToLinear();\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tintensity.push( dataview.getFloat32( row + offset.intensity, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tlabel.push( dataview.getInt32( row + offset.label, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\n\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\n\t\tif ( intensity.length > 0 ) geometry.setAttribute( 'intensity', new Float32BufferAttribute( intensity, 1 ) );\n\t\tif ( label.length > 0 ) geometry.setAttribute( 'label', new Int32BufferAttribute( label, 1 ) );\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tconst material = new PointsMaterial( { size: 0.005 } );\n\n\t\tif ( color.length > 0 ) {\n\n\t\t\tmaterial.vertexColors = true;\n\n\t\t}\n\n\t\t// build point cloud\n\n\t\treturn new Points( geometry, material );\n\n\t}\n\n}\n\nexport { PCDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}