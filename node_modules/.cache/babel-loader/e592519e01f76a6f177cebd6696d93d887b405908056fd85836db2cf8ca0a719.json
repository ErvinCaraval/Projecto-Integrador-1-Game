{"ast":null,"code":"import { AdditiveBlending, Box2, BufferGeometry, Color, FramebufferTexture, InterleavedBuffer, InterleavedBufferAttribute, Mesh, MeshBasicMaterial, RawShaderMaterial, UnsignedByteType, Vector2, Vector3, Vector4 } from 'three';\nclass Lensflare extends Mesh {\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.isLensflare = true;\n    this.type = 'Lensflare';\n    this.frustumCulled = false;\n    this.renderOrder = Infinity;\n\n    //\n\n    const positionScreen = new Vector3();\n    const positionView = new Vector3();\n\n    // textures\n\n    const tempMap = new FramebufferTexture(16, 16);\n    const occlusionMap = new FramebufferTexture(16, 16);\n    let currentType = UnsignedByteType;\n\n    // material\n\n    const geometry = Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        'scale': {\n          value: null\n        },\n        'screenPosition': {\n          value: null\n        }\n      },\n      vertexShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        'map': {\n          value: tempMap\n        },\n        'scale': {\n          value: null\n        },\n        'screenPosition': {\n          value: null\n        }\n      },\n      vertexShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    });\n\n    // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a);\n\n    //\n\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      name: shader.name,\n      uniforms: {\n        'map': {\n          value: null\n        },\n        'occlusionMap': {\n          value: occlusionMap\n        },\n        'color': {\n          value: new Color(0xffffff)\n        },\n        'scale': {\n          value: new Vector2()\n        },\n        'screenPosition': {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry, material2);\n    this.addElement = function (element) {\n      elements.push(element);\n    };\n\n    //\n\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const renderTarget = renderer.getRenderTarget();\n      const type = renderTarget !== null ? renderTarget.texture.type : UnsignedByteType;\n      if (currentType !== type) {\n        tempMap.dispose();\n        occlusionMap.dispose();\n        tempMap.type = occlusionMap.type = type;\n        currentType = type;\n      }\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2.0;\n      const halfViewportHeight = viewport.w / 2.0;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));\n\n      // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return; // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n\n      // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;\n\n      // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n\n        // render pink quad\n\n        let uniforms = material1a.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);\n\n        // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n\n        // restore graphics\n\n        uniforms = material1b.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);\n\n        // render elements\n\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms = material2.uniforms;\n          uniforms['color'].value.copy(element.color);\n          uniforms['map'].value = element.texture;\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect = viewport.w / viewport.z;\n          uniforms['scale'].value.set(size * invAspect, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n        }\n      }\n    };\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n}\n\n//\n\nclass LensflareElement {\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n}\nLensflareElement.Shader = {\n  name: 'LensflareElementShader',\n  uniforms: {\n    'map': {\n      value: null\n    },\n    'occlusionMap': {\n      value: null\n    },\n    'color': {\n      value: null\n    },\n    'scale': {\n      value: null\n    },\n    'screenPosition': {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n};\nLensflare.Geometry = function () {\n  const geometry = new BufferGeometry();\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  return geometry;\n}();\nexport { Lensflare, LensflareElement };","map":{"version":3,"names":["AdditiveBlending","Box2","BufferGeometry","Color","FramebufferTexture","InterleavedBuffer","InterleavedBufferAttribute","Mesh","MeshBasicMaterial","RawShaderMaterial","UnsignedByteType","Vector2","Vector3","Vector4","Lensflare","constructor","Geometry","opacity","transparent","isLensflare","type","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","occlusionMap","currentType","geometry","material1a","uniforms","value","vertexShader","fragmentShader","depthTest","depthWrite","material1b","mesh1","elements","shader","LensflareElement","Shader","material2","name","blending","mesh2","addElement","element","push","scale","screenPositionPixels","validArea","viewport","onBeforeRender","renderer","scene","camera","getCurrentViewport","renderTarget","getRenderTarget","texture","dispose","invAspect","w","z","halfViewportWidth","halfViewportHeight","size","set","min","x","y","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","color","distance","uniformsNeedUpdate","float32Array","Float32Array","interleavedBuffer","setIndex","setAttribute"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/objects/Lensflare.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tBox2,\n\tBufferGeometry,\n\tColor,\n\tFramebufferTexture,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tMesh,\n\tMeshBasicMaterial,\n\tRawShaderMaterial,\n\tUnsignedByteType,\n\tVector2,\n\tVector3,\n\tVector4\n} from 'three';\n\nclass Lensflare extends Mesh {\n\n\tconstructor() {\n\n\t\tsuper( Lensflare.Geometry, new MeshBasicMaterial( { opacity: 0, transparent: true } ) );\n\n\t\tthis.isLensflare = true;\n\n\t\tthis.type = 'Lensflare';\n\t\tthis.frustumCulled = false;\n\t\tthis.renderOrder = Infinity;\n\n\t\t//\n\n\t\tconst positionScreen = new Vector3();\n\t\tconst positionView = new Vector3();\n\n\t\t// textures\n\n\t\tconst tempMap = new FramebufferTexture( 16, 16 );\n\t\tconst occlusionMap = new FramebufferTexture( 16, 16 );\n\n\t\tlet currentType = UnsignedByteType;\n\n\t\t// material\n\n\t\tconst geometry = Lensflare.Geometry;\n\n\t\tconst material1a = new RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\tconst material1b = new RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\t// the following object is used for occlusionMap generation\n\n\t\tconst mesh1 = new Mesh( geometry, material1a );\n\n\t\t//\n\n\t\tconst elements = [];\n\n\t\tconst shader = LensflareElement.Shader;\n\n\t\tconst material2 = new RawShaderMaterial( {\n\t\t\tname: shader.name,\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new Color( 0xffffff ) },\n\t\t\t\t'scale': { value: new Vector2() },\n\t\t\t\t'screenPosition': { value: new Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tconst mesh2 = new Mesh( geometry, material2 );\n\n\t\tthis.addElement = function ( element ) {\n\n\t\t\telements.push( element );\n\n\t\t};\n\n\t\t//\n\n\t\tconst scale = new Vector2();\n\t\tconst screenPositionPixels = new Vector2();\n\t\tconst validArea = new Box2();\n\t\tconst viewport = new Vector4();\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\trenderer.getCurrentViewport( viewport );\n\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\t\t\tconst type = ( renderTarget !== null ) ? renderTarget.texture.type : UnsignedByteType;\n\n\t\t\tif ( currentType !== type ) {\n\n\t\t\t\ttempMap.dispose();\n\t\t\t\tocclusionMap.dispose();\n\n\t\t\t\ttempMap.type = occlusionMap.type = type;\n\n\t\t\t\tcurrentType = type;\n\n\t\t\t}\n\n\t\t\tconst invAspect = viewport.w / viewport.z;\n\t\t\tconst halfViewportWidth = viewport.z / 2.0;\n\t\t\tconst halfViewportHeight = viewport.w / 2.0;\n\n\t\t\tlet size = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\t// calculate position in screen space\n\n\t\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\n\t\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\n\n\t\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tlet uniforms = material1a.uniforms;\n\t\t\t\tuniforms[ 'scale' ].value = scale;\n\t\t\t\tuniforms[ 'screenPosition' ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tuniforms = material1b.uniforms;\n\t\t\t\tuniforms[ 'scale' ].value = scale;\n\t\t\t\tuniforms[ 'screenPosition' ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\n\n\t\t\t\t// render elements\n\n\t\t\t\tconst vecX = - positionScreen.x * 2;\n\t\t\t\tconst vecY = - positionScreen.y * 2;\n\n\t\t\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\t\tconst uniforms = material2.uniforms;\n\n\t\t\t\t\tuniforms[ 'color' ].value.copy( element.color );\n\t\t\t\t\tuniforms[ 'map' ].value = element.texture;\n\t\t\t\t\tuniforms[ 'screenPosition' ].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[ 'screenPosition' ].value.y = positionScreen.y + vecY * element.distance;\n\n\t\t\t\t\tsize = element.size / viewport.w;\n\t\t\t\t\tconst invAspect = viewport.w / viewport.z;\n\n\t\t\t\t\tuniforms[ 'scale' ].value.set( size * invAspect, size );\n\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\n\t\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\n\t\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\telements[ i ].texture.dispose();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\n//\n\nclass LensflareElement {\n\n\tconstructor( texture, size = 1, distance = 0, color = new Color( 0xffffff ) ) {\n\n\t\tthis.texture = texture;\n\t\tthis.size = size;\n\t\tthis.distance = distance;\n\t\tthis.color = color;\n\n\t}\n\n}\n\nLensflareElement.Shader = {\n\n\tname: 'LensflareElementShader',\n\n\tuniforms: {\n\n\t\t'map': { value: null },\n\t\t'occlusionMap': { value: null },\n\t\t'color': { value: null },\n\t\t'scale': { value: null },\n\t\t'screenPosition': { value: null }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n\n};\n\nLensflare.Geometry = ( function () {\n\n\tconst geometry = new BufferGeometry();\n\n\tconst float32Array = new Float32Array( [\n\t\t- 1, - 1, 0, 0, 0,\n\t\t1, - 1, 0, 1, 0,\n\t\t1, 1, 0, 1, 1,\n\t\t- 1, 1, 0, 0, 1\n\t] );\n\n\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\tgeometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\tgeometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\treturn geometry;\n\n} )();\n\nexport { Lensflare, LensflareElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}