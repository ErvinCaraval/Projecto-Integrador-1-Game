{"ast":null,"code":"import { AddOperation, AnimationClip, Bone, BufferGeometry, Color, CustomBlending, TangentSpaceNormalMap, DoubleSide, DstAlphaFactor, Euler, FileLoader, Float32BufferAttribute, FrontSide, Interpolant, Loader, LoaderUtils, UniformsUtils, ShaderMaterial, MultiplyOperation, NearestFilter, NumberKeyframeTrack, OneMinusSrcAlphaFactor, Quaternion, QuaternionKeyframeTrack, RepeatWrapping, Skeleton, SkinnedMesh, SrcAlphaFactor, SRGBColorSpace, TextureLoader, Uint16BufferAttribute, Vector3, VectorKeyframeTrack, RGB_S3TC_DXT1_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format } from 'three';\nimport { MMDToonShader } from '../shaders/MMDToonShader.js';\nimport { TGALoader } from '../loaders/TGALoader.js';\nimport { MMDParser } from '../libs/mmdparser.module.js';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null; // lazy generation\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  }\n\n  // Load MMD assets as Three.js Object\n\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n\n    // resource path\n\n    let resourcePath;\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    const modelExtension = this._extractExtension(url).toLowerCase();\n\n    // Should I detect by seeing header?\n    if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n      if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'));\n      return;\n    }\n    this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](url, function (data) {\n      onLoad(builder.build(data, resourcePath, onProgress, onError));\n    }, onProgress, onError);\n  }\n\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(url, function (vmd) {\n      onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n    }, onProgress, onError);\n  }\n\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(modelUrl, function (mesh) {\n      scope.loadAnimation(vmdUrl, mesh, function (animation) {\n        onLoad({\n          mesh: mesh,\n          animation: animation\n        });\n      }, onProgress, onError);\n    }, onProgress, onError);\n  }\n\n  // Load MMD assets as Object data parsed by MMDParser\n\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      try {\n        onLoad(parser.parsePmd(buffer, true));\n      } catch (e) {\n        if (onError) onError(e);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      try {\n        onLoad(parser.parsePmx(buffer, true));\n      } catch (e) {\n        if (onError) onError(e);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n    const parser = this._getParser();\n    this.loader.setMimeType(undefined).setPath(this.animationPath).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(urls[i], function (buffer) {\n        try {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n        } catch (e) {\n          if (onError) onError(e);\n        }\n      }, onProgress, onError);\n    }\n  }\n\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis').setPath(this.animationPath).setResponseType('text').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n      try {\n        onLoad(parser.parseVpd(text, true));\n      } catch (e) {\n        if (onError) onError(e);\n      }\n    }, onProgress, onError);\n  }\n\n  // private methods\n\n  _extractExtension(url) {\n    const index = url.lastIndexOf('.');\n    return index < 0 ? '' : url.slice(index + 1);\n  }\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new MMDParser.Parser();\n    }\n    return this.parser;\n  }\n}\n\n// Utilities\n\n/*\n\t * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n\t * We don't need to request external toon image files.\n\t */\nconst DEFAULT_TOON_TEXTURES = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='];\nconst NON_ALPHA_CHANNEL_FORMATS = [RGB_S3TC_DXT1_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format];\n\n// Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = 'anonymous';\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton);\n\n    // console.log( mesh ); // for console debug\n\n    return mesh;\n  }\n}\n\n// TODO: Try to remove this function\n\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n  if (geometry && geometry.bones !== undefined) {\n    // first, create array of 'Bone' objects from geometry data\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n\n      // create new 'Bone' object\n\n      const bone = new Bone();\n      bones.push(bone);\n\n      // apply values\n\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n    }\n\n    // second, create bone hierarchy\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n        // subsequent bones in the hierarchy\n\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        // topmost bone, immediate child of the skinned mesh\n\n        mesh.add(bones[i]);\n      }\n    }\n  }\n\n  // now the bones are part of the scene graph and children of the skinned mesh.\n  // let's update the corresponding matrices\n\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\n\n//\n\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    // for geometry\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = [];\n\n    // for work\n    let offset = 0;\n    const boneTypeTable = {};\n\n    // positions, normals, uvs, skinIndices, skinWeights\n\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n      }\n    }\n\n    // indices\n\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    }\n\n    // groups\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    }\n\n    // bones\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex];\n\n      // keeps greater number if already value is set without any special reasons\n      value = value === undefined ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1\n      };\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n      bones.push(bone);\n    }\n\n    // iks\n\n    // TODO: remove duplicated codes between PMD and PMX\n    if (data.metadata.format === 'pmd') {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n            link.limitation = new Vector3(1.0, 0.0, 0.0);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === undefined) continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (ik.links[j].angleLimitation === 1) {\n            // Revert if rotationMin/Max doesn't work well\n            // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle;\n\n            // Convert Left to Right coordinate by myself because\n            // MMDParser doesn't convert. It's a MMDParser's bug\n\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n\n        // Save the reference even from bone data for efficiently\n        // simulating PMX animation system\n        bones[i].ik = param;\n      }\n    }\n\n    // grants\n\n    if (data.metadata.format === 'pmx') {\n      // bone index -> grant entry map\n      const grantEntryMap = {};\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === undefined) continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = {\n          parent: null,\n          children: [],\n          param: param,\n          visited: false\n        };\n      }\n      const rootEntry = {\n        parent: null,\n        children: [],\n        param: null,\n        visited: false\n      };\n\n      // Build a tree representing grant hierarchy\n\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      }\n\n      // Sort grant parameters from parents to children because\n      // grant uses parent's transform that parent's grant is already applied\n      // so grant should be applied in order from parents to children\n\n      function traverse(entry) {\n        if (entry.param) {\n          grants.push(entry.param);\n\n          // Save the reference even from bone data for efficiently\n          // simulating PMX animation system\n          bones[entry.param.index].grant = entry.param;\n        }\n        entry.visited = true;\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i];\n\n          // Cut off a loop if exists. (Is a grant loop invalid?)\n          if (!child.visited) traverse(child);\n        }\n      }\n      traverse(rootEntry);\n    }\n\n    // morph\n\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n        if (data.metadata.format === 'pmd') {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = {\n        name: morph.name\n      };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n      if (data.metadata.format === 'pmd') {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1.0);\n        }\n      } else {\n        if (morph.type === 0) {\n          // group\n\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            } else {\n\n              // TODO: implement\n            }\n          }\n        } else if (morph.type === 1) {\n          // vertex\n\n          updateAttributes(attribute, morph, 1.0);\n        } else if (morph.type === 2) {// bone\n\n          // TODO: implement\n        } else if (morph.type === 3) {// uv\n\n          // TODO: implement\n        } else if (morph.type === 4) {// additional uv1\n\n          // TODO: implement\n        } else if (morph.type === 5) {// additional uv2\n\n          // TODO: implement\n        } else if (morph.type === 6) {// additional uv3\n\n          // TODO: implement\n        } else if (morph.type === 7) {// additional uv4\n\n          // TODO: implement\n        } else if (morph.type === 8) {// material\n\n          // TODO: implement\n        }\n      }\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    }\n\n    // rigid bodies from rigidBodies field.\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n\n      /*\n      \t * RigidBody position parameter in PMX seems global position\n      \t * while the one in PMD seems offset from corresponding bone.\n      \t * So unify being offset.\n      \t */\n      if (data.metadata.format === 'pmx') {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n      rigidBodies.push(params);\n    }\n\n    // constraints from constraints field.\n\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2];\n\n      // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n      constraints.push(params);\n    }\n\n    // build BufferGeometry.\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones: bones,\n      iks: iks,\n      grants: grants,\n      rigidBodies: rigidBodies,\n      constraints: constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n}\n\n//\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null; // lazy generation\n\n    this.crossOrigin = 'anonymous';\n    this.resourcePath = undefined;\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MMDToonMaterial>}\n   */\n  build(data, geometry /*, onProgress, onError */) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin);\n\n    // materials\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = {\n        userData: {\n          MMD: {}\n        }\n      };\n      if (material.name !== undefined) params.name = material.name;\n\n      /*\n      \t * Color\n      \t *\n      \t * MMD         MMDToonMaterial\n      \t * ambient  -  emissive * a\n      \t *               (a = 1.0 without map texture or 0.2 with map texture)\n      \t *\n      \t * MMDToonMaterial doesn't have ambient. Set it to emissive instead.\n      \t * It'll be too bright if material has map texture so using coef 0.2.\n      \t */\n      params.diffuse = new Color().setRGB(material.diffuse[0], material.diffuse[1], material.diffuse[2], SRGBColorSpace);\n      params.opacity = material.diffuse[3];\n      params.specular = new Color().setRGB(...material.specular, SRGBColorSpace);\n      params.shininess = material.shininess;\n      params.emissive = new Color().setRGB(...material.ambient, SRGBColorSpace);\n      params.transparent = params.opacity !== 1.0;\n\n      //\n\n      params.fog = true;\n\n      // blend\n\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor;\n\n      // side\n\n      if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\n      }\n      if (data.metadata.format === 'pmd') {\n        // map, matcap\n\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split('*');\n\n          // fileNames[ 0 ]: mapFileName\n          // fileNames[ 1 ]: matcapFileName( optional )\n\n          params.map = this._loadTexture(fileNames[0], textures);\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.matcap = this._loadTexture(fileNames[1], textures);\n            params.matcapCombine = extension === '.sph' ? MultiplyOperation : AddOperation;\n          }\n        }\n\n        // gradientMap\n\n        const toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        });\n\n        // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n          color: [0, 0, 0],\n          alpha: 1.0,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        // map\n\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n\n          // Since PMX spec don't have standard to list map files except color map and env map,\n          // we need to save file name for further mapping, like matching normal map file names after model loaded.\n          // ref: https://gist.github.com/felixjones/f8a06bd48f9da9a4539f#texture\n          params.userData.MMD.mapFileName = data.textures[material.textureIndex];\n        }\n\n        // matcap TODO: support m.envFlag === 3\n\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.matcap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n\n          // Same as color map above, keep file name in userData for further usage.\n          params.userData.MMD.matcapFileName = data.textures[material.envTextureIndex];\n          params.matcapCombine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        }\n\n        // gradientMap\n\n        let toonFileName, isDefaultToon;\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp';\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        });\n\n        // parameters for OutlineEffect\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0\n        };\n      }\n      if (params.map !== undefined) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n        params.emissive.multiplyScalar(0.2);\n      }\n      materials.push(new MMDToonMaterial(params));\n    }\n    if (data.metadata.format === 'pmx') {\n      // set transparent true if alpha morph is defined.\n\n      function checkAlphaMorph(elements, materials) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1) continue;\n          const material = materials[element.index];\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      }\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8) continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n    return materials;\n  }\n\n  // private methods\n\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === undefined) {\n        throw new Error('THREE.MMDLoader: Import TGALoader');\n      }\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n    return this.tgaLoader;\n  }\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n    if (params.isDefaultToonTexture === true) {\n      let index;\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn('THREE.MMDLoader: ' + filePath + ' seems like a ' + 'not right default texture path. Using toon00.bmp instead.');\n        index = 0;\n      }\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n    if (textures[fullPath] !== undefined) return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader;\n    }\n    const texture = loader.load(fullPath, function (t) {\n      // MMD toon texture is Axis-Y oriented\n      // but Three.js gradient map is Axis-X oriented.\n      // So here replaces the toon texture image with the rotated one.\n      if (params.isToonTexture === true) {\n        t.image = scope._getRotatedImage(t.image);\n        t.magFilter = NearestFilter;\n        t.minFilter = NearestFilter;\n      }\n      t.flipY = false;\n      t.wrapS = RepeatWrapping;\n      t.wrapT = RepeatWrapping;\n      t.colorSpace = SRGBColorSpace;\n      for (let i = 0; i < texture.readyCallbacks.length; i++) {\n        texture.readyCallbacks[i](texture);\n      }\n      delete texture.readyCallbacks;\n    }, onProgress, onError);\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n  _getRotatedImage(image) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2.0, height / 2.0);\n    context.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n    context.translate(-width / 2.0, -height / 2.0);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  }\n\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      // Is there any efficient ways?\n      function createImageData(image) {\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4) return false;\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = {\n            x: 0.0,\n            y: 0.0\n          };\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = {\n              x: uvs[index * 2 + 0],\n              y: uvs[index * 2 + 1]\n            };\n            if (getAlphaByUv(image, uv) < threshold) return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold) return true;\n        }\n        return false;\n      }\n\n      /*\n      \t * This method expects\n      \t *   texture.flipY = false\n      \t *   texture.wrapS = RepeatWrapping\n      \t *   texture.wrapT = RepeatWrapping\n      \t * TODO: more precise\n      \t */\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0) x += width;\n        if (y < 0) y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n      if (texture.isCompressedTexture === true) {\n        if (NON_ALPHA_CHANNEL_FORMATS.includes(texture.format)) {\n          map.transparent = false;\n        } else {\n          // any other way to check transparency of CompressedTexture?\n          map.transparent = true;\n        }\n        return;\n      }\n      const imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n      if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n        map.transparent = true;\n      }\n    });\n  }\n}\n\n//\n\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    // combine skeletal and morph animations\n\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n    return new AnimationClip('', -1, tracks);\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127); // x1\n      array.push(interpolation[index + 8] / 127); // x2\n      array.push(interpolation[index + 4] / 127); // y1\n      array.push(interpolation[index + 12] / 127); // y2\n    }\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === undefined) continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n      const targetName = '.bones[' + key + ']';\n      tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations));\n    }\n    return new AnimationClip('', -1, tracks);\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === undefined) continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values));\n    }\n    return new AnimationClip('', -1, tracks);\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127); // x1\n      array.push(interpolation[index * 4 + 1] / 127); // x2\n      array.push(interpolation[index * 4 + 2] / 127); // y1\n      array.push(interpolation[index * 4 + 3] / 127); // y2\n    }\n    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n      pushInterpolation(qInterpolations, interpolation, 3);\n\n      // use the same parameter for x, y, z axis.\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n    const tracks = [];\n\n    // I expect an object whose name 'target' exists under THREE.Camera\n    tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip('', -1, tracks);\n  }\n\n  // private method\n\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    /*\n    \t * optimizes here not to let KeyframeTrackPrototype optimize\n    \t * because KeyframeTrackPrototype optimizes times and values but\n    \t * doesn't optimize interpolations.\n    \t */\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n    const track = new typedKeyframeTrack(node, times, values);\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n    };\n    return track;\n  }\n}\n\n// interpolation\n\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride;\n\n    // No interpolation if next key frame is in one frame in 30fps.\n    // This is from MMD animation spec.\n    // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n    if (stride === 4) {\n      // Quaternion\n\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      // Vector3\n\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      // Number\n\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n    return result;\n  }\n  _calculate(x1, x2, y1, y2, x) {\n    /*\n    \t * Cubic Bezier curves\n    \t *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n    \t *\n    \t * B(t) = ( 1 - t ) ^ 3 * P0\n    \t *      + 3 * ( 1 - t ) ^ 2 * t * P1\n    \t *      + 3 * ( 1 - t ) * t^2 * P2\n    \t *      + t ^ 3 * P3\n    \t *      ( 0 <= t <= 1 )\n    \t *\n    \t * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n    \t *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n    \t *\n    \t *    x = ( 1 - t ) ^ 3 * x0\n    \t *      + 3 * ( 1 - t ) ^ 2 * t * x1\n    \t *      + 3 * ( 1 - t ) * t^2 * x2\n    \t *      + t ^ 3 * x3\n    \t *    y = ( 1 - t ) ^ 3 * y0\n    \t *      + 3 * ( 1 - t ) ^ 2 * t * y1\n    \t *      + 3 * ( 1 - t ) * t^2 * y2\n    \t *      + t ^ 3 * y3\n    \t *      ( x0 = 0, y0 = 0 )\n    \t *      ( x3 = 1, y3 = 1 )\n    \t *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n    \t *\n    \t * Here solves this equation with Bisection method,\n    \t *   https://en.wikipedia.org/wiki/Bisection_method\n    \t * gets t, and then calculate y.\n    \t *\n    \t * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n    \t *      + 3 * ( 1 - t ) * t^2 * x2\n    \t *      + t ^ 3 - x = 0\n    \t *\n    \t * (Another option: Newton's method\n    \t *    https://en.wikipedia.org/wiki/Newton%27s_method)\n    \t */\n\n    let c = 0.5;\n    let t = c;\n    let s = 1.0 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3.0 * s * s * t;\n      stt3 = 3.0 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps) break;\n      c /= 2.0;\n      t += ft < 0 ? c : -c;\n      s = 1.0 - t;\n    }\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n}\nclass MMDToonMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super();\n    this.isMMDToonMaterial = true;\n    this.type = 'MMDToonMaterial';\n    this._matcapCombine = AddOperation;\n    this.emissiveIntensity = 1.0;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.combine = MultiplyOperation;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.flatShading = false;\n    this.lights = true;\n    this.vertexShader = MMDToonShader.vertexShader;\n    this.fragmentShader = MMDToonShader.fragmentShader;\n    this.defines = Object.assign({}, MMDToonShader.defines);\n    Object.defineProperty(this, 'matcapCombine', {\n      get: function () {\n        return this._matcapCombine;\n      },\n      set: function (value) {\n        this._matcapCombine = value;\n        switch (value) {\n          case MultiplyOperation:\n            this.defines.MATCAP_BLENDING_MULTIPLY = true;\n            delete this.defines.MATCAP_BLENDING_ADD;\n            break;\n          default:\n          case AddOperation:\n            this.defines.MATCAP_BLENDING_ADD = true;\n            delete this.defines.MATCAP_BLENDING_MULTIPLY;\n            break;\n        }\n      }\n    });\n    this.uniforms = UniformsUtils.clone(MMDToonShader.uniforms);\n\n    // merged from MeshToon/Phong/MatcapMaterial\n    const exposePropertyNames = ['specular', 'opacity', 'diffuse', 'map', 'matcap', 'gradientMap', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalScale', 'displacemantBias', 'displacemantMap', 'displacemantScale', 'specularMap', 'alphaMap', 'reflectivity', 'refractionRatio'];\n    for (const propertyName of exposePropertyNames) {\n      Object.defineProperty(this, propertyName, {\n        get: function () {\n          return this.uniforms[propertyName].value;\n        },\n        set: function (value) {\n          this.uniforms[propertyName].value = value;\n        }\n      });\n    }\n\n    // Special path for shininess to handle zero shininess properly\n    this._shininess = 30;\n    Object.defineProperty(this, 'shininess', {\n      get: function () {\n        return this._shininess;\n      },\n      set: function (value) {\n        this._shininess = value;\n        this.uniforms.shininess.value = Math.max(this._shininess, 1e-4); // To prevent pow( 0.0, 0.0 )\n      }\n    });\n    Object.defineProperty(this, 'color', Object.getOwnPropertyDescriptor(this, 'diffuse'));\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.matcapCombine = source.matcapCombine;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.normalMapType = source.normalMapType;\n    this.combine = source.combine;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n}\nexport { MMDLoader };","map":{"version":3,"names":["AddOperation","AnimationClip","Bone","BufferGeometry","Color","CustomBlending","TangentSpaceNormalMap","DoubleSide","DstAlphaFactor","Euler","FileLoader","Float32BufferAttribute","FrontSide","Interpolant","Loader","LoaderUtils","UniformsUtils","ShaderMaterial","MultiplyOperation","NearestFilter","NumberKeyframeTrack","OneMinusSrcAlphaFactor","Quaternion","QuaternionKeyframeTrack","RepeatWrapping","Skeleton","SkinnedMesh","SrcAlphaFactor","SRGBColorSpace","TextureLoader","Uint16BufferAttribute","Vector3","VectorKeyframeTrack","RGB_S3TC_DXT1_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGB_ETC1_Format","RGB_ETC2_Format","MMDToonShader","TGALoader","MMDParser","MMDLoader","constructor","manager","loader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","setAnimationPath","animationPath","load","url","onLoad","onProgress","onError","builder","setCrossOrigin","crossOrigin","resourcePath","path","extractUrlBase","modelExtension","_extractExtension","toLowerCase","Error","data","build","loadAnimation","object","loadVMD","vmd","isCamera","buildCameraAnimation","loadWithAnimation","modelUrl","vmdUrl","scope","mesh","animation","loadPMD","_getParser","setMimeType","undefined","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parsePmd","e","loadPMX","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","loadVPD","isUnicode","text","parseVpd","index","lastIndexOf","slice","Parser","DEFAULT_TOON_TEXTURES","NON_ALPHA_CHANNEL_FORMATS","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","geometry","material","setResourcePath","skeleton","initBones","bind","bones","gbone","bone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","value","boneIndex","type","Math","max","boneCount","boneData","transformationClass","parentIndex","rigidBodyType","format","ikCount","ik","param","target","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","grantEntryMap","grant","ratio","isLocal","affectRotation","affectPosition","children","visited","rootEntry","grantEntry","parentGrantEntry","traverse","entry","child","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","params","morph2","rigidBody","key","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","setAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textureLoader","tgaLoader","textures","diffuse","setRGB","opacity","specular","shininess","emissive","ambient","transparent","fog","blending","blendSrc","blendDst","blendSrcAlpha","blendDstAlpha","flag","side","fileName","fileNames","split","map","_loadTexture","extension","matcap","matcapCombine","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","color","alpha","visible","textureIndex","mapFileName","envTextureIndex","envFlag","matcapFileName","isDefaultToon","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","MMDToonMaterial","checkAlphaMorph","_getTGALoader","test","filePath","fullPath","parseInt","match","console","warn","getHandler","texture","t","image","_getRotatedImage","magFilter","minFilter","flipY","wrapS","wrapT","colorSpace","readyCallbacks","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","createImageData","detectImageTransparency","threshold","centerUV","x","y","getAlphaByUv","round","isCompressedTexture","includes","imageData","group","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","sort","a","b","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","morphTargetDictionary","morphName","values","weight","pushVector3","vec","z","pushQuaternion","q","w","cameras","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","InterpolantFactoryMethodCubicBezier","result","CubicBezierInterpolation","getValueSize","Float32Array","parameterPositions","sampleValues","sampleSize","resultBuffer","interpolationParams","interpolate_","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","c","s","loop","eps","math","sst3","stt3","ttt","ft","abs","parameters","isMMDToonMaterial","_matcapCombine","emissiveIntensity","normalMapType","combine","wireframeLinecap","wireframeLinejoin","flatShading","lights","vertexShader","fragmentShader","defines","Object","assign","defineProperty","get","MATCAP_BLENDING_MULTIPLY","MATCAP_BLENDING_ADD","uniforms","clone","exposePropertyNames","propertyName","_shininess","getOwnPropertyDescriptor","setValues","copy","source"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/loaders/MMDLoader.js"],"sourcesContent":["import {\n\tAddOperation,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tColor,\n\tCustomBlending,\n\tTangentSpaceNormalMap,\n\tDoubleSide,\n\tDstAlphaFactor,\n\tEuler,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tInterpolant,\n\tLoader,\n\tLoaderUtils,\n\tUniformsUtils,\n\tShaderMaterial,\n\tMultiplyOperation,\n\tNearestFilter,\n\tNumberKeyframeTrack,\n\tOneMinusSrcAlphaFactor,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSrcAlphaFactor,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tUint16BufferAttribute,\n\tVector3,\n\tVectorKeyframeTrack,\n\tRGB_S3TC_DXT1_Format,\n\tRGB_PVRTC_4BPPV1_Format,\n\tRGB_PVRTC_2BPPV1_Format,\n\tRGB_ETC1_Format,\n\tRGB_ETC2_Format\n} from 'three';\nimport { MMDToonShader } from '../shaders/MMDToonShader.js';\nimport { TGALoader } from '../loaders/TGALoader.js';\nimport { MMDParser } from '../libs/mmdparser.module.js';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MMDLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.loader = new FileLoader( this.manager );\n\n\t\tthis.parser = null; // lazy generation\n\t\tthis.meshBuilder = new MeshBuilder( this.manager );\n\t\tthis.animationBuilder = new AnimationBuilder();\n\n\t}\n\n\t/**\n\t * @param {string} animationPath\n\t * @return {MMDLoader}\n\t */\n\tsetAnimationPath( animationPath ) {\n\n\t\tthis.animationPath = animationPath;\n\t\treturn this;\n\n\t}\n\n\t// Load MMD assets as Three.js Object\n\n\t/**\n\t * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n\t *\n\t * @param {string} url - url to Model(.pmd or .pmx) file\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst builder = this.meshBuilder.setCrossOrigin( this.crossOrigin );\n\n\t\t// resource path\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\tconst modelExtension = this._extractExtension( url ).toLowerCase();\n\n\t\t// Should I detect by seeing header?\n\t\tif ( modelExtension !== 'pmd' && modelExtension !== 'pmx' ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.' ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis[ modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX' ]( url, function ( data ) {\n\n\t\t\tonLoad(\tbuilder.build( data, resourcePath, onProgress, onError )\t);\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Loads Motion file(s) (.vmd) as a AnimationClip.\n\t * If two or more files are specified, they'll be merged.\n\t *\n\t * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n\t * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tloadAnimation( url, object, onLoad, onProgress, onError ) {\n\n\t\tconst builder = this.animationBuilder;\n\n\t\tthis.loadVMD( url, function ( vmd ) {\n\n\t\t\tonLoad( object.isCamera\n\t\t\t\t? builder.buildCameraAnimation( vmd )\n\t\t\t\t: builder.build( vmd, object ) );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Loads mode file and motion file(s) as an object containing\n\t * a SkinnedMesh and a AnimationClip.\n\t * Tracks of AnimationClip are fitting to the model.\n\t *\n\t * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n\t * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tloadWithAnimation( modelUrl, vmdUrl, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tthis.load( modelUrl, function ( mesh ) {\n\n\t\t\tscope.loadAnimation( vmdUrl, mesh, function ( animation ) {\n\n\t\t\t\tonLoad( {\n\t\t\t\t\tmesh: mesh,\n\t\t\t\t\tanimation: animation\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t// Load MMD assets as Object data parsed by MMDParser\n\n\t/**\n\t * Loads .pmd file as an Object.\n\t *\n\t * @param {string} url - url to .pmd file\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tloadPMD( url, onLoad, onProgress, onError ) {\n\n\t\tconst parser = this._getParser();\n\n\t\tthis.loader\n\t\t\t.setMimeType( undefined )\n\t\t\t.setPath( this.path )\n\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t.setRequestHeader( this.requestHeader )\n\t\t\t.setWithCredentials( this.withCredentials )\n\t\t\t.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( parser.parsePmd( buffer, true ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Loads .pmx file as an Object.\n\t *\n\t * @param {string} url - url to .pmx file\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tloadPMX( url, onLoad, onProgress, onError ) {\n\n\t\tconst parser = this._getParser();\n\n\t\tthis.loader\n\t\t\t.setMimeType( undefined )\n\t\t\t.setPath( this.path )\n\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t.setRequestHeader( this.requestHeader )\n\t\t\t.setWithCredentials( this.withCredentials )\n\t\t\t.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( parser.parsePmx( buffer, true ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Loads .vmd file as an Object. If two or more files are specified\n\t * they'll be merged.\n\t *\n\t * @param {string|Array<string>} url - url(s) to .vmd file(s)\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tloadVMD( url, onLoad, onProgress, onError ) {\n\n\t\tconst urls = Array.isArray( url ) ? url : [ url ];\n\n\t\tconst vmds = [];\n\t\tconst vmdNum = urls.length;\n\n\t\tconst parser = this._getParser();\n\n\t\tthis.loader\n\t\t\t.setMimeType( undefined )\n\t\t\t.setPath( this.animationPath )\n\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t.setRequestHeader( this.requestHeader )\n\t\t\t.setWithCredentials( this.withCredentials );\n\n\t\tfor ( let i = 0, il = urls.length; i < il; i ++ ) {\n\n\t\t\tthis.loader.load( urls[ i ], function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvmds.push( parser.parseVmd( buffer, true ) );\n\n\t\t\t\t\tif ( vmds.length === vmdNum ) onLoad( parser.mergeVmds( vmds ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Loads .vpd file as an Object.\n\t *\n\t * @param {string} url - url to .vpd file\n\t * @param {boolean} isUnicode\n\t * @param {function} onLoad\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t */\n\tloadVPD( url, isUnicode, onLoad, onProgress, onError ) {\n\n\t\tconst parser = this._getParser();\n\n\t\tthis.loader\n\t\t\t.setMimeType( isUnicode ? undefined : 'text/plain; charset=shift_jis' )\n\t\t\t.setPath( this.animationPath )\n\t\t\t.setResponseType( 'text' )\n\t\t\t.setRequestHeader( this.requestHeader )\n\t\t\t.setWithCredentials( this.withCredentials )\n\t\t\t.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( parser.parseVpd( text, true ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t}\n\n\t// private methods\n\n\t_extractExtension( url ) {\n\n\t\tconst index = url.lastIndexOf( '.' );\n\t\treturn index < 0 ? '' : url.slice( index + 1 );\n\n\t}\n\n\t_getParser() {\n\n\t\tif ( this.parser === null ) {\n\n\t\t\tthis.parser = new MMDParser.Parser();\n\n\t\t}\n\n\t\treturn this.parser;\n\n\t}\n\n}\n\n// Utilities\n\n/*\n\t * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n\t * We don't need to request external toon image files.\n\t */\nconst DEFAULT_TOON_TEXTURES = [\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='\n];\n\nconst NON_ALPHA_CHANNEL_FORMATS = [\n\tRGB_S3TC_DXT1_Format,\n\tRGB_PVRTC_4BPPV1_Format,\n\tRGB_PVRTC_2BPPV1_Format,\n\tRGB_ETC1_Format,\n\tRGB_ETC2_Format\n];\n\n// Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MeshBuilder {\n\n\tconstructor( manager ) {\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.geometryBuilder = new GeometryBuilder();\n\t\tthis.materialBuilder = new MaterialBuilder( manager );\n\n\t}\n\n\t/**\n\t * @param {string} crossOrigin\n\t * @return {MeshBuilder}\n\t */\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @param {Object} data - parsed PMD/PMX data\n\t * @param {string} resourcePath\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t * @return {SkinnedMesh}\n\t */\n\tbuild( data, resourcePath, onProgress, onError ) {\n\n\t\tconst geometry = this.geometryBuilder.build( data );\n\t\tconst material = this.materialBuilder\n\t\t\t.setCrossOrigin( this.crossOrigin )\n\t\t\t.setResourcePath( resourcePath )\n\t\t\t.build( data, geometry, onProgress, onError );\n\n\t\tconst mesh = new SkinnedMesh( geometry, material );\n\n\t\tconst skeleton = new Skeleton( initBones( mesh ) );\n\t\tmesh.bind( skeleton );\n\n\t\t// console.log( mesh ); // for console debug\n\n\t\treturn mesh;\n\n\t}\n\n}\n\n// TODO: Try to remove this function\n\nfunction initBones( mesh ) {\n\n\tconst geometry = mesh.geometry;\n\n\tconst bones = [];\n\n\tif ( geometry && geometry.bones !== undefined ) {\n\n\t\t// first, create array of 'Bone' objects from geometry data\n\n\t\tfor ( let i = 0, il = geometry.bones.length; i < il; i ++ ) {\n\n\t\t\tconst gbone = geometry.bones[ i ];\n\n\t\t\t// create new 'Bone' object\n\n\t\t\tconst bone = new Bone();\n\t\t\tbones.push( bone );\n\n\t\t\t// apply values\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\t// second, create bone hierarchy\n\n\t\tfor ( let i = 0, il = geometry.bones.length; i < il; i ++ ) {\n\n\t\t\tconst gbone = geometry.bones[ i ];\n\n\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\n\n\t\t\t\t// subsequent bones in the hierarchy\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\t// topmost bone, immediate child of the skinned mesh\n\n\t\t\t\tmesh.add( bones[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// now the bones are part of the scene graph and children of the skinned mesh.\n\t// let's update the corresponding matrices\n\n\tmesh.updateMatrixWorld( true );\n\n\treturn bones;\n\n}\n\n//\n\nclass GeometryBuilder {\n\n\t/**\n\t * @param {Object} data - parsed PMD/PMX data\n\t * @return {BufferGeometry}\n\t */\n\tbuild( data ) {\n\n\t\t// for geometry\n\t\tconst positions = [];\n\t\tconst uvs = [];\n\t\tconst normals = [];\n\n\t\tconst indices = [];\n\n\t\tconst groups = [];\n\n\t\tconst bones = [];\n\t\tconst skinIndices = [];\n\t\tconst skinWeights = [];\n\n\t\tconst morphTargets = [];\n\t\tconst morphPositions = [];\n\n\t\tconst iks = [];\n\t\tconst grants = [];\n\n\t\tconst rigidBodies = [];\n\t\tconst constraints = [];\n\n\t\t// for work\n\t\tlet offset = 0;\n\t\tconst boneTypeTable = {};\n\n\t\t// positions, normals, uvs, skinIndices, skinWeights\n\n\t\tfor ( let i = 0; i < data.metadata.vertexCount; i ++ ) {\n\n\t\t\tconst v = data.vertices[ i ];\n\n\t\t\tfor ( let j = 0, jl = v.position.length; j < jl; j ++ ) {\n\n\t\t\t\tpositions.push( v.position[ j ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = v.normal.length; j < jl; j ++ ) {\n\n\t\t\t\tnormals.push( v.normal[ j ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = v.uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvs.push( v.uv[ j ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\tskinIndices.push( v.skinIndices.length - 1 >= j ? v.skinIndices[ j ] : 0.0 );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\tskinWeights.push( v.skinWeights.length - 1 >= j ? v.skinWeights[ j ] : 0.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < data.metadata.faceCount; i ++ ) {\n\n\t\t\tconst face = data.faces[ i ];\n\n\t\t\tfor ( let j = 0, jl = face.indices.length; j < jl; j ++ ) {\n\n\t\t\t\tindices.push( face.indices[ j ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// groups\n\n\t\tfor ( let i = 0; i < data.metadata.materialCount; i ++ ) {\n\n\t\t\tconst material = data.materials[ i ];\n\n\t\t\tgroups.push( {\n\t\t\t\toffset: offset * 3,\n\t\t\t\tcount: material.faceCount * 3\n\t\t\t} );\n\n\t\t\toffset += material.faceCount;\n\n\t\t}\n\n\t\t// bones\n\n\t\tfor ( let i = 0; i < data.metadata.rigidBodyCount; i ++ ) {\n\n\t\t\tconst body = data.rigidBodies[ i ];\n\t\t\tlet value = boneTypeTable[ body.boneIndex ];\n\n\t\t\t// keeps greater number if already value is set without any special reasons\n\t\t\tvalue = value === undefined ? body.type : Math.max( body.type, value );\n\n\t\t\tboneTypeTable[ body.boneIndex ] = value;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < data.metadata.boneCount; i ++ ) {\n\n\t\t\tconst boneData = data.bones[ i ];\n\n\t\t\tconst bone = {\n\t\t\t\tindex: i,\n\t\t\t\ttransformationClass: boneData.transformationClass,\n\t\t\t\tparent: boneData.parentIndex,\n\t\t\t\tname: boneData.name,\n\t\t\t\tpos: boneData.position.slice( 0, 3 ),\n\t\t\t\trotq: [ 0, 0, 0, 1 ],\n\t\t\t\tscl: [ 1, 1, 1 ],\n\t\t\t\trigidBodyType: boneTypeTable[ i ] !== undefined ? boneTypeTable[ i ] : - 1\n\t\t\t};\n\n\t\t\tif ( bone.parent !== - 1 ) {\n\n\t\t\t\tbone.pos[ 0 ] -= data.bones[ bone.parent ].position[ 0 ];\n\t\t\t\tbone.pos[ 1 ] -= data.bones[ bone.parent ].position[ 1 ];\n\t\t\t\tbone.pos[ 2 ] -= data.bones[ bone.parent ].position[ 2 ];\n\n\t\t\t}\n\n\t\t\tbones.push( bone );\n\n\t\t}\n\n\t\t// iks\n\n\t\t// TODO: remove duplicated codes between PMD and PMX\n\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\tfor ( let i = 0; i < data.metadata.ikCount; i ++ ) {\n\n\t\t\t\tconst ik = data.iks[ i ];\n\n\t\t\t\tconst param = {\n\t\t\t\t\ttarget: ik.target,\n\t\t\t\t\teffector: ik.effector,\n\t\t\t\t\titeration: ik.iteration,\n\t\t\t\t\tmaxAngle: ik.maxAngle * 4,\n\t\t\t\t\tlinks: []\n\t\t\t\t};\n\n\t\t\t\tfor ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst link = {};\n\t\t\t\t\tlink.index = ik.links[ j ].index;\n\t\t\t\t\tlink.enabled = true;\n\n\t\t\t\t\tif ( data.bones[ link.index ].name.indexOf( 'ひざ' ) >= 0 ) {\n\n\t\t\t\t\t\tlink.limitation = new Vector3( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparam.links.push( link );\n\n\t\t\t\t}\n\n\t\t\t\tiks.push( param );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < data.metadata.boneCount; i ++ ) {\n\n\t\t\t\tconst ik = data.bones[ i ].ik;\n\n\t\t\t\tif ( ik === undefined ) continue;\n\n\t\t\t\tconst param = {\n\t\t\t\t\ttarget: i,\n\t\t\t\t\teffector: ik.effector,\n\t\t\t\t\titeration: ik.iteration,\n\t\t\t\t\tmaxAngle: ik.maxAngle,\n\t\t\t\t\tlinks: []\n\t\t\t\t};\n\n\t\t\t\tfor ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst link = {};\n\t\t\t\t\tlink.index = ik.links[ j ].index;\n\t\t\t\t\tlink.enabled = true;\n\n\t\t\t\t\tif ( ik.links[ j ].angleLimitation === 1 ) {\n\n\t\t\t\t\t\t// Revert if rotationMin/Max doesn't work well\n\t\t\t\t\t\t// link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\tconst rotationMin = ik.links[ j ].lowerLimitationAngle;\n\t\t\t\t\t\tconst rotationMax = ik.links[ j ].upperLimitationAngle;\n\n\t\t\t\t\t\t// Convert Left to Right coordinate by myself because\n\t\t\t\t\t\t// MMDParser doesn't convert. It's a MMDParser's bug\n\n\t\t\t\t\t\tconst tmp1 = - rotationMax[ 0 ];\n\t\t\t\t\t\tconst tmp2 = - rotationMax[ 1 ];\n\t\t\t\t\t\trotationMax[ 0 ] = - rotationMin[ 0 ];\n\t\t\t\t\t\trotationMax[ 1 ] = - rotationMin[ 1 ];\n\t\t\t\t\t\trotationMin[ 0 ] = tmp1;\n\t\t\t\t\t\trotationMin[ 1 ] = tmp2;\n\n\t\t\t\t\t\tlink.rotationMin = new Vector3().fromArray( rotationMin );\n\t\t\t\t\t\tlink.rotationMax = new Vector3().fromArray( rotationMax );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparam.links.push( link );\n\n\t\t\t\t}\n\n\t\t\t\tiks.push( param );\n\n\t\t\t\t// Save the reference even from bone data for efficiently\n\t\t\t\t// simulating PMX animation system\n\t\t\t\tbones[ i ].ik = param;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// grants\n\n\t\tif ( data.metadata.format === 'pmx' ) {\n\n\t\t\t// bone index -> grant entry map\n\t\t\tconst grantEntryMap = {};\n\n\t\t\tfor ( let i = 0; i < data.metadata.boneCount; i ++ ) {\n\n\t\t\t\tconst boneData = data.bones[ i ];\n\t\t\t\tconst grant = boneData.grant;\n\n\t\t\t\tif ( grant === undefined ) continue;\n\n\t\t\t\tconst param = {\n\t\t\t\t\tindex: i,\n\t\t\t\t\tparentIndex: grant.parentIndex,\n\t\t\t\t\tratio: grant.ratio,\n\t\t\t\t\tisLocal: grant.isLocal,\n\t\t\t\t\taffectRotation: grant.affectRotation,\n\t\t\t\t\taffectPosition: grant.affectPosition,\n\t\t\t\t\ttransformationClass: boneData.transformationClass\n\t\t\t\t};\n\n\t\t\t\tgrantEntryMap[ i ] = { parent: null, children: [], param: param, visited: false };\n\n\t\t\t}\n\n\t\t\tconst rootEntry = { parent: null, children: [], param: null, visited: false };\n\n\t\t\t// Build a tree representing grant hierarchy\n\n\t\t\tfor ( const boneIndex in grantEntryMap ) {\n\n\t\t\t\tconst grantEntry = grantEntryMap[ boneIndex ];\n\t\t\t\tconst parentGrantEntry = grantEntryMap[ grantEntry.parentIndex ] || rootEntry;\n\n\t\t\t\tgrantEntry.parent = parentGrantEntry;\n\t\t\t\tparentGrantEntry.children.push( grantEntry );\n\n\t\t\t}\n\n\t\t\t// Sort grant parameters from parents to children because\n\t\t\t// grant uses parent's transform that parent's grant is already applied\n\t\t\t// so grant should be applied in order from parents to children\n\n\t\t\tfunction traverse( entry ) {\n\n\t\t\t\tif ( entry.param ) {\n\n\t\t\t\t\tgrants.push( entry.param );\n\n\t\t\t\t\t// Save the reference even from bone data for efficiently\n\t\t\t\t\t// simulating PMX animation system\n\t\t\t\t\tbones[ entry.param.index ].grant = entry.param;\n\n\t\t\t\t}\n\n\t\t\t\tentry.visited = true;\n\n\t\t\t\tfor ( let i = 0, il = entry.children.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst child = entry.children[ i ];\n\n\t\t\t\t\t// Cut off a loop if exists. (Is a grant loop invalid?)\n\t\t\t\t\tif ( ! child.visited ) traverse( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttraverse( rootEntry );\n\n\t\t}\n\n\t\t// morph\n\n\t\tfunction updateAttributes( attribute, morph, ratio ) {\n\n\t\t\tfor ( let i = 0; i < morph.elementCount; i ++ ) {\n\n\t\t\t\tconst element = morph.elements[ i ];\n\n\t\t\t\tlet index;\n\n\t\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\t\tindex = data.morphs[ 0 ].elements[ element.index ].index;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = element.index;\n\n\t\t\t\t}\n\n\t\t\t\tattribute.array[ index * 3 + 0 ] += element.position[ 0 ] * ratio;\n\t\t\t\tattribute.array[ index * 3 + 1 ] += element.position[ 1 ] * ratio;\n\t\t\t\tattribute.array[ index * 3 + 2 ] += element.position[ 2 ] * ratio;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < data.metadata.morphCount; i ++ ) {\n\n\t\t\tconst morph = data.morphs[ i ];\n\t\t\tconst params = { name: morph.name };\n\n\t\t\tconst attribute = new Float32BufferAttribute( data.metadata.vertexCount * 3, 3 );\n\t\t\tattribute.name = morph.name;\n\n\t\t\tfor ( let j = 0; j < data.metadata.vertexCount * 3; j ++ ) {\n\n\t\t\t\tattribute.array[ j ] = positions[ j ];\n\n\t\t\t}\n\n\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\tif ( i !== 0 ) {\n\n\t\t\t\t\tupdateAttributes( attribute, morph, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( morph.type === 0 ) { // group\n\n\t\t\t\t\tfor ( let j = 0; j < morph.elementCount; j ++ ) {\n\n\t\t\t\t\t\tconst morph2 = data.morphs[ morph.elements[ j ].index ];\n\t\t\t\t\t\tconst ratio = morph.elements[ j ].ratio;\n\n\t\t\t\t\t\tif ( morph2.type === 1 ) {\n\n\t\t\t\t\t\t\tupdateAttributes( attribute, morph2, ratio );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( morph.type === 1 ) { // vertex\n\n\t\t\t\t\tupdateAttributes( attribute, morph, 1.0 );\n\n\t\t\t\t} else if ( morph.type === 2 ) { // bone\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if ( morph.type === 3 ) { // uv\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if ( morph.type === 4 ) { // additional uv1\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if ( morph.type === 5 ) { // additional uv2\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if ( morph.type === 6 ) { // additional uv3\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if ( morph.type === 7 ) { // additional uv4\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if ( morph.type === 8 ) { // material\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmorphTargets.push( params );\n\t\t\tmorphPositions.push( attribute );\n\n\t\t}\n\n\t\t// rigid bodies from rigidBodies field.\n\n\t\tfor ( let i = 0; i < data.metadata.rigidBodyCount; i ++ ) {\n\n\t\t\tconst rigidBody = data.rigidBodies[ i ];\n\t\t\tconst params = {};\n\n\t\t\tfor ( const key in rigidBody ) {\n\n\t\t\t\tparams[ key ] = rigidBody[ key ];\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\t * RigidBody position parameter in PMX seems global position\n\t\t\t\t * while the one in PMD seems offset from corresponding bone.\n\t\t\t\t * So unify being offset.\n\t\t\t\t */\n\t\t\tif ( data.metadata.format === 'pmx' ) {\n\n\t\t\t\tif ( params.boneIndex !== - 1 ) {\n\n\t\t\t\t\tconst bone = data.bones[ params.boneIndex ];\n\t\t\t\t\tparams.position[ 0 ] -= bone.position[ 0 ];\n\t\t\t\t\tparams.position[ 1 ] -= bone.position[ 1 ];\n\t\t\t\t\tparams.position[ 2 ] -= bone.position[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\trigidBodies.push( params );\n\n\t\t}\n\n\t\t// constraints from constraints field.\n\n\t\tfor ( let i = 0; i < data.metadata.constraintCount; i ++ ) {\n\n\t\t\tconst constraint = data.constraints[ i ];\n\t\t\tconst params = {};\n\n\t\t\tfor ( const key in constraint ) {\n\n\t\t\t\tparams[ key ] = constraint[ key ];\n\n\t\t\t}\n\n\t\t\tconst bodyA = rigidBodies[ params.rigidBodyIndex1 ];\n\t\t\tconst bodyB = rigidBodies[ params.rigidBodyIndex2 ];\n\n\t\t\t// Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n\t\t\tif ( bodyA.type !== 0 && bodyB.type === 2 ) {\n\n\t\t\t\tif ( bodyA.boneIndex !== - 1 && bodyB.boneIndex !== - 1 &&\n\t\t\t\t\t     data.bones[ bodyB.boneIndex ].parentIndex === bodyA.boneIndex ) {\n\n\t\t\t\t\tbodyB.type = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconstraints.push( params );\n\n\t\t}\n\n\t\t// build BufferGeometry.\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tgeometry.setAttribute( 'skinIndex', new Uint16BufferAttribute( skinIndices, 4 ) );\n\t\tgeometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeights, 4 ) );\n\t\tgeometry.setIndex( indices );\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tgeometry.addGroup( groups[ i ].offset, groups[ i ].count, i );\n\n\t\t}\n\n\t\tgeometry.bones = bones;\n\n\t\tgeometry.morphTargets = morphTargets;\n\t\tgeometry.morphAttributes.position = morphPositions;\n\t\tgeometry.morphTargetsRelative = false;\n\n\t\tgeometry.userData.MMD = {\n\t\t\tbones: bones,\n\t\t\tiks: iks,\n\t\t\tgrants: grants,\n\t\t\trigidBodies: rigidBodies,\n\t\t\tconstraints: constraints,\n\t\t\tformat: data.metadata.format\n\t\t};\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n//\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MaterialBuilder {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = manager;\n\n\t\tthis.textureLoader = new TextureLoader( this.manager );\n\t\tthis.tgaLoader = null; // lazy generation\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.resourcePath = undefined;\n\n\t}\n\n\t/**\n\t * @param {string} crossOrigin\n\t * @return {MaterialBuilder}\n\t */\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @param {string} resourcePath\n\t * @return {MaterialBuilder}\n\t */\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @param {Object} data - parsed PMD/PMX data\n\t * @param {BufferGeometry} geometry - some properties are dependend on geometry\n\t * @param {function} onProgress\n\t * @param {function} onError\n\t * @return {Array<MMDToonMaterial>}\n\t */\n\tbuild( data, geometry /*, onProgress, onError */ ) {\n\n\t\tconst materials = [];\n\n\t\tconst textures = {};\n\n\t\tthis.textureLoader.setCrossOrigin( this.crossOrigin );\n\n\t\t// materials\n\n\t\tfor ( let i = 0; i < data.metadata.materialCount; i ++ ) {\n\n\t\t\tconst material = data.materials[ i ];\n\n\t\t\tconst params = { userData: { MMD: {} } };\n\n\t\t\tif ( material.name !== undefined ) params.name = material.name;\n\n\t\t\t/*\n\t\t\t\t * Color\n\t\t\t\t *\n\t\t\t\t * MMD         MMDToonMaterial\n\t\t\t\t * ambient  -  emissive * a\n\t\t\t\t *               (a = 1.0 without map texture or 0.2 with map texture)\n\t\t\t\t *\n\t\t\t\t * MMDToonMaterial doesn't have ambient. Set it to emissive instead.\n\t\t\t\t * It'll be too bright if material has map texture so using coef 0.2.\n\t\t\t\t */\n\t\t\tparams.diffuse = new Color().setRGB(\n\t\t\t\tmaterial.diffuse[ 0 ],\n\t\t\t\tmaterial.diffuse[ 1 ],\n\t\t\t\tmaterial.diffuse[ 2 ],\n\t\t\t\tSRGBColorSpace\n\t\t\t);\n\t\t\tparams.opacity = material.diffuse[ 3 ];\n\t\t\tparams.specular = new Color().setRGB( ...material.specular, SRGBColorSpace );\n\t\t\tparams.shininess = material.shininess;\n\t\t\tparams.emissive = new Color().setRGB( ...material.ambient, SRGBColorSpace );\n\t\t\tparams.transparent = params.opacity !== 1.0;\n\n\t\t\t//\n\n\t\t\tparams.fog = true;\n\n\t\t\t// blend\n\n\t\t\tparams.blending = CustomBlending;\n\t\t\tparams.blendSrc = SrcAlphaFactor;\n\t\t\tparams.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tparams.blendSrcAlpha = SrcAlphaFactor;\n\t\t\tparams.blendDstAlpha = DstAlphaFactor;\n\n\t\t\t// side\n\n\t\t\tif ( data.metadata.format === 'pmx' && ( material.flag & 0x1 ) === 1 ) {\n\n\t\t\t\tparams.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\tparams.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\n\n\t\t\t}\n\n\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\t// map, matcap\n\n\t\t\t\tif ( material.fileName ) {\n\n\t\t\t\t\tconst fileName = material.fileName;\n\t\t\t\t\tconst fileNames = fileName.split( '*' );\n\n\t\t\t\t\t// fileNames[ 0 ]: mapFileName\n\t\t\t\t\t// fileNames[ 1 ]: matcapFileName( optional )\n\n\t\t\t\t\tparams.map = this._loadTexture( fileNames[ 0 ], textures );\n\n\t\t\t\t\tif ( fileNames.length > 1 ) {\n\n\t\t\t\t\t\tconst extension = fileNames[ 1 ].slice( - 4 ).toLowerCase();\n\n\t\t\t\t\t\tparams.matcap = this._loadTexture(\n\t\t\t\t\t\t\tfileNames[ 1 ],\n\t\t\t\t\t\t\ttextures\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tparams.matcapCombine = extension === '.sph'\n\t\t\t\t\t\t\t? MultiplyOperation\n\t\t\t\t\t\t\t: AddOperation;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// gradientMap\n\n\t\t\t\tconst toonFileName = ( material.toonIndex === - 1 )\n\t\t\t\t\t? 'toon00.bmp'\n\t\t\t\t\t: data.toonTextures[ material.toonIndex ].fileName;\n\n\t\t\t\tparams.gradientMap = this._loadTexture(\n\t\t\t\t\ttoonFileName,\n\t\t\t\t\ttextures,\n\t\t\t\t\t{\n\t\t\t\t\t\tisToonTexture: true,\n\t\t\t\t\t\tisDefaultToonTexture: this._isDefaultToonTexture( toonFileName )\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// parameters for OutlineEffect\n\n\t\t\t\tparams.userData.outlineParameters = {\n\t\t\t\t\tthickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n\t\t\t\t\tcolor: [ 0, 0, 0 ],\n\t\t\t\t\talpha: 1.0,\n\t\t\t\t\tvisible: material.edgeFlag === 1\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\t// map\n\n\t\t\t\tif ( material.textureIndex !== - 1 ) {\n\n\t\t\t\t\tparams.map = this._loadTexture( data.textures[ material.textureIndex ], textures );\n\n\t\t\t\t\t// Since PMX spec don't have standard to list map files except color map and env map,\n\t\t\t\t\t// we need to save file name for further mapping, like matching normal map file names after model loaded.\n\t\t\t\t\t// ref: https://gist.github.com/felixjones/f8a06bd48f9da9a4539f#texture\n\t\t\t\t\tparams.userData.MMD.mapFileName = data.textures[ material.textureIndex ];\n\n\t\t\t\t}\n\n\t\t\t\t// matcap TODO: support m.envFlag === 3\n\n\t\t\t\tif ( material.envTextureIndex !== - 1 && ( material.envFlag === 1 || material.envFlag == 2 ) ) {\n\n\t\t\t\t\tparams.matcap = this._loadTexture(\n\t\t\t\t\t\tdata.textures[ material.envTextureIndex ],\n\t\t\t\t\t\ttextures\n\t\t\t\t\t);\n\n\t\t\t\t\t// Same as color map above, keep file name in userData for further usage.\n\t\t\t\t\tparams.userData.MMD.matcapFileName = data.textures[ material.envTextureIndex ];\n\n\t\t\t\t\tparams.matcapCombine = material.envFlag === 1\n\t\t\t\t\t\t? MultiplyOperation\n\t\t\t\t\t\t: AddOperation;\n\n\t\t\t\t}\n\n\t\t\t\t// gradientMap\n\n\t\t\t\tlet toonFileName, isDefaultToon;\n\n\t\t\t\tif ( material.toonIndex === - 1 || material.toonFlag !== 0 ) {\n\n\t\t\t\t\ttoonFileName = 'toon' + ( '0' + ( material.toonIndex + 1 ) ).slice( - 2 ) + '.bmp';\n\t\t\t\t\tisDefaultToon = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttoonFileName = data.textures[ material.toonIndex ];\n\t\t\t\t\tisDefaultToon = false;\n\n\t\t\t\t}\n\n\t\t\t\tparams.gradientMap = this._loadTexture(\n\t\t\t\t\ttoonFileName,\n\t\t\t\t\ttextures,\n\t\t\t\t\t{\n\t\t\t\t\t\tisToonTexture: true,\n\t\t\t\t\t\tisDefaultToonTexture: isDefaultToon\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// parameters for OutlineEffect\n\t\t\t\tparams.userData.outlineParameters = {\n\t\t\t\t\tthickness: material.edgeSize / 300, // TODO: better calculation?\n\t\t\t\t\tcolor: material.edgeColor.slice( 0, 3 ),\n\t\t\t\t\talpha: material.edgeColor[ 3 ],\n\t\t\t\t\tvisible: ( material.flag & 0x10 ) !== 0 && material.edgeSize > 0.0\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif ( params.map !== undefined ) {\n\n\t\t\t\tif ( ! params.transparent ) {\n\n\t\t\t\t\tthis._checkImageTransparency( params.map, geometry, i );\n\n\t\t\t\t}\n\n\t\t\t\tparams.emissive.multiplyScalar( 0.2 );\n\n\t\t\t}\n\n\t\t\tmaterials.push( new MMDToonMaterial( params ) );\n\n\t\t}\n\n\t\tif ( data.metadata.format === 'pmx' ) {\n\n\t\t\t// set transparent true if alpha morph is defined.\n\n\t\t\tfunction checkAlphaMorph( elements, materials ) {\n\n\t\t\t\tfor ( let i = 0, il = elements.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\t\tif ( element.index === - 1 ) continue;\n\n\t\t\t\t\tconst material = materials[ element.index ];\n\n\t\t\t\t\tif ( material.opacity !== element.diffuse[ 3 ] ) {\n\n\t\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = data.morphs.length; i < il; i ++ ) {\n\n\t\t\t\tconst morph = data.morphs[ i ];\n\t\t\t\tconst elements = morph.elements;\n\n\t\t\t\tif ( morph.type === 0 ) {\n\n\t\t\t\t\tfor ( let j = 0, jl = elements.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst morph2 = data.morphs[ elements[ j ].index ];\n\n\t\t\t\t\t\tif ( morph2.type !== 8 ) continue;\n\n\t\t\t\t\t\tcheckAlphaMorph( morph2.elements, materials );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( morph.type === 8 ) {\n\n\t\t\t\t\tcheckAlphaMorph( elements, materials );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\t// private methods\n\n\t_getTGALoader() {\n\n\t\tif ( this.tgaLoader === null ) {\n\n\t\t\tif ( TGALoader === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.MMDLoader: Import TGALoader' );\n\n\t\t\t}\n\n\t\t\tthis.tgaLoader = new TGALoader( this.manager );\n\n\t\t}\n\n\t\treturn this.tgaLoader;\n\n\t}\n\n\t_isDefaultToonTexture( name ) {\n\n\t\tif ( name.length !== 10 ) return false;\n\n\t\treturn /toon(10|0[0-9])\\.bmp/.test( name );\n\n\t}\n\n\t_loadTexture( filePath, textures, params, onProgress, onError ) {\n\n\t\tparams = params || {};\n\n\t\tconst scope = this;\n\n\t\tlet fullPath;\n\n\t\tif ( params.isDefaultToonTexture === true ) {\n\n\t\t\tlet index;\n\n\t\t\ttry {\n\n\t\t\t\tindex = parseInt( filePath.match( /toon([0-9]{2})\\.bmp$/ )[ 1 ] );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.MMDLoader: ' + filePath + ' seems like a '\n\t\t\t\t\t\t+ 'not right default texture path. Using toon00.bmp instead.' );\n\n\t\t\t\tindex = 0;\n\n\t\t\t}\n\n\t\t\tfullPath = DEFAULT_TOON_TEXTURES[ index ];\n\n\t\t} else {\n\n\t\t\tfullPath = this.resourcePath + filePath;\n\n\t\t}\n\n\t\tif ( textures[ fullPath ] !== undefined ) return textures[ fullPath ];\n\n\t\tlet loader = this.manager.getHandler( fullPath );\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = ( filePath.slice( - 4 ).toLowerCase() === '.tga' )\n\t\t\t\t? this._getTGALoader()\n\t\t\t\t: this.textureLoader;\n\n\t\t}\n\n\t\tconst texture = loader.load( fullPath, function ( t ) {\n\n\t\t\t// MMD toon texture is Axis-Y oriented\n\t\t\t// but Three.js gradient map is Axis-X oriented.\n\t\t\t// So here replaces the toon texture image with the rotated one.\n\t\t\tif ( params.isToonTexture === true ) {\n\n\t\t\t\tt.image = scope._getRotatedImage( t.image );\n\n\t\t\t\tt.magFilter = NearestFilter;\n\t\t\t\tt.minFilter = NearestFilter;\n\n\t\t\t}\n\n\t\t\tt.flipY = false;\n\t\t\tt.wrapS = RepeatWrapping;\n\t\t\tt.wrapT = RepeatWrapping;\n\t\t\tt.colorSpace = SRGBColorSpace;\n\n\t\t\tfor ( let i = 0; i < texture.readyCallbacks.length; i ++ ) {\n\n\t\t\t\ttexture.readyCallbacks[ i ]( texture );\n\n\t\t\t}\n\n\t\t\tdelete texture.readyCallbacks;\n\n\t\t}, onProgress, onError );\n\n\t\ttexture.readyCallbacks = [];\n\n\t\ttextures[ fullPath ] = texture;\n\n\t\treturn texture;\n\n\t}\n\n\t_getRotatedImage( image ) {\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tconst context = canvas.getContext( '2d' );\n\n\t\tconst width = image.width;\n\t\tconst height = image.height;\n\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tcontext.clearRect( 0, 0, width, height );\n\t\tcontext.translate( width / 2.0, height / 2.0 );\n\t\tcontext.rotate( 0.5 * Math.PI ); // 90.0 * Math.PI / 180.0\n\t\tcontext.translate( - width / 2.0, - height / 2.0 );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\treturn context.getImageData( 0, 0, width, height );\n\n\t}\n\n\t// Check if the partial image area used by the texture is transparent.\n\t_checkImageTransparency( map, geometry, groupIndex ) {\n\n\t\tmap.readyCallbacks.push( function ( texture ) {\n\n\t\t\t// Is there any efficient ways?\n\t\t\tfunction createImageData( image ) {\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0 );\n\n\t\t\t\treturn context.getImageData( 0, 0, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t\tfunction detectImageTransparency( image, uvs, indices ) {\n\n\t\t\t\tconst width = image.width;\n\t\t\t\tconst height = image.height;\n\t\t\t\tconst data = image.data;\n\t\t\t\tconst threshold = 253;\n\n\t\t\t\tif ( data.length / ( width * height ) !== 4 ) return false;\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\tconst centerUV = { x: 0.0, y: 0.0 };\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tconst index = indices[ i * 3 + j ];\n\t\t\t\t\t\tconst uv = { x: uvs[ index * 2 + 0 ], y: uvs[ index * 2 + 1 ] };\n\n\t\t\t\t\t\tif ( getAlphaByUv( image, uv ) < threshold ) return true;\n\n\t\t\t\t\t\tcenterUV.x += uv.x;\n\t\t\t\t\t\tcenterUV.y += uv.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcenterUV.x /= 3;\n\t\t\t\t\tcenterUV.y /= 3;\n\n\t\t\t\t\tif ( getAlphaByUv( image, centerUV ) < threshold ) return true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\t * This method expects\n\t\t\t\t *   texture.flipY = false\n\t\t\t\t *   texture.wrapS = RepeatWrapping\n\t\t\t\t *   texture.wrapT = RepeatWrapping\n\t\t\t\t * TODO: more precise\n\t\t\t\t */\n\t\t\tfunction getAlphaByUv( image, uv ) {\n\n\t\t\t\tconst width = image.width;\n\t\t\t\tconst height = image.height;\n\n\t\t\t\tlet x = Math.round( uv.x * width ) % width;\n\t\t\t\tlet y = Math.round( uv.y * height ) % height;\n\n\t\t\t\tif ( x < 0 ) x += width;\n\t\t\t\tif ( y < 0 ) y += height;\n\n\t\t\t\tconst index = y * width + x;\n\n\t\t\t\treturn image.data[ index * 4 + 3 ];\n\n\t\t\t}\n\n\t\t\tif ( texture.isCompressedTexture === true ) {\n\n\t\t\t\tif ( NON_ALPHA_CHANNEL_FORMATS.includes( texture.format ) ) {\n\n\t\t\t\t\tmap.transparent = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// any other way to check transparency of CompressedTexture?\n\t\t\t\t\tmap.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst imageData = texture.image.data !== undefined\n\t\t\t\t? texture.image\n\t\t\t\t: createImageData( texture.image );\n\n\t\t\tconst group = geometry.groups[ groupIndex ];\n\n\t\t\tif ( detectImageTransparency(\n\t\t\t\timageData,\n\t\t\t\tgeometry.attributes.uv.array,\n\t\t\t\tgeometry.index.array.slice( group.start, group.start + group.count ) ) ) {\n\n\t\t\t\tmap.transparent = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\n//\n\nclass AnimationBuilder {\n\n\t/**\n\t * @param {Object} vmd - parsed VMD data\n\t * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n\t * @return {AnimationClip}\n\t */\n\tbuild( vmd, mesh ) {\n\n\t\t// combine skeletal and morph animations\n\n\t\tconst tracks = this.buildSkeletalAnimation( vmd, mesh ).tracks;\n\t\tconst tracks2 = this.buildMorphAnimation( vmd, mesh ).tracks;\n\n\t\tfor ( let i = 0, il = tracks2.length; i < il; i ++ ) {\n\n\t\t\ttracks.push( tracks2[ i ] );\n\n\t\t}\n\n\t\treturn new AnimationClip( '', - 1, tracks );\n\n\t}\n\n\t/**\n\t * @param {Object} vmd - parsed VMD data\n\t * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n\t * @return {AnimationClip}\n\t */\n\tbuildSkeletalAnimation( vmd, mesh ) {\n\n\t\tfunction pushInterpolation( array, interpolation, index ) {\n\n\t\t\tarray.push( interpolation[ index + 0 ] / 127 ); // x1\n\t\t\tarray.push( interpolation[ index + 8 ] / 127 ); // x2\n\t\t\tarray.push( interpolation[ index + 4 ] / 127 ); // y1\n\t\t\tarray.push( interpolation[ index + 12 ] / 127 ); // y2\n\n\t\t}\n\n\t\tconst tracks = [];\n\n\t\tconst motions = {};\n\t\tconst bones = mesh.skeleton.bones;\n\t\tconst boneNameDictionary = {};\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\tboneNameDictionary[ bones[ i ].name ] = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < vmd.metadata.motionCount; i ++ ) {\n\n\t\t\tconst motion = vmd.motions[ i ];\n\t\t\tconst boneName = motion.boneName;\n\n\t\t\tif ( boneNameDictionary[ boneName ] === undefined ) continue;\n\n\t\t\tmotions[ boneName ] = motions[ boneName ] || [];\n\t\t\tmotions[ boneName ].push( motion );\n\n\t\t}\n\n\t\tfor ( const key in motions ) {\n\n\t\t\tconst array = motions[ key ];\n\n\t\t\tarray.sort( function ( a, b ) {\n\n\t\t\t\treturn a.frameNum - b.frameNum;\n\n\t\t\t} );\n\n\t\t\tconst times = [];\n\t\t\tconst positions = [];\n\t\t\tconst rotations = [];\n\t\t\tconst pInterpolations = [];\n\t\t\tconst rInterpolations = [];\n\n\t\t\tconst basePosition = mesh.skeleton.getBoneByName( key ).position.toArray();\n\n\t\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\tconst time = array[ i ].frameNum / 30;\n\t\t\t\tconst position = array[ i ].position;\n\t\t\t\tconst rotation = array[ i ].rotation;\n\t\t\t\tconst interpolation = array[ i ].interpolation;\n\n\t\t\t\ttimes.push( time );\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) positions.push( basePosition[ j ] + position[ j ] );\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) rotations.push( rotation[ j ] );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) pushInterpolation( pInterpolations, interpolation, j );\n\n\t\t\t\tpushInterpolation( rInterpolations, interpolation, 3 );\n\n\t\t\t}\n\n\t\t\tconst targetName = '.bones[' + key + ']';\n\n\t\t\ttracks.push( this._createTrack( targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );\n\t\t\ttracks.push( this._createTrack( targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( '', - 1, tracks );\n\n\t}\n\n\t/**\n\t * @param {Object} vmd - parsed VMD data\n\t * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n\t * @return {AnimationClip}\n\t */\n\tbuildMorphAnimation( vmd, mesh ) {\n\n\t\tconst tracks = [];\n\n\t\tconst morphs = {};\n\t\tconst morphTargetDictionary = mesh.morphTargetDictionary;\n\n\t\tfor ( let i = 0; i < vmd.metadata.morphCount; i ++ ) {\n\n\t\t\tconst morph = vmd.morphs[ i ];\n\t\t\tconst morphName = morph.morphName;\n\n\t\t\tif ( morphTargetDictionary[ morphName ] === undefined ) continue;\n\n\t\t\tmorphs[ morphName ] = morphs[ morphName ] || [];\n\t\t\tmorphs[ morphName ].push( morph );\n\n\t\t}\n\n\t\tfor ( const key in morphs ) {\n\n\t\t\tconst array = morphs[ key ];\n\n\t\t\tarray.sort( function ( a, b ) {\n\n\t\t\t\treturn a.frameNum - b.frameNum;\n\n\t\t\t} );\n\n\t\t\tconst times = [];\n\t\t\tconst values = [];\n\n\t\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\ttimes.push( array[ i ].frameNum / 30 );\n\t\t\t\tvalues.push( array[ i ].weight );\n\n\t\t\t}\n\n\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetDictionary[ key ] + ']', times, values ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( '', - 1, tracks );\n\n\t}\n\n\t/**\n\t * @param {Object} vmd - parsed VMD data\n\t * @return {AnimationClip}\n\t */\n\tbuildCameraAnimation( vmd ) {\n\n\t\tfunction pushVector3( array, vec ) {\n\n\t\t\tarray.push( vec.x );\n\t\t\tarray.push( vec.y );\n\t\t\tarray.push( vec.z );\n\n\t\t}\n\n\t\tfunction pushQuaternion( array, q ) {\n\n\t\t\tarray.push( q.x );\n\t\t\tarray.push( q.y );\n\t\t\tarray.push( q.z );\n\t\t\tarray.push( q.w );\n\n\t\t}\n\n\t\tfunction pushInterpolation( array, interpolation, index ) {\n\n\t\t\tarray.push( interpolation[ index * 4 + 0 ] / 127 ); // x1\n\t\t\tarray.push( interpolation[ index * 4 + 1 ] / 127 ); // x2\n\t\t\tarray.push( interpolation[ index * 4 + 2 ] / 127 ); // y1\n\t\t\tarray.push( interpolation[ index * 4 + 3 ] / 127 ); // y2\n\n\t\t}\n\n\t\tconst cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n\n\t\tcameras.sort( function ( a, b ) {\n\n\t\t\treturn a.frameNum - b.frameNum;\n\n\t\t} );\n\n\t\tconst times = [];\n\t\tconst centers = [];\n\t\tconst quaternions = [];\n\t\tconst positions = [];\n\t\tconst fovs = [];\n\n\t\tconst cInterpolations = [];\n\t\tconst qInterpolations = [];\n\t\tconst pInterpolations = [];\n\t\tconst fInterpolations = [];\n\n\t\tconst quaternion = new Quaternion();\n\t\tconst euler = new Euler();\n\t\tconst position = new Vector3();\n\t\tconst center = new Vector3();\n\n\t\tfor ( let i = 0, il = cameras.length; i < il; i ++ ) {\n\n\t\t\tconst motion = cameras[ i ];\n\n\t\t\tconst time = motion.frameNum / 30;\n\t\t\tconst pos = motion.position;\n\t\t\tconst rot = motion.rotation;\n\t\t\tconst distance = motion.distance;\n\t\t\tconst fov = motion.fov;\n\t\t\tconst interpolation = motion.interpolation;\n\n\t\t\ttimes.push( time );\n\n\t\t\tposition.set( 0, 0, - distance );\n\t\t\tcenter.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] );\n\n\t\t\teuler.set( - rot[ 0 ], - rot[ 1 ], - rot[ 2 ] );\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tposition.add( center );\n\t\t\tposition.applyQuaternion( quaternion );\n\n\t\t\tpushVector3( centers, center );\n\t\t\tpushQuaternion( quaternions, quaternion );\n\t\t\tpushVector3( positions, position );\n\n\t\t\tfovs.push( fov );\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tpushInterpolation( cInterpolations, interpolation, j );\n\n\t\t\t}\n\n\t\t\tpushInterpolation( qInterpolations, interpolation, 3 );\n\n\t\t\t// use the same parameter for x, y, z axis.\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tpushInterpolation( pInterpolations, interpolation, 4 );\n\n\t\t\t}\n\n\t\t\tpushInterpolation( fInterpolations, interpolation, 5 );\n\n\t\t}\n\n\t\tconst tracks = [];\n\n\t\t// I expect an object whose name 'target' exists under THREE.Camera\n\t\ttracks.push( this._createTrack( 'target.position', VectorKeyframeTrack, times, centers, cInterpolations ) );\n\n\t\ttracks.push( this._createTrack( '.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations ) );\n\t\ttracks.push( this._createTrack( '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );\n\t\ttracks.push( this._createTrack( '.fov', NumberKeyframeTrack, times, fovs, fInterpolations ) );\n\n\t\treturn new AnimationClip( '', - 1, tracks );\n\n\t}\n\n\t// private method\n\n\t_createTrack( node, typedKeyframeTrack, times, values, interpolations ) {\n\n\t\t/*\n\t\t\t * optimizes here not to let KeyframeTrackPrototype optimize\n\t\t\t * because KeyframeTrackPrototype optimizes times and values but\n\t\t\t * doesn't optimize interpolations.\n\t\t\t */\n\t\tif ( times.length > 2 ) {\n\n\t\t\ttimes = times.slice();\n\t\t\tvalues = values.slice();\n\t\t\tinterpolations = interpolations.slice();\n\n\t\t\tconst stride = values.length / times.length;\n\t\t\tconst interpolateStride = interpolations.length / times.length;\n\n\t\t\tlet index = 1;\n\n\t\t\tfor ( let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < stride; i ++ ) {\n\n\t\t\t\t\tif ( values[ index * stride + i ] !== values[ ( index - 1 ) * stride + i ] ||\n\t\t\t\t\t\t\tvalues[ index * stride + i ] !== values[ aheadIndex * stride + i ] ) {\n\n\t\t\t\t\t\tindex ++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( aheadIndex > index ) {\n\n\t\t\t\t\ttimes[ index ] = times[ aheadIndex ];\n\n\t\t\t\t\tfor ( let i = 0; i < stride; i ++ ) {\n\n\t\t\t\t\t\tvalues[ index * stride + i ] = values[ aheadIndex * stride + i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0; i < interpolateStride; i ++ ) {\n\n\t\t\t\t\t\tinterpolations[ index * interpolateStride + i ] = interpolations[ aheadIndex * interpolateStride + i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttimes.length = index + 1;\n\t\t\tvalues.length = ( index + 1 ) * stride;\n\t\t\tinterpolations.length = ( index + 1 ) * interpolateStride;\n\n\t\t}\n\n\t\tconst track = new typedKeyframeTrack( node, times, values );\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier( result ) {\n\n\t\t\treturn new CubicBezierInterpolation( this.times, this.values, this.getValueSize(), result, new Float32Array( interpolations ) );\n\n\t\t};\n\n\t\treturn track;\n\n\t}\n\n}\n\n// interpolation\n\nclass CubicBezierInterpolation extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer, params ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis.interpolationParams = params;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\t\tconst params = this.interpolationParams;\n\n\t\tconst offset1 = i1 * stride;\n\t\tconst offset0 = offset1 - stride;\n\n\t\t// No interpolation if next key frame is in one frame in 30fps.\n\t\t// This is from MMD animation spec.\n\t\t// '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n\t\tconst weight1 = ( ( t1 - t0 ) < 1 / 30 * 1.5 ) ? 0.0 : ( t - t0 ) / ( t1 - t0 );\n\n\t\tif ( stride === 4 ) { // Quaternion\n\n\t\t\tconst x1 = params[ i1 * 4 + 0 ];\n\t\t\tconst x2 = params[ i1 * 4 + 1 ];\n\t\t\tconst y1 = params[ i1 * 4 + 2 ];\n\t\t\tconst y2 = params[ i1 * 4 + 3 ];\n\n\t\t\tconst ratio = this._calculate( x1, x2, y1, y2, weight1 );\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset0, values, offset1, ratio );\n\n\t\t} else if ( stride === 3 ) { // Vector3\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tconst x1 = params[ i1 * 12 + i * 4 + 0 ];\n\t\t\t\tconst x2 = params[ i1 * 12 + i * 4 + 1 ];\n\t\t\t\tconst y1 = params[ i1 * 12 + i * 4 + 2 ];\n\t\t\t\tconst y2 = params[ i1 * 12 + i * 4 + 3 ];\n\n\t\t\t\tconst ratio = this._calculate( x1, x2, y1, y2, weight1 );\n\n\t\t\t\tresult[ i ] = values[ offset0 + i ] * ( 1 - ratio ) + values[ offset1 + i ] * ratio;\n\n\t\t\t}\n\n\t\t} else { // Number\n\n\t\t\tconst x1 = params[ i1 * 4 + 0 ];\n\t\t\tconst x2 = params[ i1 * 4 + 1 ];\n\t\t\tconst y1 = params[ i1 * 4 + 2 ];\n\t\t\tconst y2 = params[ i1 * 4 + 3 ];\n\n\t\t\tconst ratio = this._calculate( x1, x2, y1, y2, weight1 );\n\n\t\t\tresult[ 0 ] = values[ offset0 ] * ( 1 - ratio ) + values[ offset1 ] * ratio;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t_calculate( x1, x2, y1, y2, x ) {\n\n\t\t/*\n\t\t\t * Cubic Bezier curves\n\t\t\t *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n\t\t\t *\n\t\t\t * B(t) = ( 1 - t ) ^ 3 * P0\n\t\t\t *      + 3 * ( 1 - t ) ^ 2 * t * P1\n\t\t\t *      + 3 * ( 1 - t ) * t^2 * P2\n\t\t\t *      + t ^ 3 * P3\n\t\t\t *      ( 0 <= t <= 1 )\n\t\t\t *\n\t\t\t * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n\t\t\t *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n\t\t\t *\n\t\t\t *    x = ( 1 - t ) ^ 3 * x0\n\t\t\t *      + 3 * ( 1 - t ) ^ 2 * t * x1\n\t\t\t *      + 3 * ( 1 - t ) * t^2 * x2\n\t\t\t *      + t ^ 3 * x3\n\t\t\t *    y = ( 1 - t ) ^ 3 * y0\n\t\t\t *      + 3 * ( 1 - t ) ^ 2 * t * y1\n\t\t\t *      + 3 * ( 1 - t ) * t^2 * y2\n\t\t\t *      + t ^ 3 * y3\n\t\t\t *      ( x0 = 0, y0 = 0 )\n\t\t\t *      ( x3 = 1, y3 = 1 )\n\t\t\t *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n\t\t\t *\n\t\t\t * Here solves this equation with Bisection method,\n\t\t\t *   https://en.wikipedia.org/wiki/Bisection_method\n\t\t\t * gets t, and then calculate y.\n\t\t\t *\n\t\t\t * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n\t\t\t *      + 3 * ( 1 - t ) * t^2 * x2\n\t\t\t *      + t ^ 3 - x = 0\n\t\t\t *\n\t\t\t * (Another option: Newton's method\n\t\t\t *    https://en.wikipedia.org/wiki/Newton%27s_method)\n\t\t\t */\n\n\t\tlet c = 0.5;\n\t\tlet t = c;\n\t\tlet s = 1.0 - t;\n\t\tconst loop = 15;\n\t\tconst eps = 1e-5;\n\t\tconst math = Math;\n\n\t\tlet sst3, stt3, ttt;\n\n\t\tfor ( let i = 0; i < loop; i ++ ) {\n\n\t\t\tsst3 = 3.0 * s * s * t;\n\t\t\tstt3 = 3.0 * s * t * t;\n\t\t\tttt = t * t * t;\n\n\t\t\tconst ft = ( sst3 * x1 ) + ( stt3 * x2 ) + ( ttt ) - x;\n\n\t\t\tif ( math.abs( ft ) < eps ) break;\n\n\t\t\tc /= 2.0;\n\n\t\t\tt += ( ft < 0 ) ? c : - c;\n\t\t\ts = 1.0 - t;\n\n\t\t}\n\n\t\treturn ( sst3 * y1 ) + ( stt3 * y2 ) + ttt;\n\n\t}\n\n}\n\nclass MMDToonMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMMDToonMaterial = true;\n\n\t\tthis.type = 'MMDToonMaterial';\n\n\t\tthis._matcapCombine = AddOperation;\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t\tthis.combine = MultiplyOperation;\n\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.lights = true;\n\n\t\tthis.vertexShader = MMDToonShader.vertexShader;\n\t\tthis.fragmentShader = MMDToonShader.fragmentShader;\n\n\t\tthis.defines = Object.assign( {}, MMDToonShader.defines );\n\t\tObject.defineProperty( this, 'matcapCombine', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._matcapCombine;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._matcapCombine = value;\n\n\t\t\t\tswitch ( value ) {\n\n\t\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\t\tthis.defines.MATCAP_BLENDING_MULTIPLY = true;\n\t\t\t\t\t\tdelete this.defines.MATCAP_BLENDING_ADD;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase AddOperation:\n\t\t\t\t\t\tthis.defines.MATCAP_BLENDING_ADD = true;\n\t\t\t\t\t\tdelete this.defines.MATCAP_BLENDING_MULTIPLY;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t} );\n\n\t\tthis.uniforms = UniformsUtils.clone( MMDToonShader.uniforms );\n\n\t\t// merged from MeshToon/Phong/MatcapMaterial\n\t\tconst exposePropertyNames = [\n\t\t\t'specular',\n\t\t\t'opacity',\n\t\t\t'diffuse',\n\n\t\t\t'map',\n\t\t\t'matcap',\n\t\t\t'gradientMap',\n\n\t\t\t'lightMap',\n\t\t\t'lightMapIntensity',\n\n\t\t\t'aoMap',\n\t\t\t'aoMapIntensity',\n\n\t\t\t'emissive',\n\t\t\t'emissiveMap',\n\n\t\t\t'bumpMap',\n\t\t\t'bumpScale',\n\n\t\t\t'normalMap',\n\t\t\t'normalScale',\n\n\t\t\t'displacemantBias',\n\t\t\t'displacemantMap',\n\t\t\t'displacemantScale',\n\n\t\t\t'specularMap',\n\n\t\t\t'alphaMap',\n\n\t\t\t'reflectivity',\n\t\t\t'refractionRatio',\n\t\t];\n\t\tfor ( const propertyName of exposePropertyNames ) {\n\n\t\t\tObject.defineProperty( this, propertyName, {\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms[ propertyName ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms[ propertyName ].value = value;\n\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Special path for shininess to handle zero shininess properly\n\t\tthis._shininess = 30;\n\t\tObject.defineProperty( this, 'shininess', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._shininess;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._shininess = value;\n\t\t\t\tthis.uniforms.shininess.value = Math.max( this._shininess, 1e-4 ); // To prevent pow( 0.0, 0.0 )\n\n\t\t\t},\n\n\t\t} );\n\n\t\tObject.defineProperty(\n\t\t\tthis,\n\t\t\t'color',\n\t\t\tObject.getOwnPropertyDescriptor( this, 'diffuse' )\n\t\t);\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.matcapCombine = source.matcapCombine;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\tthis.normalMapType = source.normalMapType;\n\n\t\tthis.combine = source.combine;\n\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MMDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}