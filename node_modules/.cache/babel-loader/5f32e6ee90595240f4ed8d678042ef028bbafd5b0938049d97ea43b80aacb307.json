{"ast":null,"code":"import { CanvasTexture, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, SRGBColorSpace, Color } from 'three';\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.colorSpace = SRGBColorSpace;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n\n    // Create an observer on the DOM, and run html2canvas update in the next loop\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n}\n\n//\n\nconst canvases = new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n        minY = -Infinity;\n      let maxX = Infinity,\n        maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element, style) {\n    let x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, x, y);\n      context.restore();\n    } else if (element instanceof HTMLImageElement) {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      context.drawImage(element, x, y, width, height);\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element);\n\n      // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n\n      // If all the borders match then stroke the round rectangle\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n\n        const width = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext('2d' /*, { alpha: false }*/);\n  const clipper = new Clipper(context);\n\n  // console.time( 'drawElement' );\n\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  drawElement(element);\n\n  // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"names":["CanvasTexture","LinearFilter","Mesh","MeshBasicMaterial","PlaneGeometry","SRGBColorSpace","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","colorSpace","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","Clipper","context","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","HTMLImageElement","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","undefined","set","luminance","sqrt","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","value","property","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","clearRect","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","right","bottom","offsetX","proportion","InputEvent","bubbles"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/interactive/HTMLMesh.js"],"sourcesContent":["import {\n\tCanvasTexture,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tPlaneGeometry,\n\tSRGBColorSpace,\n\tColor\n} from 'three';\n\nclass HTMLMesh extends Mesh {\n\n\tconstructor( dom ) {\n\n\t\tconst texture = new HTMLTexture( dom );\n\n\t\tconst geometry = new PlaneGeometry( texture.image.width * 0.001, texture.image.height * 0.001 );\n\t\tconst material = new MeshBasicMaterial( { map: texture, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tfunction onEvent( event ) {\n\n\t\t\tmaterial.map.dispatchDOMEvent( event );\n\n\t\t}\n\n\t\tthis.addEventListener( 'mousedown', onEvent );\n\t\tthis.addEventListener( 'mousemove', onEvent );\n\t\tthis.addEventListener( 'mouseup', onEvent );\n\t\tthis.addEventListener( 'click', onEvent );\n\n\t\tthis.dispose = function () {\n\n\t\t\tgeometry.dispose();\n\t\t\tmaterial.dispose();\n\n\t\t\tmaterial.map.dispose();\n\n\t\t\tcanvases.delete( dom );\n\n\t\t\tthis.removeEventListener( 'mousedown', onEvent );\n\t\t\tthis.removeEventListener( 'mousemove', onEvent );\n\t\t\tthis.removeEventListener( 'mouseup', onEvent );\n\t\t\tthis.removeEventListener( 'click', onEvent );\n\n\t\t};\n\n\t}\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n\n\tconstructor( dom ) {\n\n\t\tsuper( html2canvas( dom ) );\n\n\t\tthis.dom = dom;\n\n\t\tthis.anisotropy = 16;\n\t\tthis.colorSpace = SRGBColorSpace;\n\t\tthis.minFilter = LinearFilter;\n\t\tthis.magFilter = LinearFilter;\n\n\t\t// Create an observer on the DOM, and run html2canvas update in the next loop\n\t\tconst observer = new MutationObserver( () => {\n\n\t\t\tif ( ! this.scheduleUpdate ) {\n\n\t\t\t\t// ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n\t\t\t\tthis.scheduleUpdate = setTimeout( () => this.update(), 16 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst config = { attributes: true, childList: true, subtree: true, characterData: true };\n\t\tobserver.observe( dom, config );\n\n\t\tthis.observer = observer;\n\n\t}\n\n\tdispatchDOMEvent( event ) {\n\n\t\tif ( event.data ) {\n\n\t\t\thtmlevent( this.dom, event.type, event.data.x, event.data.y );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tthis.image = html2canvas( this.dom );\n\t\tthis.needsUpdate = true;\n\n\t\tthis.scheduleUpdate = null;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.observer ) {\n\n\t\t\tthis.observer.disconnect();\n\n\t\t}\n\n\t\tthis.scheduleUpdate = clearTimeout( this.scheduleUpdate );\n\n\t\tsuper.dispose();\n\n\t}\n\n}\n\n\n//\n\nconst canvases = new WeakMap();\n\nfunction html2canvas( element ) {\n\n\tconst range = document.createRange();\n\tconst color = new Color();\n\n\tfunction Clipper( context ) {\n\n\t\tconst clips = [];\n\t\tlet isClipping = false;\n\n\t\tfunction doClip() {\n\n\t\t\tif ( isClipping ) {\n\n\t\t\t\tisClipping = false;\n\t\t\t\tcontext.restore();\n\n\t\t\t}\n\n\t\t\tif ( clips.length === 0 ) return;\n\n\t\t\tlet minX = - Infinity, minY = - Infinity;\n\t\t\tlet maxX = Infinity, maxY = Infinity;\n\n\t\t\tfor ( let i = 0; i < clips.length; i ++ ) {\n\n\t\t\t\tconst clip = clips[ i ];\n\n\t\t\t\tminX = Math.max( minX, clip.x );\n\t\t\t\tminY = Math.max( minY, clip.y );\n\t\t\t\tmaxX = Math.min( maxX, clip.x + clip.width );\n\t\t\t\tmaxY = Math.min( maxY, clip.y + clip.height );\n\n\t\t\t}\n\n\t\t\tcontext.save();\n\t\t\tcontext.beginPath();\n\t\t\tcontext.rect( minX, minY, maxX - minX, maxY - minY );\n\t\t\tcontext.clip();\n\n\t\t\tisClipping = true;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tadd: function ( clip ) {\n\n\t\t\t\tclips.push( clip );\n\t\t\t\tdoClip();\n\n\t\t\t},\n\n\t\t\tremove: function () {\n\n\t\t\t\tclips.pop();\n\t\t\t\tdoClip();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction drawText( style, x, y, string ) {\n\n\t\tif ( string !== '' ) {\n\n\t\t\tif ( style.textTransform === 'uppercase' ) {\n\n\t\t\t\tstring = string.toUpperCase();\n\n\t\t\t}\n\n\t\t\tcontext.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n\t\t\tcontext.textBaseline = 'top';\n\t\t\tcontext.fillStyle = style.color;\n\t\t\tcontext.fillText( string, x, y + parseFloat( style.fontSize ) * 0.1 );\n\n\t\t}\n\n\t}\n\n\tfunction buildRectPath( x, y, w, h, r ) {\n\n\t\tif ( w < 2 * r ) r = w / 2;\n\t\tif ( h < 2 * r ) r = h / 2;\n\n\t\tcontext.beginPath();\n\t\tcontext.moveTo( x + r, y );\n\t\tcontext.arcTo( x + w, y, x + w, y + h, r );\n\t\tcontext.arcTo( x + w, y + h, x, y + h, r );\n\t\tcontext.arcTo( x, y + h, x, y, r );\n\t\tcontext.arcTo( x, y, x + w, y, r );\n\t\tcontext.closePath();\n\n\t}\n\n\tfunction drawBorder( style, which, x, y, width, height ) {\n\n\t\tconst borderWidth = style[ which + 'Width' ];\n\t\tconst borderStyle = style[ which + 'Style' ];\n\t\tconst borderColor = style[ which + 'Color' ];\n\n\t\tif ( borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\tcontext.strokeStyle = borderColor;\n\t\t\tcontext.lineWidth = parseFloat( borderWidth );\n\t\t\tcontext.beginPath();\n\t\t\tcontext.moveTo( x, y );\n\t\t\tcontext.lineTo( x + width, y + height );\n\t\t\tcontext.stroke();\n\n\t\t}\n\n\t}\n\n\tfunction drawElement( element, style ) {\n\n\t\tlet x = 0, y = 0, width = 0, height = 0;\n\n\t\tif ( element.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t// text\n\n\t\t\trange.selectNode( element );\n\n\t\t\tconst rect = range.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tdrawText( style, x, y, element.nodeValue.trim() );\n\n\t\t} else if ( element.nodeType === Node.COMMENT_NODE ) {\n\n\t\t\treturn;\n\n\t\t} else if ( element instanceof HTMLCanvasElement ) {\n\n\t\t\t// Canvas element\n\t\t\tif ( element.style.display === 'none' ) return;\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\n\t\t        context.save();\n\t\t\tconst dpr = window.devicePixelRatio;\n\t\t\tcontext.scale( 1 / dpr, 1 / dpr );\n\t\t\tcontext.drawImage( element, x, y );\n\t\t\tcontext.restore();\n\n\t\t} else if ( element instanceof HTMLImageElement ) {\n\n\t\t\tif ( element.style.display === 'none' ) return;\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tcontext.drawImage( element, x, y, width, height );\n\n\t\t} else {\n\n\t\t\tif ( element.style.display === 'none' ) return;\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tstyle = window.getComputedStyle( element );\n\n\t\t\t// Get the border of the element used for fill and border\n\n\t\t\tbuildRectPath( x, y, width, height, parseFloat( style.borderRadius ) );\n\n\t\t\tconst backgroundColor = style.backgroundColor;\n\n\t\t\tif ( backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\t\tcontext.fillStyle = backgroundColor;\n\t\t\t\tcontext.fill();\n\n\t\t\t}\n\n\t\t\t// If all the borders match then stroke the round rectangle\n\n\t\t\tconst borders = [ 'borderTop', 'borderLeft', 'borderBottom', 'borderRight' ];\n\n\t\t\tlet match = true;\n\t\t\tlet prevBorder = null;\n\n\t\t\tfor ( const border of borders ) {\n\n\t\t\t\tif ( prevBorder !== null ) {\n\n\t\t\t\t\tmatch = ( style[ border + 'Width' ] === style[ prevBorder + 'Width' ] ) &&\n\t\t\t\t\t( style[ border + 'Color' ] === style[ prevBorder + 'Color' ] ) &&\n\t\t\t\t\t( style[ border + 'Style' ] === style[ prevBorder + 'Style' ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( match === false ) break;\n\n\t\t\t\tprevBorder = border;\n\n\t\t\t}\n\n\t\t\tif ( match === true ) {\n\n\t\t\t\t// They all match so stroke the rectangle from before allows for border-radius\n\n\t\t\t\tconst width = parseFloat( style.borderTopWidth );\n\n\t\t\t\tif ( style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\t\t\tcontext.strokeStyle = style.borderTopColor;\n\t\t\t\t\tcontext.lineWidth = width;\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Otherwise draw individual borders\n\n\t\t\t\tdrawBorder( style, 'borderTop', x, y, width, 0 );\n\t\t\t\tdrawBorder( style, 'borderLeft', x, y, 0, height );\n\t\t\t\tdrawBorder( style, 'borderBottom', x, y + height, width, 0 );\n\t\t\t\tdrawBorder( style, 'borderRight', x + width, y, 0, height );\n\n\t\t\t}\n\n\t\t\tif ( element instanceof HTMLInputElement ) {\n\n\t\t\t\tlet accentColor = style.accentColor;\n\n\t\t\t\tif ( accentColor === undefined || accentColor === 'auto' ) accentColor = style.color;\n\n\t\t\t\tcolor.set( accentColor );\n\n\t\t\t\tconst luminance = Math.sqrt( 0.299 * ( color.r ** 2 ) + 0.587 * ( color.g ** 2 ) + 0.114 * ( color.b ** 2 ) );\n\t\t\t\tconst accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n\t\t\t\tif ( element.type === 'radio' ) {\n\n\t\t\t\t\tbuildRectPath( x, y, width, height, height );\n\n\t\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\t\tcontext.strokeStyle = accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.fill();\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\tif ( element.checked ) {\n\n\t\t\t\t\t\tbuildRectPath( x + 2, y + 2, width - 4, height - 4, height );\n\n\t\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\t\tcontext.strokeStyle = accentTextColor;\n\t\t\t\t\t\tcontext.lineWidth = 2;\n\t\t\t\t\t\tcontext.fill();\n\t\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( element.type === 'checkbox' ) {\n\n\t\t\t\t\tbuildRectPath( x, y, width, height, 2 );\n\n\t\t\t\t\tcontext.fillStyle = element.checked ? accentColor : 'white';\n\t\t\t\t\tcontext.strokeStyle = element.checked ? accentTextColor : accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t\tif ( element.checked ) {\n\n\t\t\t\t\t\tconst currentTextAlign = context.textAlign;\n\n\t\t\t\t\t\tcontext.textAlign = 'center';\n\n\t\t\t\t\t\tconst properties = {\n\t\t\t\t\t\t\tcolor: accentTextColor,\n\t\t\t\t\t\t\tfontFamily: style.fontFamily,\n\t\t\t\t\t\t\tfontSize: height + 'px',\n\t\t\t\t\t\t\tfontWeight: 'bold'\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tdrawText( properties, x + ( width / 2 ), y, '✔' );\n\n\t\t\t\t\t\tcontext.textAlign = currentTextAlign;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( element.type === 'range' ) {\n\n\t\t\t\t\tconst [ min, max, value ] = [ 'min', 'max', 'value' ].map( property => parseFloat( element[ property ] ) );\n\t\t\t\t\tconst position = ( ( value - min ) / ( max - min ) ) * ( width - height );\n\n\t\t\t\t\tbuildRectPath( x, y + ( height / 4 ), width, height / 2, height / 4 );\n\t\t\t\t\tcontext.fillStyle = accentTextColor;\n\t\t\t\t\tcontext.strokeStyle = accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.fill();\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\tbuildRectPath( x, y + ( height / 4 ), position + ( height / 2 ), height / 2, height / 4 );\n\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t\tbuildRectPath( x + position, y, height, height, height / 2 );\n\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t}\n\n\t\t\t\tif ( element.type === 'color' || element.type === 'text' || element.type === 'number' ) {\n\n\t\t\t\t\tclipper.add( { x: x, y: y, width: width, height: height } );\n\n\t\t\t\t\tdrawText( style, x + parseInt( style.paddingLeft ), y + parseInt( style.paddingTop ), element.value );\n\n\t\t\t\t\tclipper.remove();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t// debug\n\t\tcontext.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n\t\tcontext.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n\t\t*/\n\n\t\tconst isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n\n\t\tif ( isClipping ) clipper.add( { x: x, y: y, width: width, height: height } );\n\n\t\tfor ( let i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tdrawElement( element.childNodes[ i ], style );\n\n\t\t}\n\n\t\tif ( isClipping ) clipper.remove();\n\n\t}\n\n\tconst offset = element.getBoundingClientRect();\n\n\tlet canvas = canvases.get( element );\n\n\tif ( canvas === undefined ) {\n\n\t\tcanvas = document.createElement( 'canvas' );\n\t\tcanvas.width = offset.width;\n\t\tcanvas.height = offset.height;\n\t\tcanvases.set( element, canvas );\n\n\t}\n\n\tconst context = canvas.getContext( '2d'/*, { alpha: false }*/ );\n\n\tconst clipper = new Clipper( context );\n\n\t// console.time( 'drawElement' );\n\n\tcontext.clearRect( 0, 0, canvas.width, canvas.height );\n\n\tdrawElement( element );\n\n\t// console.timeEnd( 'drawElement' );\n\n\treturn canvas;\n\n}\n\nfunction htmlevent( element, event, x, y ) {\n\n\tconst mouseEventInit = {\n\t\tclientX: ( x * element.offsetWidth ) + element.offsetLeft,\n\t\tclientY: ( y * element.offsetHeight ) + element.offsetTop,\n\t\tview: element.ownerDocument.defaultView\n\t};\n\n\twindow.dispatchEvent( new MouseEvent( event, mouseEventInit ) );\n\n\tconst rect = element.getBoundingClientRect();\n\n\tx = x * rect.width + rect.left;\n\ty = y * rect.height + rect.top;\n\n\tfunction traverse( element ) {\n\n\t\tif ( element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE ) {\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tif ( x > rect.left && x < rect.right && y > rect.top && y < rect.bottom ) {\n\n\t\t\t\telement.dispatchEvent( new MouseEvent( event, mouseEventInit ) );\n\n\t\t\t\tif ( element instanceof HTMLInputElement && element.type === 'range' && ( event === 'mousedown' || event === 'click' ) ) {\n\n\t\t\t\t\tconst [ min, max ] = [ 'min', 'max' ].map( property => parseFloat( element[ property ] ) );\n\n\t\t\t\t\tconst width = rect.width;\n\t\t\t\t\tconst offsetX = x - rect.x;\n\t\t\t\t\tconst proportion = offsetX / width;\n\t\t\t\t\telement.value = min + ( max - min ) * proportion;\n\t\t\t\t\telement.dispatchEvent( new InputEvent( 'input', { bubbles: true } ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\t\ttraverse( element.childNodes[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( element );\n\n}\n\nexport { HTMLMesh };\n"],"mappings":"AAAA,SACCA,aAAa,EACbC,YAAY,EACZC,IAAI,EACJC,iBAAiB,EACjBC,aAAa,EACbC,cAAc,EACdC,KAAK,QACC,OAAO;AAEd,MAAMC,QAAQ,SAASL,IAAI,CAAC;EAE3BM,WAAWA,CAAEC,GAAG,EAAG;IAElB,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAEF,GAAI,CAAC;IAEtC,MAAMG,QAAQ,GAAG,IAAIR,aAAa,CAAEM,OAAO,CAACG,KAAK,CAACC,KAAK,GAAG,KAAK,EAAEJ,OAAO,CAACG,KAAK,CAACE,MAAM,GAAG,KAAM,CAAC;IAC/F,MAAMC,QAAQ,GAAG,IAAIb,iBAAiB,CAAE;MAAEc,GAAG,EAAEP,OAAO;MAAEQ,UAAU,EAAE,KAAK;MAAEC,WAAW,EAAE;IAAK,CAAE,CAAC;IAEhG,KAAK,CAAEP,QAAQ,EAAEI,QAAS,CAAC;IAE3B,SAASI,OAAOA,CAAEC,KAAK,EAAG;MAEzBL,QAAQ,CAACC,GAAG,CAACK,gBAAgB,CAAED,KAAM,CAAC;IAEvC;IAEA,IAAI,CAACE,gBAAgB,CAAE,WAAW,EAAEH,OAAQ,CAAC;IAC7C,IAAI,CAACG,gBAAgB,CAAE,WAAW,EAAEH,OAAQ,CAAC;IAC7C,IAAI,CAACG,gBAAgB,CAAE,SAAS,EAAEH,OAAQ,CAAC;IAC3C,IAAI,CAACG,gBAAgB,CAAE,OAAO,EAAEH,OAAQ,CAAC;IAEzC,IAAI,CAACI,OAAO,GAAG,YAAY;MAE1BZ,QAAQ,CAACY,OAAO,CAAC,CAAC;MAClBR,QAAQ,CAACQ,OAAO,CAAC,CAAC;MAElBR,QAAQ,CAACC,GAAG,CAACO,OAAO,CAAC,CAAC;MAEtBC,QAAQ,CAACC,MAAM,CAAEjB,GAAI,CAAC;MAEtB,IAAI,CAACkB,mBAAmB,CAAE,WAAW,EAAEP,OAAQ,CAAC;MAChD,IAAI,CAACO,mBAAmB,CAAE,WAAW,EAAEP,OAAQ,CAAC;MAChD,IAAI,CAACO,mBAAmB,CAAE,SAAS,EAAEP,OAAQ,CAAC;MAC9C,IAAI,CAACO,mBAAmB,CAAE,OAAO,EAAEP,OAAQ,CAAC;IAE7C,CAAC;EAEF;AAED;AAEA,MAAMT,WAAW,SAASX,aAAa,CAAC;EAEvCQ,WAAWA,CAAEC,GAAG,EAAG;IAElB,KAAK,CAAEmB,WAAW,CAAEnB,GAAI,CAAE,CAAC;IAE3B,IAAI,CAACA,GAAG,GAAGA,GAAG;IAEd,IAAI,CAACoB,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,UAAU,GAAGzB,cAAc;IAChC,IAAI,CAAC0B,SAAS,GAAG9B,YAAY;IAC7B,IAAI,CAAC+B,SAAS,GAAG/B,YAAY;;IAE7B;IACA,MAAMgC,QAAQ,GAAG,IAAIC,gBAAgB,CAAE,MAAM;MAE5C,IAAK,CAAE,IAAI,CAACC,cAAc,EAAG;QAE5B;QACA,IAAI,CAACA,cAAc,GAAGC,UAAU,CAAE,MAAM,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE,EAAG,CAAC;MAE5D;IAED,CAAE,CAAC;IAEH,MAAMC,MAAM,GAAG;MAAEC,UAAU,EAAE,IAAI;MAAEC,SAAS,EAAE,IAAI;MAAEC,OAAO,EAAE,IAAI;MAAEC,aAAa,EAAE;IAAK,CAAC;IACxFT,QAAQ,CAACU,OAAO,CAAElC,GAAG,EAAE6B,MAAO,CAAC;IAE/B,IAAI,CAACL,QAAQ,GAAGA,QAAQ;EAEzB;EAEAX,gBAAgBA,CAAED,KAAK,EAAG;IAEzB,IAAKA,KAAK,CAACuB,IAAI,EAAG;MAEjBC,SAAS,CAAE,IAAI,CAACpC,GAAG,EAAEY,KAAK,CAACyB,IAAI,EAAEzB,KAAK,CAACuB,IAAI,CAACG,CAAC,EAAE1B,KAAK,CAACuB,IAAI,CAACI,CAAE,CAAC;IAE9D;EAED;EAEAX,MAAMA,CAAA,EAAG;IAER,IAAI,CAACxB,KAAK,GAAGe,WAAW,CAAE,IAAI,CAACnB,GAAI,CAAC;IACpC,IAAI,CAACwC,WAAW,GAAG,IAAI;IAEvB,IAAI,CAACd,cAAc,GAAG,IAAI;EAE3B;EAEAX,OAAOA,CAAA,EAAG;IAET,IAAK,IAAI,CAACS,QAAQ,EAAG;MAEpB,IAAI,CAACA,QAAQ,CAACiB,UAAU,CAAC,CAAC;IAE3B;IAEA,IAAI,CAACf,cAAc,GAAGgB,YAAY,CAAE,IAAI,CAAChB,cAAe,CAAC;IAEzD,KAAK,CAACX,OAAO,CAAC,CAAC;EAEhB;AAED;;AAGA;;AAEA,MAAMC,QAAQ,GAAG,IAAI2B,OAAO,CAAC,CAAC;AAE9B,SAASxB,WAAWA,CAAEyB,OAAO,EAAG;EAE/B,MAAMC,KAAK,GAAGC,QAAQ,CAACC,WAAW,CAAC,CAAC;EACpC,MAAMC,KAAK,GAAG,IAAInD,KAAK,CAAC,CAAC;EAEzB,SAASoD,OAAOA,CAAEC,OAAO,EAAG;IAE3B,MAAMC,KAAK,GAAG,EAAE;IAChB,IAAIC,UAAU,GAAG,KAAK;IAEtB,SAASC,MAAMA,CAAA,EAAG;MAEjB,IAAKD,UAAU,EAAG;QAEjBA,UAAU,GAAG,KAAK;QAClBF,OAAO,CAACI,OAAO,CAAC,CAAC;MAElB;MAEA,IAAKH,KAAK,CAACI,MAAM,KAAK,CAAC,EAAG;MAE1B,IAAIC,IAAI,GAAG,CAAEC,QAAQ;QAAEC,IAAI,GAAG,CAAED,QAAQ;MACxC,IAAIE,IAAI,GAAGF,QAAQ;QAAEG,IAAI,GAAGH,QAAQ;MAEpC,KAAM,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,KAAK,CAACI,MAAM,EAAEM,CAAC,EAAG,EAAG;QAEzC,MAAMC,IAAI,GAAGX,KAAK,CAAEU,CAAC,CAAE;QAEvBL,IAAI,GAAGO,IAAI,CAACC,GAAG,CAAER,IAAI,EAAEM,IAAI,CAACxB,CAAE,CAAC;QAC/BoB,IAAI,GAAGK,IAAI,CAACC,GAAG,CAAEN,IAAI,EAAEI,IAAI,CAACvB,CAAE,CAAC;QAC/BoB,IAAI,GAAGI,IAAI,CAACE,GAAG,CAAEN,IAAI,EAAEG,IAAI,CAACxB,CAAC,GAAGwB,IAAI,CAACzD,KAAM,CAAC;QAC5CuD,IAAI,GAAGG,IAAI,CAACE,GAAG,CAAEL,IAAI,EAAEE,IAAI,CAACvB,CAAC,GAAGuB,IAAI,CAACxD,MAAO,CAAC;MAE9C;MAEA4C,OAAO,CAACgB,IAAI,CAAC,CAAC;MACdhB,OAAO,CAACiB,SAAS,CAAC,CAAC;MACnBjB,OAAO,CAACkB,IAAI,CAAEZ,IAAI,EAAEE,IAAI,EAAEC,IAAI,GAAGH,IAAI,EAAEI,IAAI,GAAGF,IAAK,CAAC;MACpDR,OAAO,CAACY,IAAI,CAAC,CAAC;MAEdV,UAAU,GAAG,IAAI;IAElB;IAEA,OAAO;MAENiB,GAAG,EAAE,SAAAA,CAAWP,IAAI,EAAG;QAEtBX,KAAK,CAACmB,IAAI,CAAER,IAAK,CAAC;QAClBT,MAAM,CAAC,CAAC;MAET,CAAC;MAEDkB,MAAM,EAAE,SAAAA,CAAA,EAAY;QAEnBpB,KAAK,CAACqB,GAAG,CAAC,CAAC;QACXnB,MAAM,CAAC,CAAC;MAET;IAED,CAAC;EAEF;EAEA,SAASoB,QAAQA,CAAEC,KAAK,EAAEpC,CAAC,EAAEC,CAAC,EAAEoC,MAAM,EAAG;IAExC,IAAKA,MAAM,KAAK,EAAE,EAAG;MAEpB,IAAKD,KAAK,CAACE,aAAa,KAAK,WAAW,EAAG;QAE1CD,MAAM,GAAGA,MAAM,CAACE,WAAW,CAAC,CAAC;MAE9B;MAEA3B,OAAO,CAAC4B,IAAI,GAAGJ,KAAK,CAACK,UAAU,GAAG,GAAG,GAAGL,KAAK,CAACM,QAAQ,GAAG,GAAG,GAAGN,KAAK,CAACO,UAAU;MAC/E/B,OAAO,CAACgC,YAAY,GAAG,KAAK;MAC5BhC,OAAO,CAACiC,SAAS,GAAGT,KAAK,CAAC1B,KAAK;MAC/BE,OAAO,CAACkC,QAAQ,CAAET,MAAM,EAAErC,CAAC,EAAEC,CAAC,GAAG8C,UAAU,CAAEX,KAAK,CAACM,QAAS,CAAC,GAAG,GAAI,CAAC;IAEtE;EAED;EAEA,SAASM,aAAaA,CAAEhD,CAAC,EAAEC,CAAC,EAAEgD,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAG;IAEvC,IAAKF,CAAC,GAAG,CAAC,GAAGE,CAAC,EAAGA,CAAC,GAAGF,CAAC,GAAG,CAAC;IAC1B,IAAKC,CAAC,GAAG,CAAC,GAAGC,CAAC,EAAGA,CAAC,GAAGD,CAAC,GAAG,CAAC;IAE1BtC,OAAO,CAACiB,SAAS,CAAC,CAAC;IACnBjB,OAAO,CAACwC,MAAM,CAAEpD,CAAC,GAAGmD,CAAC,EAAElD,CAAE,CAAC;IAC1BW,OAAO,CAACyC,KAAK,CAAErD,CAAC,GAAGiD,CAAC,EAAEhD,CAAC,EAAED,CAAC,GAAGiD,CAAC,EAAEhD,CAAC,GAAGiD,CAAC,EAAEC,CAAE,CAAC;IAC1CvC,OAAO,CAACyC,KAAK,CAAErD,CAAC,GAAGiD,CAAC,EAAEhD,CAAC,GAAGiD,CAAC,EAAElD,CAAC,EAAEC,CAAC,GAAGiD,CAAC,EAAEC,CAAE,CAAC;IAC1CvC,OAAO,CAACyC,KAAK,CAAErD,CAAC,EAAEC,CAAC,GAAGiD,CAAC,EAAElD,CAAC,EAAEC,CAAC,EAAEkD,CAAE,CAAC;IAClCvC,OAAO,CAACyC,KAAK,CAAErD,CAAC,EAAEC,CAAC,EAAED,CAAC,GAAGiD,CAAC,EAAEhD,CAAC,EAAEkD,CAAE,CAAC;IAClCvC,OAAO,CAAC0C,SAAS,CAAC,CAAC;EAEpB;EAEA,SAASC,UAAUA,CAAEnB,KAAK,EAAEoB,KAAK,EAAExD,CAAC,EAAEC,CAAC,EAAElC,KAAK,EAAEC,MAAM,EAAG;IAExD,MAAMyF,WAAW,GAAGrB,KAAK,CAAEoB,KAAK,GAAG,OAAO,CAAE;IAC5C,MAAME,WAAW,GAAGtB,KAAK,CAAEoB,KAAK,GAAG,OAAO,CAAE;IAC5C,MAAMG,WAAW,GAAGvB,KAAK,CAAEoB,KAAK,GAAG,OAAO,CAAE;IAE5C,IAAKC,WAAW,KAAK,KAAK,IAAIC,WAAW,KAAK,MAAM,IAAIC,WAAW,KAAK,aAAa,IAAIA,WAAW,KAAK,kBAAkB,EAAG;MAE7H/C,OAAO,CAACgD,WAAW,GAAGD,WAAW;MACjC/C,OAAO,CAACiD,SAAS,GAAGd,UAAU,CAAEU,WAAY,CAAC;MAC7C7C,OAAO,CAACiB,SAAS,CAAC,CAAC;MACnBjB,OAAO,CAACwC,MAAM,CAAEpD,CAAC,EAAEC,CAAE,CAAC;MACtBW,OAAO,CAACkD,MAAM,CAAE9D,CAAC,GAAGjC,KAAK,EAAEkC,CAAC,GAAGjC,MAAO,CAAC;MACvC4C,OAAO,CAACmD,MAAM,CAAC,CAAC;IAEjB;EAED;EAEA,SAASC,WAAWA,CAAE1D,OAAO,EAAE8B,KAAK,EAAG;IAEtC,IAAIpC,CAAC,GAAG,CAAC;MAAEC,CAAC,GAAG,CAAC;MAAElC,KAAK,GAAG,CAAC;MAAEC,MAAM,GAAG,CAAC;IAEvC,IAAKsC,OAAO,CAAC2D,QAAQ,KAAKC,IAAI,CAACC,SAAS,EAAG;MAE1C;;MAEA5D,KAAK,CAAC6D,UAAU,CAAE9D,OAAQ,CAAC;MAE3B,MAAMwB,IAAI,GAAGvB,KAAK,CAAC8D,qBAAqB,CAAC,CAAC;MAE1CrE,CAAC,GAAG8B,IAAI,CAACwC,IAAI,GAAGC,MAAM,CAACD,IAAI,GAAG,GAAG;MACjCrE,CAAC,GAAG6B,IAAI,CAAC0C,GAAG,GAAGD,MAAM,CAACC,GAAG,GAAG,GAAG;MAC/BzG,KAAK,GAAG+D,IAAI,CAAC/D,KAAK;MAClBC,MAAM,GAAG8D,IAAI,CAAC9D,MAAM;MAEpBmE,QAAQ,CAAEC,KAAK,EAAEpC,CAAC,EAAEC,CAAC,EAAEK,OAAO,CAACmE,SAAS,CAACC,IAAI,CAAC,CAAE,CAAC;IAElD,CAAC,MAAM,IAAKpE,OAAO,CAAC2D,QAAQ,KAAKC,IAAI,CAACS,YAAY,EAAG;MAEpD;IAED,CAAC,MAAM,IAAKrE,OAAO,YAAYsE,iBAAiB,EAAG;MAElD;MACA,IAAKtE,OAAO,CAAC8B,KAAK,CAACyC,OAAO,KAAK,MAAM,EAAG;MAExC,MAAM/C,IAAI,GAAGxB,OAAO,CAAC+D,qBAAqB,CAAC,CAAC;MAE5CrE,CAAC,GAAG8B,IAAI,CAACwC,IAAI,GAAGC,MAAM,CAACD,IAAI,GAAG,GAAG;MACjCrE,CAAC,GAAG6B,IAAI,CAAC0C,GAAG,GAAGD,MAAM,CAACC,GAAG,GAAG,GAAG;MAExB5D,OAAO,CAACgB,IAAI,CAAC,CAAC;MACrB,MAAMkD,GAAG,GAAGC,MAAM,CAACC,gBAAgB;MACnCpE,OAAO,CAACqE,KAAK,CAAE,CAAC,GAAGH,GAAG,EAAE,CAAC,GAAGA,GAAI,CAAC;MACjClE,OAAO,CAACsE,SAAS,CAAE5E,OAAO,EAAEN,CAAC,EAAEC,CAAE,CAAC;MAClCW,OAAO,CAACI,OAAO,CAAC,CAAC;IAElB,CAAC,MAAM,IAAKV,OAAO,YAAY6E,gBAAgB,EAAG;MAEjD,IAAK7E,OAAO,CAAC8B,KAAK,CAACyC,OAAO,KAAK,MAAM,EAAG;MAExC,MAAM/C,IAAI,GAAGxB,OAAO,CAAC+D,qBAAqB,CAAC,CAAC;MAE5CrE,CAAC,GAAG8B,IAAI,CAACwC,IAAI,GAAGC,MAAM,CAACD,IAAI,GAAG,GAAG;MACjCrE,CAAC,GAAG6B,IAAI,CAAC0C,GAAG,GAAGD,MAAM,CAACC,GAAG,GAAG,GAAG;MAC/BzG,KAAK,GAAG+D,IAAI,CAAC/D,KAAK;MAClBC,MAAM,GAAG8D,IAAI,CAAC9D,MAAM;MAEpB4C,OAAO,CAACsE,SAAS,CAAE5E,OAAO,EAAEN,CAAC,EAAEC,CAAC,EAAElC,KAAK,EAAEC,MAAO,CAAC;IAElD,CAAC,MAAM;MAEN,IAAKsC,OAAO,CAAC8B,KAAK,CAACyC,OAAO,KAAK,MAAM,EAAG;MAExC,MAAM/C,IAAI,GAAGxB,OAAO,CAAC+D,qBAAqB,CAAC,CAAC;MAE5CrE,CAAC,GAAG8B,IAAI,CAACwC,IAAI,GAAGC,MAAM,CAACD,IAAI,GAAG,GAAG;MACjCrE,CAAC,GAAG6B,IAAI,CAAC0C,GAAG,GAAGD,MAAM,CAACC,GAAG,GAAG,GAAG;MAC/BzG,KAAK,GAAG+D,IAAI,CAAC/D,KAAK;MAClBC,MAAM,GAAG8D,IAAI,CAAC9D,MAAM;MAEpBoE,KAAK,GAAG2C,MAAM,CAACK,gBAAgB,CAAE9E,OAAQ,CAAC;;MAE1C;;MAEA0C,aAAa,CAAEhD,CAAC,EAAEC,CAAC,EAAElC,KAAK,EAAEC,MAAM,EAAE+E,UAAU,CAAEX,KAAK,CAACiD,YAAa,CAAE,CAAC;MAEtE,MAAMC,eAAe,GAAGlD,KAAK,CAACkD,eAAe;MAE7C,IAAKA,eAAe,KAAK,aAAa,IAAIA,eAAe,KAAK,kBAAkB,EAAG;QAElF1E,OAAO,CAACiC,SAAS,GAAGyC,eAAe;QACnC1E,OAAO,CAAC2E,IAAI,CAAC,CAAC;MAEf;;MAEA;;MAEA,MAAMC,OAAO,GAAG,CAAE,WAAW,EAAE,YAAY,EAAE,cAAc,EAAE,aAAa,CAAE;MAE5E,IAAIC,KAAK,GAAG,IAAI;MAChB,IAAIC,UAAU,GAAG,IAAI;MAErB,KAAM,MAAMC,MAAM,IAAIH,OAAO,EAAG;QAE/B,IAAKE,UAAU,KAAK,IAAI,EAAG;UAE1BD,KAAK,GAAKrD,KAAK,CAAEuD,MAAM,GAAG,OAAO,CAAE,KAAKvD,KAAK,CAAEsD,UAAU,GAAG,OAAO,CAAE,IACnEtD,KAAK,CAAEuD,MAAM,GAAG,OAAO,CAAE,KAAKvD,KAAK,CAAEsD,UAAU,GAAG,OAAO,CAAI,IAC7DtD,KAAK,CAAEuD,MAAM,GAAG,OAAO,CAAE,KAAKvD,KAAK,CAAEsD,UAAU,GAAG,OAAO,CAAI;QAEhE;QAEA,IAAKD,KAAK,KAAK,KAAK,EAAG;QAEvBC,UAAU,GAAGC,MAAM;MAEpB;MAEA,IAAKF,KAAK,KAAK,IAAI,EAAG;QAErB;;QAEA,MAAM1H,KAAK,GAAGgF,UAAU,CAAEX,KAAK,CAACwD,cAAe,CAAC;QAEhD,IAAKxD,KAAK,CAACwD,cAAc,KAAK,KAAK,IAAIxD,KAAK,CAACyD,cAAc,KAAK,MAAM,IAAIzD,KAAK,CAAC0D,cAAc,KAAK,aAAa,IAAI1D,KAAK,CAAC0D,cAAc,KAAK,kBAAkB,EAAG;UAEjKlF,OAAO,CAACgD,WAAW,GAAGxB,KAAK,CAAC0D,cAAc;UAC1ClF,OAAO,CAACiD,SAAS,GAAG9F,KAAK;UACzB6C,OAAO,CAACmD,MAAM,CAAC,CAAC;QAEjB;MAED,CAAC,MAAM;QAEN;;QAEAR,UAAU,CAAEnB,KAAK,EAAE,WAAW,EAAEpC,CAAC,EAAEC,CAAC,EAAElC,KAAK,EAAE,CAAE,CAAC;QAChDwF,UAAU,CAAEnB,KAAK,EAAE,YAAY,EAAEpC,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAEjC,MAAO,CAAC;QAClDuF,UAAU,CAAEnB,KAAK,EAAE,cAAc,EAAEpC,CAAC,EAAEC,CAAC,GAAGjC,MAAM,EAAED,KAAK,EAAE,CAAE,CAAC;QAC5DwF,UAAU,CAAEnB,KAAK,EAAE,aAAa,EAAEpC,CAAC,GAAGjC,KAAK,EAAEkC,CAAC,EAAE,CAAC,EAAEjC,MAAO,CAAC;MAE5D;MAEA,IAAKsC,OAAO,YAAYyF,gBAAgB,EAAG;QAE1C,IAAIC,WAAW,GAAG5D,KAAK,CAAC4D,WAAW;QAEnC,IAAKA,WAAW,KAAKC,SAAS,IAAID,WAAW,KAAK,MAAM,EAAGA,WAAW,GAAG5D,KAAK,CAAC1B,KAAK;QAEpFA,KAAK,CAACwF,GAAG,CAAEF,WAAY,CAAC;QAExB,MAAMG,SAAS,GAAG1E,IAAI,CAAC2E,IAAI,CAAE,KAAK,GAAK1F,KAAK,CAACyC,CAAC,IAAI,CAAG,GAAG,KAAK,GAAKzC,KAAK,CAAC2F,CAAC,IAAI,CAAG,GAAG,KAAK,GAAK3F,KAAK,CAAC4F,CAAC,IAAI,CAAI,CAAC;QAC7G,MAAMC,eAAe,GAAGJ,SAAS,GAAG,GAAG,GAAG,OAAO,GAAG,SAAS;QAE7D,IAAK7F,OAAO,CAACP,IAAI,KAAK,OAAO,EAAG;UAE/BiD,aAAa,CAAEhD,CAAC,EAAEC,CAAC,EAAElC,KAAK,EAAEC,MAAM,EAAEA,MAAO,CAAC;UAE5C4C,OAAO,CAACiC,SAAS,GAAG,OAAO;UAC3BjC,OAAO,CAACgD,WAAW,GAAGoC,WAAW;UACjCpF,OAAO,CAACiD,SAAS,GAAG,CAAC;UACrBjD,OAAO,CAAC2E,IAAI,CAAC,CAAC;UACd3E,OAAO,CAACmD,MAAM,CAAC,CAAC;UAEhB,IAAKzD,OAAO,CAACkG,OAAO,EAAG;YAEtBxD,aAAa,CAAEhD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAElC,KAAK,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAO,CAAC;YAE5D4C,OAAO,CAACiC,SAAS,GAAGmD,WAAW;YAC/BpF,OAAO,CAACgD,WAAW,GAAG2C,eAAe;YACrC3F,OAAO,CAACiD,SAAS,GAAG,CAAC;YACrBjD,OAAO,CAAC2E,IAAI,CAAC,CAAC;YACd3E,OAAO,CAACmD,MAAM,CAAC,CAAC;UAEjB;QAED;QAEA,IAAKzD,OAAO,CAACP,IAAI,KAAK,UAAU,EAAG;UAElCiD,aAAa,CAAEhD,CAAC,EAAEC,CAAC,EAAElC,KAAK,EAAEC,MAAM,EAAE,CAAE,CAAC;UAEvC4C,OAAO,CAACiC,SAAS,GAAGvC,OAAO,CAACkG,OAAO,GAAGR,WAAW,GAAG,OAAO;UAC3DpF,OAAO,CAACgD,WAAW,GAAGtD,OAAO,CAACkG,OAAO,GAAGD,eAAe,GAAGP,WAAW;UACrEpF,OAAO,CAACiD,SAAS,GAAG,CAAC;UACrBjD,OAAO,CAACmD,MAAM,CAAC,CAAC;UAChBnD,OAAO,CAAC2E,IAAI,CAAC,CAAC;UAEd,IAAKjF,OAAO,CAACkG,OAAO,EAAG;YAEtB,MAAMC,gBAAgB,GAAG7F,OAAO,CAAC8F,SAAS;YAE1C9F,OAAO,CAAC8F,SAAS,GAAG,QAAQ;YAE5B,MAAMC,UAAU,GAAG;cAClBjG,KAAK,EAAE6F,eAAe;cACtB5D,UAAU,EAAEP,KAAK,CAACO,UAAU;cAC5BD,QAAQ,EAAE1E,MAAM,GAAG,IAAI;cACvByE,UAAU,EAAE;YACb,CAAC;YAEDN,QAAQ,CAAEwE,UAAU,EAAE3G,CAAC,GAAKjC,KAAK,GAAG,CAAG,EAAEkC,CAAC,EAAE,GAAI,CAAC;YAEjDW,OAAO,CAAC8F,SAAS,GAAGD,gBAAgB;UAErC;QAED;QAEA,IAAKnG,OAAO,CAACP,IAAI,KAAK,OAAO,EAAG;UAE/B,MAAM,CAAE4B,GAAG,EAAED,GAAG,EAAEkF,KAAK,CAAE,GAAG,CAAE,KAAK,EAAE,KAAK,EAAE,OAAO,CAAE,CAAC1I,GAAG,CAAE2I,QAAQ,IAAI9D,UAAU,CAAEzC,OAAO,CAAEuG,QAAQ,CAAG,CAAE,CAAC;UAC1G,MAAMC,QAAQ,GAAK,CAAEF,KAAK,GAAGjF,GAAG,KAAOD,GAAG,GAAGC,GAAG,CAAE,IAAO5D,KAAK,GAAGC,MAAM,CAAE;UAEzEgF,aAAa,CAAEhD,CAAC,EAAEC,CAAC,GAAKjC,MAAM,GAAG,CAAG,EAAED,KAAK,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAG,CAAE,CAAC;UACrE4C,OAAO,CAACiC,SAAS,GAAG0D,eAAe;UACnC3F,OAAO,CAACgD,WAAW,GAAGoC,WAAW;UACjCpF,OAAO,CAACiD,SAAS,GAAG,CAAC;UACrBjD,OAAO,CAAC2E,IAAI,CAAC,CAAC;UACd3E,OAAO,CAACmD,MAAM,CAAC,CAAC;UAEhBf,aAAa,CAAEhD,CAAC,EAAEC,CAAC,GAAKjC,MAAM,GAAG,CAAG,EAAE8I,QAAQ,GAAK9I,MAAM,GAAG,CAAG,EAAEA,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAG,CAAE,CAAC;UACzF4C,OAAO,CAACiC,SAAS,GAAGmD,WAAW;UAC/BpF,OAAO,CAAC2E,IAAI,CAAC,CAAC;UAEdvC,aAAa,CAAEhD,CAAC,GAAG8G,QAAQ,EAAE7G,CAAC,EAAEjC,MAAM,EAAEA,MAAM,EAAEA,MAAM,GAAG,CAAE,CAAC;UAC5D4C,OAAO,CAACiC,SAAS,GAAGmD,WAAW;UAC/BpF,OAAO,CAAC2E,IAAI,CAAC,CAAC;QAEf;QAEA,IAAKjF,OAAO,CAACP,IAAI,KAAK,OAAO,IAAIO,OAAO,CAACP,IAAI,KAAK,MAAM,IAAIO,OAAO,CAACP,IAAI,KAAK,QAAQ,EAAG;UAEvFgH,OAAO,CAAChF,GAAG,CAAE;YAAE/B,CAAC,EAAEA,CAAC;YAAEC,CAAC,EAAEA,CAAC;YAAElC,KAAK,EAAEA,KAAK;YAAEC,MAAM,EAAEA;UAAO,CAAE,CAAC;UAE3DmE,QAAQ,CAAEC,KAAK,EAAEpC,CAAC,GAAGgH,QAAQ,CAAE5E,KAAK,CAAC6E,WAAY,CAAC,EAAEhH,CAAC,GAAG+G,QAAQ,CAAE5E,KAAK,CAAC8E,UAAW,CAAC,EAAE5G,OAAO,CAACsG,KAAM,CAAC;UAErGG,OAAO,CAAC9E,MAAM,CAAC,CAAC;QAEjB;MAED;IAED;;IAEA;AACF;AACA;AACA;AACA;;IAEE,MAAMnB,UAAU,GAAGsB,KAAK,CAAC+E,QAAQ,KAAK,MAAM,IAAI/E,KAAK,CAAC+E,QAAQ,KAAK,QAAQ;IAE3E,IAAKrG,UAAU,EAAGiG,OAAO,CAAChF,GAAG,CAAE;MAAE/B,CAAC,EAAEA,CAAC;MAAEC,CAAC,EAAEA,CAAC;MAAElC,KAAK,EAAEA,KAAK;MAAEC,MAAM,EAAEA;IAAO,CAAE,CAAC;IAE7E,KAAM,IAAIuD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,OAAO,CAAC8G,UAAU,CAACnG,MAAM,EAAEM,CAAC,EAAG,EAAG;MAEtDyC,WAAW,CAAE1D,OAAO,CAAC8G,UAAU,CAAE7F,CAAC,CAAE,EAAEa,KAAM,CAAC;IAE9C;IAEA,IAAKtB,UAAU,EAAGiG,OAAO,CAAC9E,MAAM,CAAC,CAAC;EAEnC;EAEA,MAAMsC,MAAM,GAAGjE,OAAO,CAAC+D,qBAAqB,CAAC,CAAC;EAE9C,IAAIgD,MAAM,GAAG3I,QAAQ,CAAC4I,GAAG,CAAEhH,OAAQ,CAAC;EAEpC,IAAK+G,MAAM,KAAKpB,SAAS,EAAG;IAE3BoB,MAAM,GAAG7G,QAAQ,CAAC+G,aAAa,CAAE,QAAS,CAAC;IAC3CF,MAAM,CAACtJ,KAAK,GAAGwG,MAAM,CAACxG,KAAK;IAC3BsJ,MAAM,CAACrJ,MAAM,GAAGuG,MAAM,CAACvG,MAAM;IAC7BU,QAAQ,CAACwH,GAAG,CAAE5F,OAAO,EAAE+G,MAAO,CAAC;EAEhC;EAEA,MAAMzG,OAAO,GAAGyG,MAAM,CAACG,UAAU,CAAE,IAAI,uBAAuB,CAAC;EAE/D,MAAMT,OAAO,GAAG,IAAIpG,OAAO,CAAEC,OAAQ,CAAC;;EAEtC;;EAEAA,OAAO,CAAC6G,SAAS,CAAE,CAAC,EAAE,CAAC,EAAEJ,MAAM,CAACtJ,KAAK,EAAEsJ,MAAM,CAACrJ,MAAO,CAAC;EAEtDgG,WAAW,CAAE1D,OAAQ,CAAC;;EAEtB;;EAEA,OAAO+G,MAAM;AAEd;AAEA,SAASvH,SAASA,CAAEQ,OAAO,EAAEhC,KAAK,EAAE0B,CAAC,EAAEC,CAAC,EAAG;EAE1C,MAAMyH,cAAc,GAAG;IACtBC,OAAO,EAAI3H,CAAC,GAAGM,OAAO,CAACsH,WAAW,GAAKtH,OAAO,CAACuH,UAAU;IACzDC,OAAO,EAAI7H,CAAC,GAAGK,OAAO,CAACyH,YAAY,GAAKzH,OAAO,CAAC0H,SAAS;IACzDC,IAAI,EAAE3H,OAAO,CAAC4H,aAAa,CAACC;EAC7B,CAAC;EAEDpD,MAAM,CAACqD,aAAa,CAAE,IAAIC,UAAU,CAAE/J,KAAK,EAAEoJ,cAAe,CAAE,CAAC;EAE/D,MAAM5F,IAAI,GAAGxB,OAAO,CAAC+D,qBAAqB,CAAC,CAAC;EAE5CrE,CAAC,GAAGA,CAAC,GAAG8B,IAAI,CAAC/D,KAAK,GAAG+D,IAAI,CAACwC,IAAI;EAC9BrE,CAAC,GAAGA,CAAC,GAAG6B,IAAI,CAAC9D,MAAM,GAAG8D,IAAI,CAAC0C,GAAG;EAE9B,SAAS8D,QAAQA,CAAEhI,OAAO,EAAG;IAE5B,IAAKA,OAAO,CAAC2D,QAAQ,KAAKC,IAAI,CAACC,SAAS,IAAI7D,OAAO,CAAC2D,QAAQ,KAAKC,IAAI,CAACS,YAAY,EAAG;MAEpF,MAAM7C,IAAI,GAAGxB,OAAO,CAAC+D,qBAAqB,CAAC,CAAC;MAE5C,IAAKrE,CAAC,GAAG8B,IAAI,CAACwC,IAAI,IAAItE,CAAC,GAAG8B,IAAI,CAACyG,KAAK,IAAItI,CAAC,GAAG6B,IAAI,CAAC0C,GAAG,IAAIvE,CAAC,GAAG6B,IAAI,CAAC0G,MAAM,EAAG;QAEzElI,OAAO,CAAC8H,aAAa,CAAE,IAAIC,UAAU,CAAE/J,KAAK,EAAEoJ,cAAe,CAAE,CAAC;QAEhE,IAAKpH,OAAO,YAAYyF,gBAAgB,IAAIzF,OAAO,CAACP,IAAI,KAAK,OAAO,KAAMzB,KAAK,KAAK,WAAW,IAAIA,KAAK,KAAK,OAAO,CAAE,EAAG;UAExH,MAAM,CAAEqD,GAAG,EAAED,GAAG,CAAE,GAAG,CAAE,KAAK,EAAE,KAAK,CAAE,CAACxD,GAAG,CAAE2I,QAAQ,IAAI9D,UAAU,CAAEzC,OAAO,CAAEuG,QAAQ,CAAG,CAAE,CAAC;UAE1F,MAAM9I,KAAK,GAAG+D,IAAI,CAAC/D,KAAK;UACxB,MAAM0K,OAAO,GAAGzI,CAAC,GAAG8B,IAAI,CAAC9B,CAAC;UAC1B,MAAM0I,UAAU,GAAGD,OAAO,GAAG1K,KAAK;UAClCuC,OAAO,CAACsG,KAAK,GAAGjF,GAAG,GAAG,CAAED,GAAG,GAAGC,GAAG,IAAK+G,UAAU;UAChDpI,OAAO,CAAC8H,aAAa,CAAE,IAAIO,UAAU,CAAE,OAAO,EAAE;YAAEC,OAAO,EAAE;UAAK,CAAE,CAAE,CAAC;QAEtE;MAED;MAEA,KAAM,IAAIrH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,OAAO,CAAC8G,UAAU,CAACnG,MAAM,EAAEM,CAAC,EAAG,EAAG;QAEtD+G,QAAQ,CAAEhI,OAAO,CAAC8G,UAAU,CAAE7F,CAAC,CAAG,CAAC;MAEpC;IAED;EAED;EAEA+G,QAAQ,CAAEhI,OAAQ,CAAC;AAEpB;AAEA,SAAS9C,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}