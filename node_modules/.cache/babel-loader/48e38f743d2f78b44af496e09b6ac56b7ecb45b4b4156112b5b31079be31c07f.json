{"ast":null,"code":"import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { useAsset } from 'use-asset';\nimport { mergeVertices } from 'three-stdlib';\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n}; // External hooks\n\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\n\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\n\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\n\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n}; // Internal hooks\n\n/**\n * @internal\n */\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n  /**\n   * Return the proxy and a reset function\n   */\n\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    erp = 0.8\n  } = props;\n  const rapier = useAsset(importRapier);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []); // Update mutable props\n\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.allowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.predictionDistance = predictionDistance;\n    worldProxy.integrationParameters.erp = erp;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, erp]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      } // New states\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\n\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\n\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\n\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\n\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue); // Update the forwarded ref when the inner ref changes\n\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null); // We spread the props out here to make sure that the ref is updated when the props change.\n\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray); // Only provide a object state after the ref has been set\n\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []); // Update the RigidBodyStates whenever the instances change\n\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\n\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\n\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };","map":{"version":3,"names":["Vector3","Vector3$1","Quaternion","Quaternion$1","ActiveEvents","ColliderDesc","EventQueue","RigidBodyDesc","CoefficientCombineRule","Collider","RapierCollider","RigidBody","RapierRigidBody","useFrame","useThree","React","useRef","useEffect","memo","useMemo","useContext","useState","createContext","useCallback","forwardRef","Fragment","Euler","Object3D","Matrix4","BufferAttribute","MathUtils","DynamicDrawUsage","useAsset","mergeVertices","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_quaternion","_vector3","_matrix4","_position","_rotation","_scale","vectorArrayToVector3","arr","x","y","z","rapierQuaternionToQuaternion","w","set","vector3ToRapierVector","v","Array","isArray","threeVector3","quaternionToRapierQuaternion","rigidBodyTypeMap","fixed","dynamic","kinematicPosition","kinematicVelocity","rigidBodyTypeFromString","type","scaleVertices","vertices","scale","scaledVerts","from","vectorToTuple","useConst","initialValue","ref","current","undefined","useRaf","callback","cb","raf","lastFrame","loop","now","performance","delta","requestAnimationFrame","cancelAnimationFrame","UseFrameStepper","onStep","updatePriority","_","dt","RafStepper","FrameStepper","createElement","FrameStepper$1","_objectWithoutPropertiesLoose","excluded","sourceKeys","indexOf","_objectWithoutProperties","sourceSymbolKeys","prototype","propertyIsEnumerable","call","_excluded$2","scaleColliderArgs","shape","args","newArgs","slice","s","scaleArray","map","arg","index","createColliderFromOptions","options","world","getRigidBody","scaledArgs","desc","createCollider","immutableColliderOptions","massPropertiesConflictError","setColliderMassOptions","collider","density","mass","massProperties","Error","setDensity","setMass","setMassProperties","centerOfMass","principalAngularInertia","angularInertiaLocalFrame","mutableColliderOptions","sensor","setSensor","collisionGroups","setCollisionGroups","solverGroups","setSolverGroups","friction","setFriction","frictionCombineRule","setFrictionCombineRule","restitution","setRestitution","restitutionCombineRule","setRestitutionCombineRule","quaternion","position","rotation","mutableColliderOptionKeys","setColliderOptions","states","state","get","handle","_state$worldParent","parentWorldScale","parent","getWorldScale","parentInvertedWorldMatrix","worldParent","matrixWorld","clone","invert","updateWorldMatrix","copy","premultiply","decompose","setTranslationWrtParent","setRotationWrtParent","setTranslation","setRotation","option","useUpdateColliderOptions","getCollider","props","mutablePropsAsFlatArray","flatMap","isChildOfMeshCollider","child","flag","traverseAncestors","a","userData","r3RapierType","createColliderState","rigidBodyObject","autoColliderMap","cuboid","ball","hull","trimesh","createColliderPropsFromChildren","ignoreMeshColliders","_ignoreMeshColliders","childColliderProps","invertedParentMatrixWorld","colliderFromChild","worldScale","colliders","rotationEuler","setFromQuaternion","geometry","offset","getColliderArgsFromGeometry","colliderProps","cleanRigidBodyPropsForCollider","includeInvisible","traverse","traverseVisible","computeBoundingBox","boundingBox","size","getSize","getCenter","computeBoundingSphere","boundingSphere","radius","center","_clonedGeometry$index","clonedGeometry","attributes","array","g","getActiveCollisionEventsFromProps","collision","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","contactForce","onContactForce","useColliderEvents","events","activeEvents","collisionEventsActive","contactForceEventsActive","hasCollisionEvent","hasContactForceEvent","setActiveEvents","COLLISION_EVENTS","CONTACT_FORCE_EVENTS","delete","rest","useMutableCallback","fn","useRapier","rapier","rapierContext","useBeforePhysicsStep","beforeStepCallbacks","add","useAfterPhysicsStep","afterStepCallbacks","useChildColliderProps","setColliderProps","Debug","mesh","buffers","debugRender","setAttribute","colors","frustumCulled","color","vertexColors","createSingletonProxy","createInstance","instance","handler","prop","Reflect","proxy","Proxy","reset","newInstance","getCollisionPayloadFromSource","other","_target$collider$stat","_target$rigidBody$sta","_other$collider$state","_other$rigidBody$stat","_other$collider$state2","_other$rigidBody$stat2","rigidBody","colliderObject","importRapier","r","init","Physics","children","timeStep","paused","interpolate","updateLoop","debug","gravity","allowedLinearError","predictionDistance","numSolverIterations","numAdditionalFrictionIterations","numInternalPgsIterations","minIslandSize","maxCcdSubsteps","erp","invalidate","rigidBodyStates","Map","colliderStates","rigidBodyEvents","colliderEvents","eventQueue","Set","worldProxy","resetWorldProxy","setWorldProxy","World","free","integrationParameters","getSourceFromColliderHandle","_collider$parent","colEvents","colliderState","rigidBodyHandle","rbEvents","rigidBodyState","steppingState","previousState","accumulator","step","timeStepVariable","clampedDelta","clamp","stepWorld","timestep","forEachRigidBody","body","translation","interpolationAlpha","onSleep","onWake","isSleeping","_events$onSleep","_events$onWake","setMatrix","t","compose","invertedWorldMatrix","meshType","lerp","slerp","drainCollisionEvents","handle1","handle2","started","source1","source2","collisionPayload1","collisionPayload2","contactPair","manifold","flipped","_source1$rigidBody$ev","_source1$rigidBody$ev2","_source2$rigidBody$ev","_source2$rigidBody$ev2","_source1$collider$eve","_source1$collider$eve2","_source2$collider$eve","_source2$collider$eve2","_source1$rigidBody$ev3","_source1$rigidBody$ev4","_source2$rigidBody$ev3","_source2$rigidBody$ev4","_source1$collider$eve3","_source1$collider$eve4","_source2$collider$eve3","_source2$collider$eve4","intersectionPair","_source1$rigidBody$ev5","_source1$rigidBody$ev6","_source2$rigidBody$ev5","_source2$rigidBody$ev6","_source1$collider$eve5","_source1$collider$eve6","_source2$collider$eve5","_source2$collider$eve6","_source1$rigidBody$ev7","_source1$rigidBody$ev8","_source2$rigidBody$ev7","_source2$rigidBody$ev8","_source1$collider$eve7","_source1$collider$eve8","_source2$collider$eve7","_source2$collider$eve8","drainContactForceEvents","event","_source1$rigidBody$ev9","_source1$rigidBody$ev10","_source2$rigidBody$ev9","_source2$rigidBody$ev10","_source1$collider$eve9","_source1$collider$eve10","_source2$collider$eve9","_source2$collider$eve10","collider1","collider2","totalForce","totalForceMagnitude","maxForceDirection","maxForceMagnitude","forEachActiveRigidBody","context","setWorld","physicsOptions","isPaused","isDebug","stepCallback","Provider","_extends","assign","bind","hasOwnProperty","useImperativeInstance","createFn","destroyFn","dependencyList","getInstance","destroy","vec3","quat","euler","useForwardedRef","forwardedRef","defaultValue","innerRef","AnyCollider","name","rigidBodyContext","useRigidBodyContext","colliderRef","objectRef","immutablePropArray","removeCollider","mergedProps","CuboidCollider","displayName","RoundCuboidCollider","BallCollider","CapsuleCollider","HeightfieldCollider","TrimeshCollider","ConeCollider","RoundConeCollider","CylinderCollider","RoundCylinderCollider","ConvexHullCollider","rigidBodyDescFromOptions","_options$canSleep","canSleep","createRigidBodyState","getMatrix","_meshType","matrix","immutableRigidBodyOptions","mutableRigidBodyOptions","gravityScale","rb","setGravityScale","additionalSolverIterations","setAdditionalSolverIterations","linearDamping","setLinearDamping","angularDamping","setAngularDamping","dominanceGroup","setDominanceGroup","enabledRotations","setEnabledRotations","enabledTranslations","setEnabledTranslations","lockRotations","lockTranslations","angularVelocity","setAngvel","linearVelocity","setLinvel","ccd","enableCcd","setBodyType","mutableRigidBodyOptionKeys","setRigidBodyOptions","updateTranslations","useUpdateRigidBodyOptions","useRigidBodyEvents","eventHandlers","_excluded$1","RigidBodyContext","transformState","objectProps","rigidBodyRef","mergedOptions","createRigidBody","removeRigidBody","contextValue","MeshCollider","_excluded","InstancedRigidBodies","rigidBodiesRef","instanceWrapperRef","instances","colliderNodes","rigidBodyProps","getInstancedMesh","firstChild","instancedMesh","instanceMatrix","setUsage","console","warn","applyInstancedState","getMatrixAt","setMatrixAt","needsUpdate","node","colliderIndex","useImpulseJoint","body1","body2","params","jointRef","newJoint","createImpulseJoint","joint","getImpulseJoint","removeImpulseJoint","useFixedJoint","body1Anchor","body1LocalFrame","body2Anchor","body2LocalFrame","JointData","useSphericalJoint","spherical","useRevoluteJoint","axis","limits","revolute","limitsEnabled","usePrismaticJoint","prismatic","useRopeJoint","vBody1Anchor","vBody2Anchor","rope","useSpringJoint","restLength","stiffness","damping","spring","interactionGroups","memberships","filters","bitmask","groups","flat","reduce","acc","layer"],"sources":["/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js"],"sourcesContent":["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { useAsset } from 'use-asset';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\n\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\n\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\n\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld);\n\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n\n    _matrix4.decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n\n      childColliderProps.push(colliderProps);\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n\n  return rest;\n};\n\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n}; // External hooks\n\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\n\n\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\n\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\n\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n}; // Internal hooks\n\n/**\n * @internal\n */\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.get(instance, prop);\n    },\n\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.set(instance, prop, value);\n    }\n\n  };\n  const proxy = new Proxy({}, handler);\n\n  const reset = () => {\n    instance = undefined;\n  };\n\n  const set = newInstance => {\n    instance = newInstance;\n  };\n  /**\n   * Return the proxy and a reset function\n   */\n\n\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\n\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\n\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    erp = 0.8\n  } = props;\n  const rapier = useAsset(importRapier);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []); // Update mutable props\n\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.allowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.predictionDistance = predictionDistance;\n    worldProxy.integrationParameters.erp = erp;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, erp]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      } // New states\n\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\n\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n\n    const destroy = () => destroyFn(instance);\n\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\n\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\n\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\n\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue); // Update the forwarded ref when the inner ref changes\n\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n\n    return forwardedRef;\n  }\n\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null); // We spread the props out here to make sure that the ref is updated when the props change.\n\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion,\n    transformState\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray); // Only provide a object state after the ref has been set\n\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n\n  const {\n    // instanced props\n    children,\n    instances,\n    colliderNodes = [],\n    // wrapper object props\n    position,\n    rotation,\n    quaternion,\n    scale\n  } = props,\n        rigidBodyProps = _objectWithoutProperties(props, _excluded);\n\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n\n    return undefined;\n  };\n\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []); // Update the RigidBodyStates whenever the instances change\n\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n\n    return state;\n  };\n\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\n\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\n\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}