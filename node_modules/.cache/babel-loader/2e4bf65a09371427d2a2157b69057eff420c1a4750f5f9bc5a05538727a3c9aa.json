{"ast":null,"code":"import { useGLTF, useAnimations, useKeyboardControls } from \"@react-three/drei\";\nimport { useThree, Canvas, useFrame } from \"@react-three/fiber\";\nimport { useRapier, RigidBody, CapsuleCollider, CylinderCollider, quat } from \"@react-three/rapier\";\nimport React, { useMemo, useEffect, useRef, Suspense, forwardRef, useState, useCallback } from \"react\";\nimport * as THREE from \"three\";\nimport { useControls } from \"leva\";\nimport { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\nimport { useSpring, animated } from \"@react-spring/three\";\nconst useFollowCam = function (props) {\n  const {\n    scene,\n    camera,\n    gl\n  } = useThree();\n  const disableFollowCam = props.disableFollowCam;\n  const disableFollowCamPos = props.disableFollowCamPos;\n  const disableFollowCamTarget = props.disableFollowCamTarget;\n  let isMouseDown = false;\n  let previousTouch1 = null;\n  let previousTouch2 = null;\n  let originZDis = props.camInitDis;\n  const camMaxDis = props.camMaxDis;\n  const camMinDis = props.camMinDis;\n  const camInitDir = props.camInitDir;\n  const camMoveSpeed = props.camMoveSpeed;\n  const camZoomSpeed = props.camZoomSpeed;\n  const camCollisionOffset = props.camCollisionOffset;\n  const pivot = useMemo(() => new THREE.Object3D(), []);\n  const followCam = useMemo(() => {\n    const origin = new THREE.Object3D();\n    origin.position.set(0, 0, originZDis);\n    return origin;\n  }, []);\n  let smallestDistance = null;\n  let cameraDistance = null;\n  let intersects = null;\n  let intersectObjects = [];\n  const cameraRayDir = useMemo(() => new THREE.Vector3(), []);\n  const cameraRayOrigin = useMemo(() => new THREE.Vector3(), []);\n  const cameraPosition = useMemo(() => new THREE.Vector3(), []);\n  const camLerpingPoint = useMemo(() => new THREE.Vector3(), []);\n  const camRayCast = new THREE.Raycaster(cameraRayOrigin, cameraRayDir, 0, -camMaxDis);\n  const onDocumentMouseMove = e => {\n    if (document.pointerLockElement || isMouseDown) {\n      pivot.rotation.y -= e.movementX * 2e-3 * camMoveSpeed;\n      const vy = followCam.rotation.x + e.movementY * 2e-3 * camMoveSpeed;\n      cameraDistance = followCam.position.length();\n      if (vy >= -0.5 && vy <= 1.5) {\n        followCam.rotation.x = vy;\n        followCam.position.y = -cameraDistance * Math.sin(-vy);\n        followCam.position.z = -cameraDistance * Math.cos(-vy);\n      }\n    }\n    return false;\n  };\n  const onDocumentMouseWheel = e => {\n    const vz = originZDis - e.deltaY * 2e-3 * camZoomSpeed;\n    const vy = followCam.rotation.x;\n    if (vz >= camMaxDis && vz <= camMinDis) {\n      originZDis = vz;\n      followCam.position.z = originZDis * Math.cos(-vy);\n      followCam.position.y = originZDis * Math.sin(-vy);\n    }\n    return false;\n  };\n  const onTouchEnd = e => {\n    previousTouch1 = null;\n    previousTouch2 = null;\n  };\n  const onTouchMove = e => {\n    e.preventDefault();\n    e.stopImmediatePropagation();\n    const touch1 = e.targetTouches[0];\n    const touch2 = e.targetTouches[1];\n    if (previousTouch1 && !previousTouch2) {\n      const touch1MovementX = touch1.pageX - previousTouch1.pageX;\n      const touch1MovementY = touch1.pageY - previousTouch1.pageY;\n      pivot.rotation.y -= touch1MovementX * 5e-3 * camMoveSpeed;\n      const vy = followCam.rotation.x + touch1MovementY * 5e-3 * camMoveSpeed;\n      cameraDistance = followCam.position.length();\n      if (vy >= -0.5 && vy <= 1.5) {\n        followCam.rotation.x = vy;\n        followCam.position.y = -cameraDistance * Math.sin(-vy);\n        followCam.position.z = -cameraDistance * Math.cos(-vy);\n      }\n    }\n    if (previousTouch2) {\n      const prePinchDis = Math.hypot(previousTouch1.pageX - previousTouch2.pageX, previousTouch1.pageY - previousTouch2.pageY);\n      const pinchDis = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);\n      const vz = originZDis - (prePinchDis - pinchDis) * 0.01 * camZoomSpeed;\n      const vy = followCam.rotation.x;\n      if (vz >= camMaxDis && vz <= camMinDis) {\n        originZDis = vz;\n        followCam.position.z = originZDis * Math.cos(-vy);\n        followCam.position.y = originZDis * Math.sin(-vy);\n      }\n    }\n    previousTouch1 = touch1;\n    previousTouch2 = touch2;\n  };\n  const joystickCamMove = (movementX, movementY) => {\n    pivot.rotation.y -= movementX * 5e-3 * camMoveSpeed * 3;\n    const vy = followCam.rotation.x + movementY * 5e-3 * camMoveSpeed * 3;\n    cameraDistance = followCam.position.length();\n    if (vy >= -0.5 && vy <= 1.5) {\n      followCam.rotation.x = vy;\n      followCam.position.y = -cameraDistance * Math.sin(-vy);\n      followCam.position.z = -cameraDistance * Math.cos(vy);\n    }\n  };\n  function customTraverse(object) {\n    if (object.userData && object.userData.camExcludeCollision === true) {\n      return;\n    }\n    if (object.isMesh && object.geometry.type !== \"InstancedBufferGeometry\") {\n      intersectObjects.push(object);\n    }\n    object.children.forEach(child => {\n      customTraverse(child);\n    });\n  }\n  const cameraCollisionDetect = delta => {\n    cameraRayOrigin.copy(pivot.position);\n    camera.getWorldPosition(cameraPosition);\n    cameraRayDir.subVectors(cameraPosition, pivot.position);\n    intersects = camRayCast.intersectObjects(intersectObjects);\n    if (intersects.length && intersects[0].distance <= -originZDis) {\n      smallestDistance = -intersects[0].distance * camCollisionOffset < -0.7 ? -intersects[0].distance * camCollisionOffset : -0.7;\n    } else {\n      smallestDistance = originZDis;\n    }\n    camLerpingPoint.set(followCam.position.x, smallestDistance * Math.sin(-followCam.rotation.x), smallestDistance * Math.cos(-followCam.rotation.x));\n    followCam.position.lerp(camLerpingPoint, delta * 4);\n  };\n  useEffect(() => {\n    pivot.rotation.y = camInitDir.y;\n    followCam.rotation.x = camInitDir.x;\n  }, []);\n  useEffect(() => {\n    if (disableFollowCam) {\n      camera.position.set(disableFollowCamPos.x, disableFollowCamPos.y, disableFollowCamPos.z);\n      camera.lookAt(new THREE.Vector3(disableFollowCamTarget.x, disableFollowCamTarget.y, disableFollowCamTarget.z));\n    } else {\n      camera.position.set(0, 0, 0);\n    }\n  }, [disableFollowCam]);\n  useEffect(() => {\n    scene.children.forEach(child => customTraverse(child));\n    disableFollowCam ? followCam.remove(camera) : followCam.add(camera);\n    pivot.add(followCam);\n    gl.domElement.addEventListener(\"mousedown\", () => {\n      isMouseDown = true;\n    });\n    gl.domElement.addEventListener(\"mouseup\", () => {\n      isMouseDown = false;\n    });\n    gl.domElement.addEventListener(\"mousemove\", onDocumentMouseMove);\n    gl.domElement.addEventListener(\"mousewheel\", onDocumentMouseWheel);\n    gl.domElement.addEventListener(\"touchend\", onTouchEnd);\n    gl.domElement.addEventListener(\"touchmove\", onTouchMove, {\n      passive: false\n    });\n    return () => {\n      gl.domElement.removeEventListener(\"mousedown\", () => {\n        isMouseDown = true;\n      });\n      gl.domElement.removeEventListener(\"mouseup\", () => {\n        isMouseDown = false;\n      });\n      gl.domElement.removeEventListener(\"mousemove\", onDocumentMouseMove);\n      gl.domElement.removeEventListener(\"mousewheel\", onDocumentMouseWheel);\n      gl.domElement.removeEventListener(\"touchend\", onTouchEnd);\n      gl.domElement.removeEventListener(\"touchmove\", onTouchMove);\n      followCam.remove(camera);\n    };\n  });\n  return {\n    pivot,\n    followCam,\n    cameraCollisionDetect,\n    joystickCamMove\n  };\n};\nconst useGame = /* @__PURE__ */create( /* @__PURE__ */subscribeWithSelector((set, get) => {\n  return {\n    /**\n     * Point to move point\n     */\n    moveToPoint: null,\n    /**\n     * Check is camera based movement\n     */\n    isCameraBased: false,\n    /**\n     * Character animations state manegement\n     */\n    // Initial animation\n    curAnimation: null,\n    animationSet: {},\n    initializeAnimationSet: animationSet => {\n      set(state => {\n        if (Object.keys(state.animationSet).length === 0) {\n          return {\n            animationSet\n          };\n        }\n        return {};\n      });\n    },\n    reset: () => {\n      set(state => {\n        return {\n          curAnimation: state.animationSet.idle\n        };\n      });\n    },\n    idle: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.jumpIdle) {\n          return {\n            curAnimation: state.animationSet.jumpLand\n          };\n        } else if (state.curAnimation !== state.animationSet.action1 && state.curAnimation !== state.animationSet.action2 && state.curAnimation !== state.animationSet.action3 && state.curAnimation !== state.animationSet.action4) {\n          return {\n            curAnimation: state.animationSet.idle\n          };\n        }\n        return {};\n      });\n    },\n    walk: () => {\n      set(state => {\n        if (state.curAnimation !== state.animationSet.action4) {\n          return {\n            curAnimation: state.animationSet.walk\n          };\n        }\n        return {};\n      });\n    },\n    run: () => {\n      set(state => {\n        if (state.curAnimation !== state.animationSet.action4) {\n          return {\n            curAnimation: state.animationSet.run\n          };\n        }\n        return {};\n      });\n    },\n    jump: () => {\n      set(state => {\n        return {\n          curAnimation: state.animationSet.jump\n        };\n      });\n    },\n    jumpIdle: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.jump) {\n          return {\n            curAnimation: state.animationSet.jumpIdle\n          };\n        }\n        return {};\n      });\n    },\n    jumpLand: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.jumpIdle) {\n          return {\n            curAnimation: state.animationSet.jumpLand\n          };\n        }\n        return {};\n      });\n    },\n    fall: () => {\n      set(state => {\n        return {\n          curAnimation: state.animationSet.fall\n        };\n      });\n    },\n    action1: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.idle) {\n          return {\n            curAnimation: state.animationSet.action1\n          };\n        }\n        return {};\n      });\n    },\n    action2: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.idle) {\n          return {\n            curAnimation: state.animationSet.action2\n          };\n        }\n        return {};\n      });\n    },\n    action3: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.idle) {\n          return {\n            curAnimation: state.animationSet.action3\n          };\n        }\n        return {};\n      });\n    },\n    action4: () => {\n      set(state => {\n        if (state.curAnimation === state.animationSet.idle || state.curAnimation === state.animationSet.walk || state.curAnimation === state.animationSet.run) {\n          return {\n            curAnimation: state.animationSet.action4\n          };\n        }\n        return {};\n      });\n    },\n    /**\n     * Additional animations\n     */\n    // triggerFunction: ()=>{\n    //    set((state) => {\n    //        return { curAnimation: state.animationSet.additionalAnimation };\n    //    });\n    // }\n    /**\n     * Set/get point to move point\n     */\n    setMoveToPoint: point => {\n      set(() => {\n        return {\n          moveToPoint: point\n        };\n      });\n    },\n    getMoveToPoint: () => {\n      return {\n        moveToPoint: get().moveToPoint\n      };\n    },\n    /**\n     * Set/get camera based movement\n     */\n    setCameraBased: isCameraBased => {\n      set(() => {\n        return {\n          isCameraBased\n        };\n      });\n    },\n    getCameraBased: () => {\n      return {\n        isCameraBased: get().isCameraBased\n      };\n    }\n  };\n}));\nconst useJoystickControls = /* @__PURE__ */create( /* @__PURE__ */subscribeWithSelector((set, get) => {\n  return {\n    /**\n     * Joystick state manegement\n     */\n    // Initial joystick/button state\n    curJoystickDis: 0,\n    curJoystickAng: 0,\n    curRunState: false,\n    curButton1Pressed: false,\n    curButton2Pressed: false,\n    curButton3Pressed: false,\n    curButton4Pressed: false,\n    curButton5Pressed: false,\n    setJoystick: (joystickDis, joystickAng, runState) => {\n      set(() => {\n        return {\n          curJoystickDis: joystickDis,\n          curJoystickAng: joystickAng,\n          curRunState: runState\n        };\n      });\n    },\n    resetJoystick: () => {\n      set(state => {\n        if (state.curJoystickDis !== 0 || state.curJoystickAng !== 0) {\n          return {\n            curJoystickDis: 0,\n            curJoystickAng: 0,\n            curRunState: false\n          };\n        }\n        return {};\n      });\n    },\n    pressButton1: () => {\n      set(state => {\n        if (!state.curButton1Pressed) {\n          return {\n            curButton1Pressed: true\n          };\n        }\n        return {};\n      });\n    },\n    pressButton2: () => {\n      set(state => {\n        if (!state.curButton2Pressed) {\n          return {\n            curButton2Pressed: true\n          };\n        }\n        return {};\n      });\n    },\n    pressButton3: () => {\n      set(state => {\n        if (!state.curButton3Pressed) {\n          return {\n            curButton3Pressed: true\n          };\n        }\n        return {};\n      });\n    },\n    pressButton4: () => {\n      set(state => {\n        if (!state.curButton4Pressed) {\n          return {\n            curButton4Pressed: true\n          };\n        }\n        return {};\n      });\n    },\n    pressButton5: () => {\n      set(state => {\n        if (!state.curButton5Pressed) {\n          return {\n            curButton5Pressed: true\n          };\n        }\n        return {};\n      });\n    },\n    releaseAllButtons: () => {\n      set(state => {\n        if (state.curButton1Pressed) {\n          return {\n            curButton1Pressed: false\n          };\n        }\n        if (state.curButton2Pressed) {\n          return {\n            curButton2Pressed: false\n          };\n        }\n        if (state.curButton3Pressed) {\n          return {\n            curButton3Pressed: false\n          };\n        }\n        if (state.curButton4Pressed) {\n          return {\n            curButton4Pressed: false\n          };\n        }\n        if (state.curButton5Pressed) {\n          return {\n            curButton5Pressed: false\n          };\n        }\n        return {};\n      });\n    },\n    getJoystickValues: () => {\n      return {\n        joystickDis: get().curJoystickDis,\n        joystickAng: get().curJoystickAng,\n        runState: get().curRunState,\n        button1Pressed: get().curButton1Pressed,\n        button2Pressed: get().curButton2Pressed,\n        button3Pressed: get().curButton3Pressed,\n        button4Pressed: get().curButton4Pressed,\n        button5Pressed: get().curButton5Pressed\n      };\n    }\n  };\n}));\nfunction EcctrlAnimation(props) {\n  const group = useRef();\n  const {\n    animations\n  } = useGLTF(props.characterURL);\n  const {\n    actions\n  } = useAnimations(animations, group);\n  const curAnimation = useGame(state => state.curAnimation);\n  const resetAnimation = useGame(state => state.reset);\n  const initializeAnimationSet = useGame(state => state.initializeAnimationSet);\n  useEffect(() => {\n    initializeAnimationSet(props.animationSet);\n  }, []);\n  useEffect(() => {\n    const action = actions[curAnimation ? curAnimation : props.animationSet.jumpIdle];\n    if (curAnimation === props.animationSet.jump || curAnimation === props.animationSet.jumpLand || curAnimation === props.animationSet.action1 || curAnimation === props.animationSet.action2 || curAnimation === props.animationSet.action3 || curAnimation === props.animationSet.action4) {\n      action.reset().fadeIn(0.2).setLoop(THREE.LoopOnce, void 0).play();\n      action.clampWhenFinished = true;\n    } else {\n      action.reset().fadeIn(0.2).play();\n    }\n    action._mixer.addEventListener(\"finished\", () => resetAnimation());\n    return () => {\n      action.fadeOut(0.2);\n      action._mixer.removeEventListener(\"finished\", () => resetAnimation());\n      action._mixer._listeners = [];\n    };\n  }, [curAnimation]);\n  return /* @__PURE__ */React.createElement(Suspense, {\n    fallback: null\n  }, /* @__PURE__ */React.createElement(\"group\", {\n    ref: group,\n    dispose: null,\n    userData: {\n      camExcludeCollision: true\n    }\n  }, props.children));\n}\nconst JoystickComponents = props => {\n  let joystickCenterX = 0;\n  let joystickCenterY = 0;\n  let joystickHalfWidth = 0;\n  let joystickHalfHeight = 0;\n  let joystickMaxDis = 0;\n  let joystickDis = 0;\n  let joystickAng = 0;\n  const touch1MovementVec2 = useMemo(() => new THREE.Vector2(), []);\n  const joystickMovementVec2 = useMemo(() => new THREE.Vector2(), []);\n  const [windowSize, setWindowSize] = useState({\n    innerHeight,\n    innerWidth\n  });\n  const joystickDiv = document.querySelector(\"#ecctrl-joystick\");\n  const [springs, api] = useSpring(() => ({\n    topRotationX: 0,\n    topRotationY: 0,\n    basePositionX: 0,\n    basePositionY: 0,\n    config: {\n      tension: 600\n    }\n  }));\n  const joystickBaseGeo = useMemo(() => new THREE.CylinderGeometry(2.3, 2.1, 0.3, 16), []);\n  const joystickStickGeo = useMemo(() => new THREE.CylinderGeometry(0.3, 0.3, 3, 6), []);\n  const joystickHandleGeo = useMemo(() => new THREE.SphereGeometry(1.4, 8, 8), []);\n  const joystickBaseMaterial = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.3\n  }), []);\n  const joystickStickMaterial = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.3\n  }), []);\n  const joystickHandleMaterial = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.7\n  }), []);\n  const setJoystick = useJoystickControls(state => state.setJoystick);\n  const resetJoystick = useJoystickControls(state => state.resetJoystick);\n  const onTouchMove = useCallback(e => {\n    e.preventDefault();\n    e.stopImmediatePropagation();\n    const touch1 = e.targetTouches[0];\n    const touch1MovementX = touch1.pageX - joystickCenterX;\n    const touch1MovementY = -(touch1.pageY - joystickCenterY);\n    touch1MovementVec2.set(touch1MovementX, touch1MovementY);\n    joystickDis = Math.min(Math.sqrt(Math.pow(touch1MovementX, 2) + Math.pow(touch1MovementY, 2)), joystickMaxDis);\n    joystickAng = touch1MovementVec2.angle();\n    joystickMovementVec2.set(joystickDis * Math.cos(joystickAng), joystickDis * Math.sin(joystickAng));\n    const runState = joystickDis > joystickMaxDis * 0.7;\n    api.start({\n      topRotationX: -joystickMovementVec2.y / joystickHalfHeight,\n      topRotationY: joystickMovementVec2.x / joystickHalfWidth,\n      basePositionX: joystickMovementVec2.x * 2e-3,\n      basePositionY: joystickMovementVec2.y * 2e-3\n    });\n    setJoystick(joystickDis, joystickAng, runState);\n  }, [api, windowSize]);\n  const onTouchEnd = e => {\n    api.start({\n      topRotationX: 0,\n      topRotationY: 0,\n      basePositionX: 0,\n      basePositionY: 0\n    });\n    resetJoystick();\n  };\n  const onWindowResize = () => {\n    setWindowSize({\n      innerHeight: window.innerHeight,\n      innerWidth: window.innerWidth\n    });\n  };\n  useEffect(() => {\n    const joystickPositionX = joystickDiv.getBoundingClientRect().x;\n    const joystickPositionY = joystickDiv.getBoundingClientRect().y;\n    joystickHalfWidth = joystickDiv.getBoundingClientRect().width / 2;\n    joystickHalfHeight = joystickDiv.getBoundingClientRect().height / 2;\n    joystickMaxDis = joystickHalfWidth * 0.65;\n    joystickCenterX = joystickPositionX + joystickHalfWidth;\n    joystickCenterY = joystickPositionY + joystickHalfHeight;\n    joystickDiv.addEventListener(\"touchmove\", onTouchMove, {\n      passive: false\n    });\n    joystickDiv.addEventListener(\"touchend\", onTouchEnd);\n    window.visualViewport.addEventListener(\"resize\", onWindowResize);\n    return () => {\n      joystickDiv.removeEventListener(\"touchmove\", onTouchMove);\n      joystickDiv.removeEventListener(\"touchend\", onTouchEnd);\n      window.visualViewport.removeEventListener(\"resize\", onWindowResize);\n    };\n  });\n  return /* @__PURE__ */React.createElement(Suspense, {\n    fallback: \"null\"\n  }, /* @__PURE__ */React.createElement(animated.group, {\n    \"position-x\": springs.basePositionX,\n    \"position-y\": springs.basePositionY\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: joystickBaseGeo,\n    material: joystickBaseMaterial,\n    rotation: [-Math.PI / 2, 0, 0],\n    ...props.joystickBaseProps\n  })), /* @__PURE__ */React.createElement(animated.group, {\n    \"rotation-x\": springs.topRotationX,\n    \"rotation-y\": springs.topRotationY\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: joystickStickGeo,\n    material: joystickStickMaterial,\n    rotation: [-Math.PI / 2, 0, 0],\n    position: [0, 0, 1.5],\n    ...props.joystickStickProps\n  }), /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: joystickHandleGeo,\n    material: joystickHandleMaterial,\n    position: [0, 0, 4],\n    ...props.joystickHandleProps\n  })));\n};\nconst ButtonComponents = ({\n  buttonNumber = 1,\n  ...props\n}) => {\n  const buttonLargeBaseGeo = useMemo(() => new THREE.CylinderGeometry(1.1, 1, 0.3, 16), []);\n  const buttonSmallBaseGeo = useMemo(() => new THREE.CylinderGeometry(0.9, 0.8, 0.3, 16), []);\n  const buttonTop1Geo = useMemo(() => new THREE.CylinderGeometry(0.9, 0.9, 0.5, 16), []);\n  const buttonTop2Geo = useMemo(() => new THREE.CylinderGeometry(0.9, 0.9, 0.5, 16), []);\n  const buttonTop3Geo = useMemo(() => new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16), []);\n  const buttonTop4Geo = useMemo(() => new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16), []);\n  const buttonTop5Geo = useMemo(() => new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16), []);\n  const buttonBaseMaterial = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.3\n  }), []);\n  const buttonTop1Material = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.5\n  }), []);\n  const buttonTop2Material = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.5\n  }), []);\n  const buttonTop3Material = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.5\n  }), []);\n  const buttonTop4Material = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.5\n  }), []);\n  const buttonTop5Material = useMemo(() => new THREE.MeshNormalMaterial({\n    transparent: true,\n    opacity: 0.5\n  }), []);\n  const buttonDiv = document.querySelector(\"#ecctrl-button\");\n  const [springs, api] = useSpring(() => ({\n    buttonTop1BaseScaleY: 1,\n    buttonTop1BaseScaleXAndZ: 1,\n    buttonTop2BaseScaleY: 1,\n    buttonTop2BaseScaleXAndZ: 1,\n    buttonTop3BaseScaleY: 1,\n    buttonTop3BaseScaleXAndZ: 1,\n    buttonTop4BaseScaleY: 1,\n    buttonTop4BaseScaleXAndZ: 1,\n    buttonTop5BaseScaleY: 1,\n    buttonTop5BaseScaleXAndZ: 1,\n    config: {\n      tension: 600\n    }\n  }));\n  const pressButton1 = useJoystickControls(state => state.pressButton1);\n  const pressButton2 = useJoystickControls(state => state.pressButton2);\n  const pressButton3 = useJoystickControls(state => state.pressButton3);\n  const pressButton4 = useJoystickControls(state => state.pressButton4);\n  const pressButton5 = useJoystickControls(state => state.pressButton5);\n  const releaseAllButtons = useJoystickControls(state => state.releaseAllButtons);\n  const onPointerDown = number => {\n    switch (number) {\n      case 1:\n        pressButton1();\n        api.start({\n          buttonTop1BaseScaleY: 0.5,\n          buttonTop1BaseScaleXAndZ: 1.15\n        });\n        break;\n      case 2:\n        pressButton2();\n        api.start({\n          buttonTop2BaseScaleY: 0.5,\n          buttonTop2BaseScaleXAndZ: 1.15\n        });\n        break;\n      case 3:\n        pressButton3();\n        api.start({\n          buttonTop3BaseScaleY: 0.5,\n          buttonTop3BaseScaleXAndZ: 1.15\n        });\n        break;\n      case 4:\n        pressButton4();\n        api.start({\n          buttonTop4BaseScaleY: 0.5,\n          buttonTop4BaseScaleXAndZ: 1.15\n        });\n        break;\n      case 5:\n        pressButton5();\n        api.start({\n          buttonTop5BaseScaleY: 0.5,\n          buttonTop5BaseScaleXAndZ: 1.15\n        });\n        break;\n    }\n  };\n  const onPointerUp = () => {\n    releaseAllButtons();\n    api.start({\n      buttonTop1BaseScaleY: 1,\n      buttonTop1BaseScaleXAndZ: 1,\n      buttonTop2BaseScaleY: 1,\n      buttonTop2BaseScaleXAndZ: 1,\n      buttonTop3BaseScaleY: 1,\n      buttonTop3BaseScaleXAndZ: 1,\n      buttonTop4BaseScaleY: 1,\n      buttonTop4BaseScaleXAndZ: 1,\n      buttonTop5BaseScaleY: 1,\n      buttonTop5BaseScaleXAndZ: 1\n    });\n  };\n  useEffect(() => {\n    buttonDiv.addEventListener(\"pointerup\", onPointerUp);\n    return () => {\n      buttonDiv.removeEventListener(\"pointerup\", onPointerUp);\n    };\n  });\n  return /* @__PURE__ */React.createElement(Suspense, {\n    fallback: \"null\"\n  }, buttonNumber > 0 && /* @__PURE__ */React.createElement(animated.group, {\n    \"scale-x\": springs.buttonTop1BaseScaleXAndZ,\n    \"scale-y\": springs.buttonTop1BaseScaleY,\n    \"scale-z\": springs.buttonTop1BaseScaleXAndZ,\n    rotation: [-Math.PI / 2, 0, 0],\n    position: props.buttonGroup1Position || (buttonNumber === 1 ? [0, 0, 0] : [2, 1, 0])\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonLargeBaseGeo,\n    material: buttonBaseMaterial,\n    ...props.buttonLargeBaseProps,\n    onPointerDown: () => onPointerDown(1)\n  }), /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonTop1Geo,\n    material: buttonTop1Material,\n    position: [0, -0.3, 0],\n    ...props.buttonTop1Props\n  })), buttonNumber > 1 && /* @__PURE__ */React.createElement(animated.group, {\n    \"scale-x\": springs.buttonTop2BaseScaleXAndZ,\n    \"scale-y\": springs.buttonTop2BaseScaleY,\n    \"scale-z\": springs.buttonTop2BaseScaleXAndZ,\n    rotation: [-Math.PI / 2, 0, 0],\n    position: props.buttonGroup2Position || [0.5, -1.3, 0]\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonLargeBaseGeo,\n    material: buttonBaseMaterial,\n    ...props.buttonLargeBaseProps,\n    onPointerDown: () => onPointerDown(2)\n  }), /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonTop2Geo,\n    material: buttonTop2Material,\n    position: [0, -0.3, 0],\n    ...props.buttonTop2Props\n  })), buttonNumber > 2 && /* @__PURE__ */React.createElement(animated.group, {\n    \"scale-x\": springs.buttonTop3BaseScaleXAndZ,\n    \"scale-y\": springs.buttonTop3BaseScaleY,\n    \"scale-z\": springs.buttonTop3BaseScaleXAndZ,\n    rotation: [-Math.PI / 2, 0, 0],\n    position: props.buttonGroup3Position || [-1, 1, 0]\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonSmallBaseGeo,\n    material: buttonBaseMaterial,\n    ...props.buttonSmallBaseProps,\n    onPointerDown: () => onPointerDown(3)\n  }), /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonTop3Geo,\n    material: buttonTop3Material,\n    position: [0, -0.3, 0],\n    ...props.buttonTop3Props\n  })), buttonNumber > 3 && /* @__PURE__ */React.createElement(animated.group, {\n    \"scale-x\": springs.buttonTop4BaseScaleXAndZ,\n    \"scale-y\": springs.buttonTop4BaseScaleY,\n    \"scale-z\": springs.buttonTop4BaseScaleXAndZ,\n    rotation: [-Math.PI / 2, 0, 0],\n    position: props.buttonGroup4Position || [-2, -1.3, 0]\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonSmallBaseGeo,\n    material: buttonBaseMaterial,\n    ...props.buttonSmallBaseProps,\n    onPointerDown: () => onPointerDown(4)\n  }), /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonTop4Geo,\n    material: buttonTop4Material,\n    position: [0, -0.3, 0],\n    ...props.buttonTop4Props\n  })), buttonNumber > 4 && /* @__PURE__ */React.createElement(animated.group, {\n    \"scale-x\": springs.buttonTop5BaseScaleXAndZ,\n    \"scale-y\": springs.buttonTop5BaseScaleY,\n    \"scale-z\": springs.buttonTop5BaseScaleXAndZ,\n    rotation: [-Math.PI / 2, 0, 0],\n    position: props.buttonGroup5Position || [0.4, 2.9, 0]\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonSmallBaseGeo,\n    material: buttonBaseMaterial,\n    ...props.buttonSmallBaseProps,\n    onPointerDown: () => onPointerDown(5)\n  }), /* @__PURE__ */React.createElement(\"mesh\", {\n    geometry: buttonTop5Geo,\n    material: buttonTop5Material,\n    position: [0, -0.3, 0],\n    ...props.buttonTop5Props\n  })));\n};\nconst EcctrlJoystick = forwardRef((props, ref) => {\n  const joystickWrapperStyle = {\n    userSelect: \"none\",\n    MozUserSelect: \"none\",\n    WebkitUserSelect: \"none\",\n    msUserSelect: \"none\",\n    touchAction: \"none\",\n    pointerEvents: \"none\",\n    overscrollBehavior: \"none\",\n    position: \"fixed\",\n    zIndex: \"9999\",\n    height: props.joystickHeightAndWidth || \"200px\",\n    width: props.joystickHeightAndWidth || \"200px\",\n    left: props.joystickPositionLeft || \"0\",\n    bottom: props.joystickPositionBottom || \"0\"\n  };\n  const buttonWrapperStyle = {\n    userSelect: \"none\",\n    MozUserSelect: \"none\",\n    WebkitUserSelect: \"none\",\n    msUserSelect: \"none\",\n    touchAction: \"none\",\n    pointerEvents: \"none\",\n    overscrollBehavior: \"none\",\n    position: \"fixed\",\n    zIndex: \"9999\",\n    height: props.buttonHeightAndWidth || \"200px\",\n    width: props.buttonHeightAndWidth || \"200px\",\n    right: props.buttonPositionRight || \"0\",\n    bottom: props.buttonPositionBottom || \"0\"\n  };\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref\n  }, /* @__PURE__ */React.createElement(\"div\", {\n    id: \"ecctrl-joystick\",\n    style: joystickWrapperStyle,\n    onContextMenu: e => e.preventDefault()\n  }, /* @__PURE__ */React.createElement(Canvas, {\n    shadows: true,\n    orthographic: true,\n    camera: {\n      zoom: props.joystickCamZoom || 26,\n      position: props.joystickCamPosition || [0, 0, 50]\n    }\n  }, /* @__PURE__ */React.createElement(JoystickComponents, {\n    ...props\n  }), props.children)), /* @__PURE__ */React.createElement(\"div\", {\n    id: \"ecctrl-button\",\n    style: buttonWrapperStyle,\n    onContextMenu: e => e.preventDefault()\n  }, /* @__PURE__ */React.createElement(Canvas, {\n    shadows: true,\n    orthographic: true,\n    camera: {\n      zoom: props.buttonCamZoom || 26,\n      position: props.buttonCamPosition || [0, 0, 50]\n    }\n  }, /* @__PURE__ */React.createElement(ButtonComponents, {\n    ...props\n  }), props.children)));\n});\nconst getMovingDirection = (forward, backward, leftward, rightward, pivot) => {\n  if (!forward && !backward && !leftward && !rightward) return null;\n  if (forward && leftward) return pivot.rotation.y + Math.PI / 4;\n  if (forward && rightward) return pivot.rotation.y - Math.PI / 4;\n  if (backward && leftward) return pivot.rotation.y - Math.PI / 4 + Math.PI;\n  if (backward && rightward) return pivot.rotation.y + Math.PI / 4 + Math.PI;\n  if (backward) return pivot.rotation.y + Math.PI;\n  if (leftward) return pivot.rotation.y + Math.PI / 2;\n  if (rightward) return pivot.rotation.y - Math.PI / 2;\n  if (forward) return pivot.rotation.y;\n};\nconst Ecctrl = ({\n  children,\n  debug = false,\n  capsuleHalfHeight = 0.35,\n  capsuleRadius = 0.3,\n  floatHeight = 0.3,\n  characterInitDir = 0,\n  // in rad\n  followLight = false,\n  disableFollowCam = false,\n  disableFollowCamPos = {\n    x: 0,\n    y: 0,\n    z: -5\n  },\n  disableFollowCamTarget = {\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  // Follow camera setups\n  camInitDis = -5,\n  camMaxDis = -7,\n  camMinDis = -0.7,\n  camInitDir = {\n    x: 0,\n    y: 0\n  },\n  // in rad\n  camTargetPos = {\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  camMoveSpeed = 1,\n  camZoomSpeed = 1,\n  camCollision = true,\n  camCollisionOffset = 0.7,\n  // Follow light setups\n  followLightPos = {\n    x: 20,\n    y: 30,\n    z: 10\n  },\n  // Base control setups\n  maxVelLimit = 2.5,\n  turnVelMultiplier = 0.2,\n  turnSpeed = 15,\n  sprintMult = 2,\n  jumpVel = 4,\n  jumpForceToGroundMult = 5,\n  slopJumpMult = 0.25,\n  sprintJumpMult = 1.2,\n  airDragMultiplier = 0.2,\n  dragDampingC = 0.15,\n  accDeltaTime = 8,\n  rejectVelMult = 4,\n  moveImpulsePointY = 0.5,\n  camFollowMult = 11,\n  fallingGravityScale = 2.5,\n  fallingMaxVel = -20,\n  wakeUpDelay = 200,\n  // Floating Ray setups\n  rayOriginOffest = {\n    x: 0,\n    y: -capsuleHalfHeight,\n    z: 0\n  },\n  rayHitForgiveness = 0.1,\n  rayLength = capsuleRadius + 2,\n  rayDir = {\n    x: 0,\n    y: -1,\n    z: 0\n  },\n  floatingDis = capsuleRadius + floatHeight,\n  springK = 1.2,\n  dampingC = 0.08,\n  // Slope Ray setups\n  showSlopeRayOrigin = false,\n  slopeMaxAngle = 1,\n  // in rad\n  slopeRayOriginOffest = capsuleRadius - 0.03,\n  slopeRayLength = capsuleRadius + 3,\n  slopeRayDir = {\n    x: 0,\n    y: -1,\n    z: 0\n  },\n  slopeUpExtraForce = 0.1,\n  slopeDownExtraForce = 0.2,\n  // AutoBalance Force setups\n  autoBalance = true,\n  autoBalanceSpringK = 0.3,\n  autoBalanceDampingC = 0.03,\n  autoBalanceSpringOnY = 0.5,\n  autoBalanceDampingOnY = 0.015,\n  // Animation temporary setups\n  animated: animated2 = false,\n  // Mode setups\n  mode = null,\n  // Controller setups\n  controllerKeys = {\n    forward: 12,\n    backward: 13,\n    leftward: 14,\n    rightward: 15,\n    jump: 2,\n    action1: 11,\n    action2: 3,\n    action3: 1,\n    action4: 0\n  },\n  // Other rigibody props from parent\n  ...props\n}, ref) => {\n  const characterRef = ref || useRef();\n  const characterModelRef = useRef();\n  const characterModelIndicator = useMemo(() => new THREE.Object3D(), []);\n  const defaultControllerKeys = {\n    forward: 12,\n    backward: 13,\n    leftward: 14,\n    rightward: 15,\n    jump: 2,\n    action1: 11,\n    action2: 3,\n    action3: 1,\n    action4: 0\n  };\n  let isModePointToMove = false;\n  const setCameraBased = useGame(state => state.setCameraBased);\n  const getCameraBased = useGame(state => state.getCameraBased);\n  if (mode) {\n    if (mode === \"PointToMove\") isModePointToMove = true;\n    if (mode === \"CameraBasedMovement\") setCameraBased(true);\n  }\n  const modelFacingVec = useMemo(() => new THREE.Vector3(), []);\n  const bodyFacingVec = useMemo(() => new THREE.Vector3(), []);\n  const bodyBalanceVec = useMemo(() => new THREE.Vector3(), []);\n  const bodyBalanceVecOnX = useMemo(() => new THREE.Vector3(), []);\n  const bodyFacingVecOnY = useMemo(() => new THREE.Vector3(), []);\n  const bodyBalanceVecOnZ = useMemo(() => new THREE.Vector3(), []);\n  const vectorY = useMemo(() => new THREE.Vector3(0, 1, 0), []);\n  const vectorZ = useMemo(() => new THREE.Vector3(0, 0, 1), []);\n  const bodyContactForce = useMemo(() => new THREE.Vector3(), []);\n  const idleAnimation = !animated2 ? null : useGame(state => state.idle);\n  const walkAnimation = !animated2 ? null : useGame(state => state.walk);\n  const runAnimation = !animated2 ? null : useGame(state => state.run);\n  const jumpAnimation = !animated2 ? null : useGame(state => state.jump);\n  const jumpIdleAnimation = !animated2 ? null : useGame(state => state.jumpIdle);\n  const fallAnimation = !animated2 ? null : useGame(state => state.fall);\n  const action1Animation = !animated2 ? null : useGame(state => state.action1);\n  const action2Animation = !animated2 ? null : useGame(state => state.action2);\n  const action3Animation = !animated2 ? null : useGame(state => state.action3);\n  const action4Animation = !animated2 ? null : useGame(state => state.action4);\n  let characterControlsDebug = null;\n  let floatingRayDebug = null;\n  let slopeRayDebug = null;\n  let autoBalanceForceDebug = null;\n  if (debug) {\n    characterControlsDebug = useControls(\"Character Controls\", {\n      maxVelLimit: {\n        value: maxVelLimit,\n        min: 0,\n        max: 10,\n        step: 0.01\n      },\n      turnVelMultiplier: {\n        value: turnVelMultiplier,\n        min: 0,\n        max: 1,\n        step: 0.01\n      },\n      turnSpeed: {\n        value: turnSpeed,\n        min: 5,\n        max: 30,\n        step: 0.1\n      },\n      sprintMult: {\n        value: sprintMult,\n        min: 1,\n        max: 5,\n        step: 0.01\n      },\n      jumpVel: {\n        value: jumpVel,\n        min: 0,\n        max: 10,\n        step: 0.01\n      },\n      jumpForceToGroundMult: {\n        value: jumpForceToGroundMult,\n        min: 0,\n        max: 80,\n        step: 0.1\n      },\n      slopJumpMult: {\n        value: slopJumpMult,\n        min: 0,\n        max: 1,\n        step: 0.01\n      },\n      sprintJumpMult: {\n        value: sprintJumpMult,\n        min: 1,\n        max: 3,\n        step: 0.01\n      },\n      airDragMultiplier: {\n        value: airDragMultiplier,\n        min: 0,\n        max: 1,\n        step: 0.01\n      },\n      dragDampingC: {\n        value: dragDampingC,\n        min: 0,\n        max: 0.5,\n        step: 0.01\n      },\n      accDeltaTime: {\n        value: accDeltaTime,\n        min: 0,\n        max: 50,\n        step: 1\n      },\n      rejectVelMult: {\n        value: rejectVelMult,\n        min: 0,\n        max: 10,\n        step: 0.1\n      },\n      moveImpulsePointY: {\n        value: moveImpulsePointY,\n        min: 0,\n        max: 3,\n        step: 0.1\n      },\n      camFollowMult: {\n        value: camFollowMult,\n        min: 0,\n        max: 15,\n        step: 0.1\n      }\n    }, {\n      collapsed: true\n    });\n    maxVelLimit = characterControlsDebug.maxVelLimit;\n    turnVelMultiplier = characterControlsDebug.turnVelMultiplier;\n    turnSpeed = characterControlsDebug.turnSpeed;\n    sprintMult = characterControlsDebug.sprintMult;\n    jumpVel = characterControlsDebug.jumpVel;\n    jumpForceToGroundMult = characterControlsDebug.jumpForceToGroundMult;\n    slopJumpMult = characterControlsDebug.slopJumpMult;\n    sprintJumpMult = characterControlsDebug.sprintJumpMult;\n    airDragMultiplier = characterControlsDebug.airDragMultiplier;\n    dragDampingC = characterControlsDebug.dragDampingC;\n    accDeltaTime = characterControlsDebug.accDeltaTime;\n    rejectVelMult = characterControlsDebug.rejectVelMult;\n    moveImpulsePointY = characterControlsDebug.moveImpulsePointY;\n    camFollowMult = characterControlsDebug.camFollowMult;\n    floatingRayDebug = useControls(\"Floating Ray\", {\n      rayOriginOffest: {\n        x: 0,\n        y: -capsuleHalfHeight,\n        z: 0\n      },\n      rayHitForgiveness: {\n        value: rayHitForgiveness,\n        min: 0,\n        max: 0.5,\n        step: 0.01\n      },\n      rayLength: {\n        value: capsuleRadius + 2,\n        min: 0,\n        max: capsuleRadius + 10,\n        step: 0.01\n      },\n      rayDir: {\n        x: 0,\n        y: -1,\n        z: 0\n      },\n      floatingDis: {\n        value: capsuleRadius + floatHeight,\n        min: 0,\n        max: capsuleRadius + 2,\n        step: 0.01\n      },\n      springK: {\n        value: springK,\n        min: 0,\n        max: 5,\n        step: 0.01\n      },\n      dampingC: {\n        value: dampingC,\n        min: 0,\n        max: 3,\n        step: 0.01\n      }\n    }, {\n      collapsed: true\n    });\n    rayOriginOffest = floatingRayDebug.rayOriginOffest;\n    rayHitForgiveness = floatingRayDebug.rayHitForgiveness;\n    rayLength = floatingRayDebug.rayLength;\n    rayDir = floatingRayDebug.rayDir;\n    floatingDis = floatingRayDebug.floatingDis;\n    springK = floatingRayDebug.springK;\n    dampingC = floatingRayDebug.dampingC;\n    slopeRayDebug = useControls(\"Slope Ray\", {\n      showSlopeRayOrigin: false,\n      slopeMaxAngle: {\n        value: slopeMaxAngle,\n        min: 0,\n        max: 1.57,\n        step: 0.01\n      },\n      slopeRayOriginOffest: {\n        value: capsuleRadius,\n        min: 0,\n        max: capsuleRadius + 3,\n        step: 0.01\n      },\n      slopeRayLength: {\n        value: capsuleRadius + 3,\n        min: 0,\n        max: capsuleRadius + 13,\n        step: 0.01\n      },\n      slopeRayDir: {\n        x: 0,\n        y: -1,\n        z: 0\n      },\n      slopeUpExtraForce: {\n        value: slopeUpExtraForce,\n        min: 0,\n        max: 5,\n        step: 0.01\n      },\n      slopeDownExtraForce: {\n        value: slopeDownExtraForce,\n        min: 0,\n        max: 5,\n        step: 0.01\n      }\n    }, {\n      collapsed: true\n    });\n    showSlopeRayOrigin = slopeRayDebug.showSlopeRayOrigin;\n    slopeMaxAngle = slopeRayDebug.slopeMaxAngle;\n    slopeRayLength = slopeRayDebug.slopeRayLength;\n    slopeRayDir = slopeRayDebug.slopeRayDir;\n    slopeUpExtraForce = slopeRayDebug.slopeUpExtraForce;\n    slopeDownExtraForce = slopeRayDebug.slopeDownExtraForce;\n    autoBalanceForceDebug = useControls(\"AutoBalance Force\", {\n      autoBalance: {\n        value: true\n      },\n      autoBalanceSpringK: {\n        value: autoBalanceSpringK,\n        min: 0,\n        max: 5,\n        step: 0.01\n      },\n      autoBalanceDampingC: {\n        value: autoBalanceDampingC,\n        min: 0,\n        max: 0.1,\n        step: 1e-3\n      },\n      autoBalanceSpringOnY: {\n        value: autoBalanceSpringOnY,\n        min: 0,\n        max: 5,\n        step: 0.01\n      },\n      autoBalanceDampingOnY: {\n        value: autoBalanceDampingOnY,\n        min: 0,\n        max: 0.1,\n        step: 1e-3\n      }\n    }, {\n      collapsed: true\n    });\n    autoBalance = autoBalanceForceDebug.autoBalance;\n    autoBalanceSpringK = autoBalanceForceDebug.autoBalanceSpringK;\n    autoBalanceDampingC = autoBalanceForceDebug.autoBalanceDampingC;\n    autoBalanceSpringOnY = autoBalanceForceDebug.autoBalanceSpringOnY;\n    autoBalanceDampingOnY = autoBalanceForceDebug.autoBalanceDampingOnY;\n  }\n  function useIsInsideKeyboardControls() {\n    try {\n      return !!useKeyboardControls();\n    } catch (e) {\n      return false;\n    }\n  }\n  const isInsideKeyboardControls = useIsInsideKeyboardControls();\n  const [subscribeKeys, getKeys] = isInsideKeyboardControls ? useKeyboardControls() : [null];\n  const presetKeys = {\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false,\n    jump: false,\n    run: false\n  };\n  const {\n    rapier,\n    world\n  } = useRapier();\n  const getJoystickValues = useJoystickControls(state => state.getJoystickValues);\n  const pressButton1 = useJoystickControls(state => state.pressButton1);\n  const pressButton2 = useJoystickControls(state => state.pressButton2);\n  const pressButton3 = useJoystickControls(state => state.pressButton3);\n  const pressButton4 = useJoystickControls(state => state.pressButton4);\n  const pressButton5 = useJoystickControls(state => state.pressButton5);\n  const releaseAllButtons = useJoystickControls(state => state.releaseAllButtons);\n  const setJoystick = useJoystickControls(state => state.setJoystick);\n  const resetJoystick = useJoystickControls(state => state.resetJoystick);\n  let controllerIndex = null;\n  const gamepadKeys = {\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false\n  };\n  const gamepadJoystickVec2 = useMemo(() => new THREE.Vector2(), []);\n  let gamepadJoystickDis = 0;\n  let gamepadJoystickAng = 0;\n  const gamepadConnect = e => {\n    controllerIndex = e.gamepad.index;\n  };\n  const gamepadDisconnect = () => {\n    controllerIndex = null;\n  };\n  const mergedKeys = useMemo(() => Object.assign({}, defaultControllerKeys, controllerKeys), [controllerKeys]);\n  const handleButtons = buttons => {\n    gamepadKeys.forward = buttons[mergedKeys.forward].pressed;\n    gamepadKeys.backward = buttons[mergedKeys.backward].pressed;\n    gamepadKeys.leftward = buttons[mergedKeys.leftward].pressed;\n    gamepadKeys.rightward = buttons[mergedKeys.rightward].pressed;\n    if (buttons[mergedKeys.action4].pressed) {\n      pressButton2();\n    } else if (buttons[mergedKeys.action3].pressed) {\n      pressButton4();\n    } else if (buttons[mergedKeys.jump].pressed) {\n      pressButton1();\n    } else if (buttons[mergedKeys.action2].pressed) {\n      pressButton3();\n    } else if (buttons[mergedKeys.action1].pressed) {\n      pressButton5();\n    } else {\n      releaseAllButtons();\n    }\n  };\n  const handleSticks = axes => {\n    if (Math.abs(axes[0]) > 0 || Math.abs(axes[1]) > 0) {\n      gamepadJoystickVec2.set(axes[0], -axes[1]);\n      gamepadJoystickDis = Math.min(Math.sqrt(Math.pow(gamepadJoystickVec2.x, 2) + Math.pow(gamepadJoystickVec2.y, 2)), 1);\n      gamepadJoystickAng = gamepadJoystickVec2.angle();\n      const runState = gamepadJoystickDis > 0.7;\n      setJoystick(gamepadJoystickDis, gamepadJoystickAng, runState);\n    } else {\n      resetJoystick();\n    }\n    if (Math.abs(axes[2]) > 0 || Math.abs(axes[3]) > 0) {\n      joystickCamMove(axes[2], axes[3]);\n    }\n  };\n  let canJump = false;\n  let isFalling = false;\n  const initialGravityScale = useMemo(() => props.gravityScale || 1, []);\n  let massRatio = 1;\n  let isOnMovingObject = false;\n  const standingForcePoint = useMemo(() => new THREE.Vector3(), []);\n  const movingObjectDragForce = useMemo(() => new THREE.Vector3(), []);\n  const movingObjectVelocity = useMemo(() => new THREE.Vector3(), []);\n  const movingObjectVelocityInCharacterDir = useMemo(() => new THREE.Vector3(), []);\n  const distanceFromCharacterToObject = useMemo(() => new THREE.Vector3(), []);\n  const objectAngvelToLinvel = useMemo(() => new THREE.Vector3(), []);\n  const velocityDiff = useMemo(() => new THREE.Vector3(), []);\n  let dirLight = null;\n  const cameraSetups = {\n    disableFollowCam,\n    disableFollowCamPos,\n    disableFollowCamTarget,\n    camInitDis,\n    camMaxDis,\n    camMinDis,\n    camInitDir,\n    camMoveSpeed,\n    camZoomSpeed,\n    camCollisionOffset\n  };\n  const {\n    pivot,\n    cameraCollisionDetect,\n    joystickCamMove\n  } = useFollowCam(cameraSetups);\n  const pivotPosition = useMemo(() => new THREE.Vector3(), []);\n  const modelEuler = useMemo(() => new THREE.Euler(), []);\n  const modelQuat = useMemo(() => new THREE.Quaternion(), []);\n  const moveImpulse = useMemo(() => new THREE.Vector3(), []);\n  const movingDirection = useMemo(() => new THREE.Vector3(), []);\n  const moveAccNeeded = useMemo(() => new THREE.Vector3(), []);\n  const jumpVelocityVec = useMemo(() => new THREE.Vector3(), []);\n  const jumpDirection = useMemo(() => new THREE.Vector3(), []);\n  const currentVel = useMemo(() => new THREE.Vector3(), []);\n  const currentPos = useMemo(() => new THREE.Vector3(), []);\n  const dragForce = useMemo(() => new THREE.Vector3(), []);\n  const dragAngForce = useMemo(() => new THREE.Vector3(), []);\n  const wantToMoveVel = useMemo(() => new THREE.Vector3(), []);\n  const rejectVel = useMemo(() => new THREE.Vector3(), []);\n  let floatingForce = null;\n  const springDirVec = useMemo(() => new THREE.Vector3(), []);\n  const characterMassForce = useMemo(() => new THREE.Vector3(), []);\n  const rayOrigin = useMemo(() => new THREE.Vector3(), []);\n  const rayCast = new rapier.Ray(rayOrigin, rayDir);\n  let rayHit = null;\n  let slopeAngle = null;\n  let actualSlopeNormal = null;\n  let actualSlopeAngle = null;\n  const actualSlopeNormalVec = useMemo(() => new THREE.Vector3(), []);\n  const floorNormal = useMemo(() => new THREE.Vector3(0, 1, 0), []);\n  const slopeRayOriginRef = useRef();\n  const slopeRayorigin = useMemo(() => new THREE.Vector3(), []);\n  const slopeRayCast = new rapier.Ray(slopeRayorigin, slopeRayDir);\n  let slopeRayHit = null;\n  let isBodyHitWall = false;\n  let isPointMoving = false;\n  const crossVector = useMemo(() => new THREE.Vector3(), []);\n  const pointToPoint = useMemo(() => new THREE.Vector3(), []);\n  const getMoveToPoint = useGame(state => state.getMoveToPoint);\n  const bodySensorRef = useRef();\n  const handleOnIntersectionEnter = () => {\n    isBodyHitWall = true;\n  };\n  const handleOnIntersectionExit = () => {\n    isBodyHitWall = false;\n  };\n  let characterRotated = true;\n  const moveCharacter = (_, run, slopeAngle2, movingObjectVelocity2) => {\n    if (actualSlopeAngle < slopeMaxAngle && Math.abs(slopeAngle2) > 0.2 && Math.abs(slopeAngle2) < slopeMaxAngle) {\n      movingDirection.set(0, Math.sin(slopeAngle2), Math.cos(slopeAngle2));\n    } else if (actualSlopeAngle >= slopeMaxAngle) {\n      movingDirection.set(0, Math.sin(slopeAngle2) > 0 ? 0 : Math.sin(slopeAngle2), Math.sin(slopeAngle2) > 0 ? 0.1 : 1);\n    } else {\n      movingDirection.set(0, 0, 1);\n    }\n    movingDirection.applyQuaternion(characterModelIndicator.quaternion);\n    movingObjectVelocityInCharacterDir.copy(movingObjectVelocity2).projectOnVector(movingDirection).multiply(movingDirection);\n    const angleBetweenCharacterDirAndObjectDir = movingObjectVelocity2.angleTo(movingDirection);\n    const wantToMoveMeg = currentVel.dot(movingDirection);\n    wantToMoveVel.set(movingDirection.x * wantToMoveMeg, 0, movingDirection.z * wantToMoveMeg);\n    rejectVel.copy(currentVel).sub(wantToMoveVel);\n    moveAccNeeded.set((movingDirection.x * (maxVelLimit * (run ? sprintMult : 1) + movingObjectVelocityInCharacterDir.x) - (currentVel.x - movingObjectVelocity2.x * Math.sin(angleBetweenCharacterDirAndObjectDir) + rejectVel.x * (isOnMovingObject ? 0 : rejectVelMult))) / accDeltaTime, 0, (movingDirection.z * (maxVelLimit * (run ? sprintMult : 1) + movingObjectVelocityInCharacterDir.z) - (currentVel.z - movingObjectVelocity2.z * Math.sin(angleBetweenCharacterDirAndObjectDir) + rejectVel.z * (isOnMovingObject ? 0 : rejectVelMult))) / accDeltaTime);\n    const moveForceNeeded = moveAccNeeded.multiplyScalar(characterRef.current.mass());\n    characterRotated = Math.sin(characterModelIndicator.rotation.y).toFixed(3) == Math.sin(modelEuler.y).toFixed(3);\n    if (!characterRotated) {\n      moveImpulse.set(moveForceNeeded.x * turnVelMultiplier * (canJump ? 1 : airDragMultiplier),\n      // if it's in the air, give it less control\n      slopeAngle2 === null || slopeAngle2 == 0 ? 0 : movingDirection.y * turnVelMultiplier * (movingDirection.y > 0 ? slopeUpExtraForce : slopeDownExtraForce) * (run ? sprintMult : 1), moveForceNeeded.z * turnVelMultiplier * (canJump ? 1 : airDragMultiplier)\n      // if it's in the air, give it less control\n      );\n    } else {\n      moveImpulse.set(moveForceNeeded.x * (canJump ? 1 : airDragMultiplier), slopeAngle2 === null || slopeAngle2 == 0 ? 0 : movingDirection.y * (movingDirection.y > 0 ? slopeUpExtraForce : slopeDownExtraForce) * (run ? sprintMult : 1), moveForceNeeded.z * (canJump ? 1 : airDragMultiplier));\n    }\n    characterRef.current.applyImpulseAtPoint(moveImpulse, {\n      x: currentPos.x,\n      y: currentPos.y + moveImpulsePointY,\n      z: currentPos.z\n    }, true);\n  };\n  const autoBalanceCharacter = () => {\n    bodyFacingVec.set(0, 0, 1).applyQuaternion(quat(characterRef.current.rotation()));\n    bodyBalanceVec.set(0, 1, 0).applyQuaternion(quat(characterRef.current.rotation()));\n    bodyBalanceVecOnX.set(0, bodyBalanceVec.y, bodyBalanceVec.z);\n    bodyFacingVecOnY.set(bodyFacingVec.x, 0, bodyFacingVec.z);\n    bodyBalanceVecOnZ.set(bodyBalanceVec.x, bodyBalanceVec.y, 0);\n    if (getCameraBased().isCameraBased) {\n      modelEuler.y = pivot.rotation.y;\n      pivot.getWorldDirection(modelFacingVec);\n    } else {\n      characterModelIndicator.getWorldDirection(modelFacingVec);\n    }\n    const crossVecOnX = vectorY.clone().cross(bodyBalanceVecOnX);\n    const crossVecOnY = modelFacingVec.clone().cross(bodyFacingVecOnY);\n    const crossVecOnZ = vectorY.clone().cross(bodyBalanceVecOnZ);\n    dragAngForce.set((crossVecOnX.x < 0 ? 1 : -1) * autoBalanceSpringK * bodyBalanceVecOnX.angleTo(vectorY) - characterRef.current.angvel().x * autoBalanceDampingC, (crossVecOnY.y < 0 ? 1 : -1) * autoBalanceSpringOnY * modelFacingVec.angleTo(bodyFacingVecOnY) - characterRef.current.angvel().y * autoBalanceDampingOnY, (crossVecOnZ.z < 0 ? 1 : -1) * autoBalanceSpringK * bodyBalanceVecOnZ.angleTo(vectorY) - characterRef.current.angvel().z * autoBalanceDampingC);\n    characterRef.current.applyTorqueImpulse(dragAngForce, true);\n  };\n  const sleepCharacter = () => {\n    if (characterRef.current) {\n      if (document.visibilityState === \"hidden\") {\n        characterRef.current.sleep();\n      } else {\n        setTimeout(() => {\n          characterRef.current.wakeUp();\n        }, wakeUpDelay);\n      }\n    }\n  };\n  const pointToMove = (delta, slopeAngle2, movingObjectVelocity2) => {\n    const moveToPoint = getMoveToPoint().moveToPoint;\n    if (moveToPoint) {\n      pointToPoint.set(moveToPoint.x - currentPos.x, 0, moveToPoint.z - currentPos.z);\n      crossVector.crossVectors(pointToPoint, vectorZ);\n      modelEuler.y = (crossVector.y > 0 ? -1 : 1) * pointToPoint.angleTo(vectorZ);\n      if (characterRef.current) {\n        if (pointToPoint.length() > 0.3 && !isBodyHitWall) {\n          moveCharacter(delta, false, slopeAngle2, movingObjectVelocity2);\n          isPointMoving = true;\n        } else {\n          isPointMoving = false;\n        }\n      }\n    }\n  };\n  useEffect(() => {\n    if (followLight) {\n      dirLight = characterModelRef.current.parent.parent.children.find(item => {\n        return item.name === \"followLight\";\n      });\n    }\n  });\n  if (isInsideKeyboardControls) {\n    useEffect(() => {\n      const unSubscribeAction1 = subscribeKeys(state => state.action1, value => {\n        if (value) {\n          animated2 && action1Animation();\n        }\n      });\n      const unSubscribeAction2 = subscribeKeys(state => state.action2, value => {\n        if (value) {\n          animated2 && action2Animation();\n        }\n      });\n      const unSubscribeAction3 = subscribeKeys(state => state.action3, value => {\n        if (value) {\n          animated2 && action3Animation();\n        }\n      });\n      const unSubscribeAction4 = subscribeKeys(state => state.action4, value => {\n        if (value) {\n          animated2 && action4Animation();\n        }\n      });\n      return () => {\n        unSubscribeAction1();\n        unSubscribeAction2();\n        unSubscribeAction3();\n        unSubscribeAction4();\n      };\n    });\n  }\n  useEffect(() => {\n    const unSubPressButton2 = useJoystickControls.subscribe(state => state.curButton2Pressed, value => {\n      if (value) {\n        animated2 && action4Animation();\n      }\n    });\n    const unSubPressButton3 = useJoystickControls.subscribe(state => state.curButton3Pressed, value => {\n      if (value) {\n        animated2 && action2Animation();\n      }\n    });\n    const unSubPressButton4 = useJoystickControls.subscribe(state => state.curButton4Pressed, value => {\n      if (value) {\n        animated2 && action3Animation();\n      }\n    });\n    const unSubPressButton5 = useJoystickControls.subscribe(state => state.curButton5Pressed, value => {\n      if (value) {\n        animated2 && action1Animation();\n      }\n    });\n    return () => {\n      unSubPressButton2();\n      unSubPressButton3();\n      unSubPressButton4();\n      unSubPressButton5();\n    };\n  });\n  useEffect(() => {\n    characterRef.current.setEnabledRotations(autoBalance ? true : false, autoBalance ? true : false, autoBalance ? true : false, false);\n    return () => {\n      if (characterRef.current && characterModelRef.current) {\n        characterModelRef.current.quaternion.set(0, 0, 0, 1);\n        characterRef.current.setRotation({\n          x: 0,\n          y: 0,\n          z: 0,\n          w: 1\n        }, false);\n      }\n    };\n  }, [autoBalance]);\n  useEffect(() => {\n    modelEuler.y = characterInitDir;\n    window.addEventListener(\"visibilitychange\", sleepCharacter);\n    window.addEventListener(\"gamepadconnected\", gamepadConnect);\n    window.addEventListener(\"gamepaddisconnected\", gamepadDisconnect);\n    return () => {\n      window.removeEventListener(\"visibilitychange\", sleepCharacter);\n      window.removeEventListener(\"gamepadconnected\", gamepadConnect);\n      window.removeEventListener(\"gamepaddisconnected\", gamepadDisconnect);\n    };\n  }, []);\n  useFrame((state, delta) => {\n    var _a, _b, _c;\n    if (delta > 1) delta %= 1;\n    if (characterRef.current) {\n      currentPos.copy(characterRef.current.translation());\n      characterRef.current.userData.canJump = canJump;\n      characterRef.current.userData.slopeAngle = slopeAngle;\n      characterRef.current.userData.characterRotated = characterRotated;\n      characterRef.current.userData.isOnMovingObject = isOnMovingObject;\n    }\n    if (followLight && dirLight) {\n      dirLight.position.x = currentPos.x + followLightPos.x;\n      dirLight.position.y = currentPos.y + followLightPos.y;\n      dirLight.position.z = currentPos.z + followLightPos.z;\n      dirLight.target = characterModelRef.current;\n    }\n    if (controllerIndex !== null) {\n      const gamepad = navigator.getGamepads()[controllerIndex];\n      handleButtons(gamepad.buttons);\n      handleSticks(gamepad.axes);\n      modelEuler.y = (movingDirection2 => movingDirection2 === null ? modelEuler.y : movingDirection2)(getMovingDirection(gamepadKeys.forward, gamepadKeys.backward, gamepadKeys.leftward, gamepadKeys.rightward, pivot));\n    }\n    const {\n      joystickDis,\n      joystickAng,\n      runState,\n      button1Pressed\n    } = getJoystickValues();\n    if (joystickDis > 0) {\n      modelEuler.y = pivot.rotation.y + (joystickAng - Math.PI / 2);\n      moveCharacter(delta, runState, slopeAngle, movingObjectVelocity);\n    }\n    const {\n      forward,\n      backward,\n      leftward,\n      rightward,\n      jump,\n      run\n    } = isInsideKeyboardControls ? getKeys() : presetKeys;\n    modelEuler.y = (movingDirection2 => movingDirection2 === null ? modelEuler.y : movingDirection2)(getMovingDirection(forward, backward, leftward, rightward, pivot));\n    if (forward || backward || leftward || rightward || gamepadKeys.forward || gamepadKeys.backward || gamepadKeys.leftward || gamepadKeys.rightward) moveCharacter(delta, run, slopeAngle, movingObjectVelocity);\n    if (characterRef.current) currentVel.copy(characterRef.current.linvel());\n    if ((jump || button1Pressed) && canJump) {\n      jumpVelocityVec.set(currentVel.x, run ? sprintJumpMult * jumpVel : jumpVel, currentVel.z);\n      characterRef.current.setLinvel(jumpDirection.set(0, (run ? sprintJumpMult * jumpVel : jumpVel) * slopJumpMult, 0).projectOnVector(actualSlopeNormalVec).add(jumpVelocityVec), true);\n      characterMassForce.y *= jumpForceToGroundMult;\n      (_a = rayHit.collider.parent()) == null ? void 0 : _a.applyImpulseAtPoint(characterMassForce, standingForcePoint, true);\n    }\n    modelQuat.setFromEuler(modelEuler);\n    characterModelIndicator.quaternion.rotateTowards(modelQuat, delta * turnSpeed);\n    if (!autoBalance) {\n      if (getCameraBased().isCameraBased) {\n        characterModelRef.current.quaternion.copy(pivot.quaternion);\n      } else {\n        characterModelRef.current.quaternion.copy(characterModelIndicator.quaternion);\n      }\n    }\n    pivotPosition.set(currentPos.x + camTargetPos.x, currentPos.y + (camTargetPos.y || capsuleHalfHeight + capsuleRadius / 2), currentPos.z + camTargetPos.z);\n    pivot.position.lerp(pivotPosition, 1 - Math.exp(-camFollowMult * delta));\n    !disableFollowCam && state.camera.lookAt(pivot.position);\n    rayOrigin.addVectors(currentPos, rayOriginOffest);\n    rayHit = world.castRay(rayCast, rayLength, true,\n    // this exclude sensor \n    16, null, null, characterRef.current,\n    // this exclude any collider with userData: excludeEcctrlRay\n    collider => collider.parent().userData && !collider.parent().userData.excludeEcctrlRay);\n    if (rayHit && rayHit.toi < floatingDis + rayHitForgiveness) {\n      if (slopeRayHit && actualSlopeAngle < slopeMaxAngle) {\n        canJump = true;\n      }\n    } else {\n      canJump = false;\n    }\n    if (rayHit && canJump) {\n      if (rayHit.collider.parent()) {\n        standingForcePoint.set(rayOrigin.x, rayOrigin.y - rayHit.toi, rayOrigin.z);\n        const rayHitObjectBodyType = rayHit.collider.parent().bodyType();\n        const rayHitObjectBodyMass = rayHit.collider.parent().mass();\n        massRatio = characterRef.current.mass() / rayHitObjectBodyMass;\n        if (rayHitObjectBodyType === 0 || rayHitObjectBodyType === 2) {\n          isOnMovingObject = true;\n          distanceFromCharacterToObject.copy(currentPos).sub(rayHit.collider.parent().translation());\n          const movingObjectLinvel = rayHit.collider.parent().linvel();\n          const movingObjectAngvel = rayHit.collider.parent().angvel();\n          movingObjectVelocity.set(movingObjectLinvel.x + objectAngvelToLinvel.crossVectors(movingObjectAngvel, distanceFromCharacterToObject).x, movingObjectLinvel.y, movingObjectLinvel.z + objectAngvelToLinvel.crossVectors(movingObjectAngvel, distanceFromCharacterToObject).z).multiplyScalar(Math.min(1, 1 / massRatio));\n          velocityDiff.subVectors(movingObjectVelocity, currentVel);\n          if (velocityDiff.length() > 30) movingObjectVelocity.multiplyScalar(1 / velocityDiff.length());\n          if (rayHitObjectBodyType === 0) {\n            if (!forward && !backward && !leftward && !rightward && canJump && joystickDis === 0 && !isPointMoving && !gamepadKeys.forward && !gamepadKeys.backward && !gamepadKeys.leftward && !gamepadKeys.rightward) {\n              movingObjectDragForce.copy(bodyContactForce).multiplyScalar(delta).multiplyScalar(Math.min(1, 1 / massRatio)).negate();\n              bodyContactForce.set(0, 0, 0);\n            } else {\n              movingObjectDragForce.copy(moveImpulse).multiplyScalar(Math.min(1, 1 / massRatio)).negate();\n            }\n            rayHit.collider.parent().applyImpulseAtPoint(movingObjectDragForce, standingForcePoint, true);\n          }\n        } else {\n          massRatio = 1;\n          isOnMovingObject = false;\n          bodyContactForce.set(0, 0, 0);\n          movingObjectVelocity.set(0, 0, 0);\n        }\n      }\n    } else {\n      massRatio = 1;\n      isOnMovingObject = false;\n      bodyContactForce.set(0, 0, 0);\n      movingObjectVelocity.set(0, 0, 0);\n    }\n    slopeRayOriginRef.current.getWorldPosition(slopeRayorigin);\n    slopeRayorigin.y = rayOrigin.y;\n    slopeRayHit = world.castRay(slopeRayCast, slopeRayLength, true,\n    // this exclude sensor \n    16, null, null, characterRef.current,\n    // this exclude any collider with userData: excludeEcctrlRay\n    collider => collider.parent().userData && !collider.parent().userData.excludeEcctrlRay);\n    if (slopeRayHit) {\n      actualSlopeNormal = (_b = slopeRayHit.collider.castRayAndGetNormal(slopeRayCast, slopeRayLength, false)) == null ? void 0 : _b.normal;\n      if (actualSlopeNormal) {\n        actualSlopeNormalVec == null ? void 0 : actualSlopeNormalVec.set(actualSlopeNormal.x, actualSlopeNormal.y, actualSlopeNormal.z);\n        actualSlopeAngle = actualSlopeNormalVec == null ? void 0 : actualSlopeNormalVec.angleTo(floorNormal);\n      }\n    }\n    if (slopeRayHit && rayHit && slopeRayHit.toi < floatingDis + 0.5) {\n      if (canJump) {\n        slopeAngle = Number(Math.atan((rayHit.toi - slopeRayHit.toi) / slopeRayOriginOffest).toFixed(2));\n      } else {\n        slopeAngle = null;\n      }\n    } else {\n      slopeAngle = null;\n    }\n    if (rayHit != null) {\n      if (canJump && rayHit.collider.parent()) {\n        floatingForce = springK * (floatingDis - rayHit.toi) - characterRef.current.linvel().y * dampingC;\n        characterRef.current.applyImpulse(springDirVec.set(0, floatingForce, 0), false);\n        characterMassForce.set(0, floatingForce > 0 ? -floatingForce : 0, 0);\n        (_c = rayHit.collider.parent()) == null ? void 0 : _c.applyImpulseAtPoint(characterMassForce, standingForcePoint, true);\n      }\n    }\n    if (!forward && !backward && !leftward && !rightward && canJump && joystickDis === 0 && !isPointMoving && !gamepadKeys.forward && !gamepadKeys.backward && !gamepadKeys.leftward && !gamepadKeys.rightward) {\n      if (!isOnMovingObject) {\n        dragForce.set(-currentVel.x * dragDampingC, 0, -currentVel.z * dragDampingC);\n        characterRef.current.applyImpulse(dragForce, false);\n      } else {\n        dragForce.set((movingObjectVelocity.x - currentVel.x) * dragDampingC, 0, (movingObjectVelocity.z - currentVel.z) * dragDampingC);\n        characterRef.current.applyImpulse(dragForce, true);\n      }\n    }\n    isFalling = currentVel.y < 0 && !canJump ? true : false;\n    if (characterRef.current) {\n      if (currentVel.y < fallingMaxVel) {\n        if (characterRef.current.gravityScale() !== 0) {\n          characterRef.current.setGravityScale(0, true);\n        }\n      } else {\n        if (!isFalling && characterRef.current.gravityScale() !== initialGravityScale) {\n          characterRef.current.setGravityScale(initialGravityScale, true);\n        } else if (isFalling && characterRef.current.gravityScale() !== fallingGravityScale) {\n          characterRef.current.setGravityScale(fallingGravityScale, true);\n        }\n      }\n    }\n    if (autoBalance && characterRef.current) autoBalanceCharacter();\n    camCollision && cameraCollisionDetect(delta);\n    isModePointToMove && pointToMove(delta, slopeAngle, movingObjectVelocity);\n    if (animated2) {\n      if (!forward && !backward && !leftward && !rightward && !jump && !button1Pressed && joystickDis === 0 && !isPointMoving && !gamepadKeys.forward && !gamepadKeys.backward && !gamepadKeys.leftward && !gamepadKeys.rightward && canJump) {\n        idleAnimation();\n      } else if ((jump || button1Pressed) && canJump) {\n        jumpAnimation();\n      } else if (canJump && (forward || backward || leftward || rightward || joystickDis > 0 || isPointMoving || gamepadKeys.forward || gamepadKeys.backward || gamepadKeys.leftward || gamepadKeys.rightward)) {\n        run || runState ? runAnimation() : walkAnimation();\n      } else if (!canJump) {\n        jumpIdleAnimation();\n      }\n      if (rayHit == null && isFalling) {\n        fallAnimation();\n      }\n    }\n  });\n  return /* @__PURE__ */React.createElement(RigidBody, {\n    colliders: false,\n    ref: characterRef,\n    position: props.position || [0, 5, 0],\n    friction: props.friction || -0.5,\n    onContactForce: e => bodyContactForce.set(e.totalForce.x, e.totalForce.y, e.totalForce.z),\n    onCollisionExit: () => bodyContactForce.set(0, 0, 0),\n    userData: {\n      canJump: false\n    },\n    ...props\n  }, /* @__PURE__ */React.createElement(CapsuleCollider, {\n    name: \"character-capsule-collider\",\n    args: [capsuleHalfHeight, capsuleRadius]\n  }), isModePointToMove && /* @__PURE__ */React.createElement(CylinderCollider, {\n    ref: bodySensorRef,\n    sensor: true,\n    args: [capsuleHalfHeight / 2, capsuleRadius],\n    position: [0, 0, capsuleRadius / 2],\n    onIntersectionEnter: handleOnIntersectionEnter,\n    onIntersectionExit: handleOnIntersectionExit\n  }), /* @__PURE__ */React.createElement(\"group\", {\n    ref: characterModelRef,\n    userData: {\n      camExcludeCollision: true\n    }\n  }, /* @__PURE__ */React.createElement(\"mesh\", {\n    position: [rayOriginOffest.x, rayOriginOffest.y, rayOriginOffest.z + slopeRayOriginOffest],\n    ref: slopeRayOriginRef,\n    visible: showSlopeRayOrigin,\n    userData: {\n      camExcludeCollision: true\n    }\n  }, /* @__PURE__ */React.createElement(\"boxGeometry\", {\n    args: [0.15, 0.15, 0.15]\n  })), children));\n};\nconst Ecctrl$1 = forwardRef(Ecctrl);\nexport { EcctrlAnimation, EcctrlJoystick, Ecctrl$1 as default, useFollowCam, useGame, useJoystickControls };","map":{"version":3,"names":["useFollowCam","props","scene","camera","gl","useThree","disableFollowCam","disableFollowCamPos","disableFollowCamTarget","isMouseDown","previousTouch1","previousTouch2","originZDis","camInitDis","camMaxDis","camMinDis","camInitDir","camMoveSpeed","camZoomSpeed","camCollisionOffset","pivot","useMemo","THREE","Object3D","followCam","origin","position","set","smallestDistance","cameraDistance","intersects","intersectObjects","cameraRayDir","Vector3","cameraRayOrigin","cameraPosition","camLerpingPoint","camRayCast","Raycaster","onDocumentMouseMove","e","document","pointerLockElement","rotation","y","movementX","vy","x","movementY","length","Math","sin","z","cos","onDocumentMouseWheel","vz","deltaY","onTouchEnd","onTouchMove","preventDefault","stopImmediatePropagation","touch1","targetTouches","touch2","touch1MovementX","pageX","touch1MovementY","pageY","prePinchDis","hypot","pinchDis","touches","joystickCamMove","customTraverse","object","userData","camExcludeCollision","isMesh","geometry","type","push","children","forEach","child","cameraCollisionDetect","delta","copy","getWorldPosition","subVectors","distance","lerp","useEffect","lookAt","remove","add","domElement","addEventListener","passive","removeEventListener","useGame","create","subscribeWithSelector","get","moveToPoint","isCameraBased","curAnimation","animationSet","initializeAnimationSet","state","Object","keys","reset","idle","jumpIdle","jumpLand","action1","action2","action3","action4","walk","run","jump","fall","setMoveToPoint","point","getMoveToPoint","setCameraBased","getCameraBased","useJoystickControls","curJoystickDis","curJoystickAng","curRunState","curButton1Pressed","curButton2Pressed","curButton3Pressed","curButton4Pressed","curButton5Pressed","setJoystick","joystickDis","joystickAng","runState","resetJoystick","pressButton1","pressButton2","pressButton3","pressButton4","pressButton5","releaseAllButtons","getJoystickValues","button1Pressed","button2Pressed","button3Pressed","button4Pressed","button5Pressed","EcctrlAnimation","group","useRef","animations","useGLTF","characterURL","actions","useAnimations","resetAnimation","action","fadeIn","setLoop","LoopOnce","play","clampWhenFinished","_mixer","fadeOut","_listeners","React","createElement","Suspense","fallback","ref","dispose","JoystickComponents","joystickCenterX","joystickCenterY","joystickHalfWidth","joystickHalfHeight","joystickMaxDis","touch1MovementVec2","Vector2","joystickMovementVec2","windowSize","setWindowSize","useState","innerHeight","innerWidth","joystickDiv","querySelector","springs","api","useSpring","topRotationX","topRotationY","basePositionX","basePositionY","config","tension","joystickBaseGeo","CylinderGeometry","joystickStickGeo","joystickHandleGeo","SphereGeometry","joystickBaseMaterial","MeshNormalMaterial","transparent","opacity","joystickStickMaterial","joystickHandleMaterial","useCallback","min","sqrt","pow","angle","start","onWindowResize","window","joystickPositionX","getBoundingClientRect","joystickPositionY","width","height","visualViewport","animated","material","PI","joystickBaseProps","joystickStickProps","joystickHandleProps","ButtonComponents","buttonNumber","buttonLargeBaseGeo","buttonSmallBaseGeo","buttonTop1Geo","buttonTop2Geo","buttonTop3Geo","buttonTop4Geo","buttonTop5Geo","buttonBaseMaterial","buttonTop1Material","buttonTop2Material","buttonTop3Material","buttonTop4Material","buttonTop5Material","buttonDiv","buttonTop1BaseScaleY","buttonTop1BaseScaleXAndZ","buttonTop2BaseScaleY","buttonTop2BaseScaleXAndZ","buttonTop3BaseScaleY","buttonTop3BaseScaleXAndZ","buttonTop4BaseScaleY","buttonTop4BaseScaleXAndZ","buttonTop5BaseScaleY","buttonTop5BaseScaleXAndZ","onPointerDown","number","onPointerUp","buttonGroup1Position","buttonLargeBaseProps","buttonTop1Props","buttonGroup2Position","buttonTop2Props","buttonGroup3Position","buttonSmallBaseProps","buttonTop3Props","buttonGroup4Position","buttonTop4Props","buttonGroup5Position","buttonTop5Props","EcctrlJoystick","forwardRef","joystickWrapperStyle","userSelect","MozUserSelect","WebkitUserSelect","msUserSelect","touchAction","pointerEvents","overscrollBehavior","zIndex","joystickHeightAndWidth","left","joystickPositionLeft","bottom","joystickPositionBottom","buttonWrapperStyle","buttonHeightAndWidth","right","buttonPositionRight","buttonPositionBottom","id","style","onContextMenu","Canvas","shadows","orthographic","zoom","joystickCamZoom","joystickCamPosition","buttonCamZoom","buttonCamPosition","getMovingDirection","forward","backward","leftward","rightward","Ecctrl","debug","capsuleHalfHeight","capsuleRadius","floatHeight","characterInitDir","followLight","camTargetPos","camCollision","followLightPos","maxVelLimit","turnVelMultiplier","turnSpeed","sprintMult","jumpVel","jumpForceToGroundMult","slopJumpMult","sprintJumpMult","airDragMultiplier","dragDampingC","accDeltaTime","rejectVelMult","moveImpulsePointY","camFollowMult","fallingGravityScale","fallingMaxVel","wakeUpDelay","rayOriginOffest","rayHitForgiveness","rayLength","rayDir","floatingDis","springK","dampingC","showSlopeRayOrigin","slopeMaxAngle","slopeRayOriginOffest","slopeRayLength","slopeRayDir","slopeUpExtraForce","slopeDownExtraForce","autoBalance","autoBalanceSpringK","autoBalanceDampingC","autoBalanceSpringOnY","autoBalanceDampingOnY","animated2","mode","controllerKeys","characterRef","characterModelRef","characterModelIndicator","defaultControllerKeys","isModePointToMove","modelFacingVec","bodyFacingVec","bodyBalanceVec","bodyBalanceVecOnX","bodyFacingVecOnY","bodyBalanceVecOnZ","vectorY","vectorZ","bodyContactForce","idleAnimation","walkAnimation","runAnimation","jumpAnimation","jumpIdleAnimation","fallAnimation","action1Animation","action2Animation","action3Animation","action4Animation","characterControlsDebug","floatingRayDebug","slopeRayDebug","autoBalanceForceDebug","useControls","value","max","step","collapsed","useIsInsideKeyboardControls","useKeyboardControls","isInsideKeyboardControls","subscribeKeys","getKeys","presetKeys","rapier","world","useRapier","controllerIndex","gamepadKeys","gamepadJoystickVec2","gamepadJoystickDis","gamepadJoystickAng","gamepadConnect","gamepad","index","gamepadDisconnect","mergedKeys","assign","handleButtons","buttons","pressed","handleSticks","axes","abs","canJump","isFalling","initialGravityScale","gravityScale","massRatio","isOnMovingObject","standingForcePoint","movingObjectDragForce","movingObjectVelocity","movingObjectVelocityInCharacterDir","distanceFromCharacterToObject","objectAngvelToLinvel","velocityDiff","dirLight","cameraSetups","pivotPosition","modelEuler","Euler","modelQuat","Quaternion","moveImpulse","movingDirection","moveAccNeeded","jumpVelocityVec","jumpDirection","currentVel","currentPos","dragForce","dragAngForce","wantToMoveVel","rejectVel","floatingForce","springDirVec","characterMassForce","rayOrigin","rayCast","Ray","rayHit","slopeAngle","actualSlopeNormal","actualSlopeAngle","actualSlopeNormalVec","floorNormal","slopeRayOriginRef","slopeRayorigin","slopeRayCast","slopeRayHit","isBodyHitWall","isPointMoving","crossVector","pointToPoint","bodySensorRef","handleOnIntersectionEnter","handleOnIntersectionExit","characterRotated","moveCharacter","_","slopeAngle2","movingObjectVelocity2","applyQuaternion","quaternion","projectOnVector","multiply","angleBetweenCharacterDirAndObjectDir","angleTo","wantToMoveMeg","dot","sub","moveForceNeeded","multiplyScalar","current","mass","toFixed","applyImpulseAtPoint","autoBalanceCharacter","quat","getWorldDirection","crossVecOnX","clone","cross","crossVecOnY","crossVecOnZ","angvel","applyTorqueImpulse","sleepCharacter","visibilityState","sleep","setTimeout","wakeUp","pointToMove","crossVectors","parent","find","item","name","unSubscribeAction1","unSubscribeAction2","unSubscribeAction3","unSubscribeAction4","unSubPressButton2","subscribe","unSubPressButton3","unSubPressButton4","unSubPressButton5","setEnabledRotations","setRotation","w","useFrame","translation","target","navigator","getGamepads","movingDirection2","linvel","setLinvel","_a","collider","setFromEuler","rotateTowards","exp","addVectors","castRay","excludeEcctrlRay","toi","rayHitObjectBodyType","bodyType","rayHitObjectBodyMass","movingObjectLinvel","movingObjectAngvel","negate","_b","castRayAndGetNormal","normal","Number","atan","applyImpulse","_c","setGravityScale","RigidBody","colliders","friction","onContactForce","totalForce","onCollisionExit","CapsuleCollider","args","CylinderCollider","sensor","onIntersectionEnter","onIntersectionExit","visible","Ecctrl$1"],"sources":["/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/ecctrl/src/hooks/useFollowCam.tsx","/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/ecctrl/src/stores/useGame.ts","/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/ecctrl/src/stores/useJoystickControls.ts","/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/ecctrl/src/EcctrlAnimation.tsx","/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/ecctrl/src/EcctrlJoystick.tsx","/home/ervin/Escritorio/integrador/squid-games-pi-2024-1-client/node_modules/ecctrl/src/Ecctrl.tsx"],"sourcesContent":["import { useThree } from \"@react-three/fiber\";\n// import { useRapier } from \"@react-three/rapier\";\nimport { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\n\nexport const useFollowCam = function (props: UseFollowCamProps) {\n  const { scene, camera, gl } = useThree();\n  const disableFollowCam = props.disableFollowCam;\n  const disableFollowCamPos = props.disableFollowCamPos;\n  const disableFollowCamTarget = props.disableFollowCamTarget;\n  // const { rapier, world } = useRapier();\n\n  let isMouseDown = false;\n  let previousTouch1: Touch = null;\n  let previousTouch2: Touch = null;\n\n  let originZDis = props.camInitDis;\n  const camMaxDis = props.camMaxDis;\n  const camMinDis = props.camMinDis;\n  const camInitDir = props.camInitDir;\n  const camMoveSpeed = props.camMoveSpeed;\n  const camZoomSpeed = props.camZoomSpeed;\n  const camCollisionOffset = props.camCollisionOffset;\n  const pivot = useMemo(() => new THREE.Object3D(), []);\n  const followCam = useMemo(() => {\n    const origin = new THREE.Object3D();\n    origin.position.set(0, 0, originZDis);\n    return origin;\n  }, []);\n\n  /** Camera collison detect setups */\n  let smallestDistance = null;\n  let cameraDistance = null;\n  let intersects = null;\n  let intersectObjects: THREE.Object3D[] = [];\n  const cameraRayDir = useMemo(() => new THREE.Vector3(), []);\n  const cameraRayOrigin = useMemo(() => new THREE.Vector3(), []);\n  const cameraPosition = useMemo(() => new THREE.Vector3(), []);\n  const camLerpingPoint = useMemo(() => new THREE.Vector3(), []);\n  const camRayCast = new THREE.Raycaster(\n    cameraRayOrigin,\n    cameraRayDir,\n    0,\n    -camMaxDis\n  );\n  // Rapier ray setup (optional)\n  // const rayCast = new rapier.Ray(cameraRayOrigin, cameraRayDir);\n  // let rayLength = null;\n  // let rayHit = null;\n\n  // Mouse move event\n  const onDocumentMouseMove = (e: MouseEvent) => {\n    if (document.pointerLockElement || isMouseDown) {\n      pivot.rotation.y -= e.movementX * 0.002 * camMoveSpeed;\n      const vy = followCam.rotation.x + e.movementY * 0.002 * camMoveSpeed;\n\n      cameraDistance = followCam.position.length();\n\n      if (vy >= -0.5 && vy <= 1.5) {\n        followCam.rotation.x = vy;\n        followCam.position.y = -cameraDistance * Math.sin(-vy);\n        followCam.position.z = -cameraDistance * Math.cos(-vy);\n      }\n    }\n    return false;\n  };\n\n  // Mouse scroll event\n  const onDocumentMouseWheel = (e: Event) => {\n    const vz = originZDis - (e as WheelEvent).deltaY * 0.002 * camZoomSpeed;\n    const vy = followCam.rotation.x;\n\n    if (vz >= camMaxDis && vz <= camMinDis) {\n      originZDis = vz;\n      followCam.position.z = originZDis * Math.cos(-vy);\n      followCam.position.y = originZDis * Math.sin(-vy);\n    }\n    return false;\n  };\n\n  /**\n   * Touch events\n   */\n  // Touch end event\n  const onTouchEnd = (e: TouchEvent) => {\n    previousTouch1 = null\n    previousTouch2 = null\n  }\n\n  // Touch move event\n  const onTouchMove = (e: TouchEvent) => {\n    // prevent swipe to navigate gesture\n    e.preventDefault();\n    e.stopImmediatePropagation();\n\n    const touch1 = e.targetTouches[0];\n    const touch2 = e.targetTouches[1];\n\n    // One finger touch to rotate camera\n    if (previousTouch1 && !previousTouch2) {\n      const touch1MovementX = touch1.pageX - previousTouch1.pageX;\n      const touch1MovementY = touch1.pageY - previousTouch1.pageY;\n\n      pivot.rotation.y -= touch1MovementX * 0.005 * camMoveSpeed;\n      const vy = followCam.rotation.x + touch1MovementY * 0.005 * camMoveSpeed;\n\n      cameraDistance = followCam.position.length();\n\n      if (vy >= -0.5 && vy <= 1.5) {\n        followCam.rotation.x = vy;\n        followCam.position.y = -cameraDistance * Math.sin(-vy);\n        followCam.position.z = -cameraDistance * Math.cos(-vy);\n      }\n    }\n\n    // Two fingers touch to zoom in/out camera\n    if (previousTouch2) {\n      const prePinchDis = Math.hypot(\n        previousTouch1.pageX - previousTouch2.pageX,\n        previousTouch1.pageY - previousTouch2.pageY\n      );\n      const pinchDis = Math.hypot(\n        e.touches[0].pageX - e.touches[1].pageX,\n        e.touches[0].pageY - e.touches[1].pageY\n      );\n\n      const vz = originZDis - (prePinchDis - pinchDis) * 0.01 * camZoomSpeed;\n      const vy = followCam.rotation.x;\n\n      if (vz >= camMaxDis && vz <= camMinDis) {\n        originZDis = vz;\n        followCam.position.z = originZDis * Math.cos(-vy);\n        followCam.position.y = originZDis * Math.sin(-vy);\n      }\n    }\n\n    previousTouch1 = touch1;\n    previousTouch2 = touch2;\n  }\n\n  /**\n   * Gamepad second joystick event\n   */\n  const joystickCamMove = (movementX: number, movementY: number) => {\n    pivot.rotation.y -= movementX * 0.005 * camMoveSpeed * 3;\n    const vy = followCam.rotation.x + movementY * 0.005 * camMoveSpeed * 3;\n\n    cameraDistance = followCam.position.length();\n\n    if (vy >= -0.5 && vy <= 1.5) {\n      followCam.rotation.x = vy;\n      followCam.position.y = -cameraDistance * Math.sin(-vy);\n      followCam.position.z = -cameraDistance * Math.cos(vy);\n    }\n  }\n\n  /**\n   * Custom traverse function\n   */\n  // Prepare intersect objects for camera collision\n  function customTraverse(object: THREE.Object3D) {\n    // Chekc if the object's userData camExcludeCollision is true\n    if (object.userData && object.userData.camExcludeCollision === true) {\n      return;\n    }\n\n    // Check if the object is a Mesh, and not Text (\"InstancedBufferGeometry\")\n    if (\n      (object as THREE.Mesh).isMesh &&\n      (object as THREE.Mesh).geometry.type !== \"InstancedBufferGeometry\"\n    ) {\n      intersectObjects.push(object);\n    }\n\n    // Recursively traverse child objects\n    object.children.forEach((child) => {\n      customTraverse(child); // Continue the traversal for all child objects\n    });\n  }\n\n  /**\n   * Camera collision detection function\n   */\n  const cameraCollisionDetect = (delta: number) => {\n    // Update collision detect ray origin and pointing direction\n    // Which is from pivot point to camera position\n    cameraRayOrigin.copy(pivot.position);\n    camera.getWorldPosition(cameraPosition);\n    cameraRayDir.subVectors(cameraPosition, pivot.position);\n    // rayLength = cameraRayDir.length();\n\n    // casting ray hit, if object in between character and camera,\n    // change the smallestDistance to the ray hit toi\n    // otherwise the smallestDistance is same as camera original position (originZDis)\n    intersects = camRayCast.intersectObjects(intersectObjects);\n    if (intersects.length && intersects[0].distance <= -originZDis) {\n      smallestDistance =\n        -intersects[0].distance * camCollisionOffset < -0.7\n          ? -intersects[0].distance * camCollisionOffset\n          : -0.7;\n    } else {\n      smallestDistance = originZDis;\n    }\n\n    // Rapier ray hit setup (optional)\n    // rayHit = world.castRay(rayCast, rayLength + 1, true, null, null, character);\n    // if (rayHit && rayHit.toi && rayHit.toi > originZDis) {\n    //   smallestDistance = -rayHit.toi + 0.5;\n    // } else if (rayHit == null) {\n    //   smallestDistance = originZDis;\n    // }\n\n    // Update camera next lerping position, and lerp the camera\n    camLerpingPoint.set(\n      followCam.position.x,\n      smallestDistance * Math.sin(-followCam.rotation.x),\n      smallestDistance * Math.cos(-followCam.rotation.x)\n    );\n\n    followCam.position.lerp(camLerpingPoint, delta * 4); // delta * 2 for rapier ray setup\n  };\n\n  // Initialize camera facing direction\n  useEffect(() => {\n    pivot.rotation.y = camInitDir.y;\n    followCam.rotation.x = camInitDir.x\n  }, [])\n\n  // Set camera position to (0,0,0), if followCam is disabled set to disableFollowCamPos (default 0,0,-5)\n  useEffect(() => {\n    if (disableFollowCam) {\n      camera.position.set(disableFollowCamPos.x, disableFollowCamPos.y, disableFollowCamPos.z)\n      camera.lookAt(new THREE.Vector3(disableFollowCamTarget.x, disableFollowCamTarget.y, disableFollowCamTarget.z))\n    } else {\n      camera.position.set(0, 0, 0)\n    }\n  }, [disableFollowCam]);\n\n  useEffect(() => {\n    // Prepare for camera ray intersect objects\n    scene.children.forEach((child) => customTraverse(child));\n\n    // Prepare for followCam and pivot point\n    disableFollowCam ? followCam.remove(camera) : followCam.add(camera);\n    pivot.add(followCam);\n\n    gl.domElement.addEventListener(\"mousedown\", () => { isMouseDown = true });\n    gl.domElement.addEventListener(\"mouseup\", () => { isMouseDown = false });\n    gl.domElement.addEventListener(\"mousemove\", onDocumentMouseMove);\n    gl.domElement.addEventListener(\"mousewheel\", onDocumentMouseWheel);\n    // Touch event\n    gl.domElement.addEventListener(\"touchend\", onTouchEnd);\n    gl.domElement.addEventListener(\"touchmove\", onTouchMove, { passive: false });\n\n    return () => {\n      gl.domElement.removeEventListener(\"mousedown\", () => { isMouseDown = true });\n      gl.domElement.removeEventListener(\"mouseup\", () => { isMouseDown = false });\n      gl.domElement.removeEventListener(\"mousemove\", onDocumentMouseMove);\n      gl.domElement.removeEventListener(\"mousewheel\", onDocumentMouseWheel);\n      // Touch event\n      gl.domElement.removeEventListener(\"touchend\", onTouchEnd);\n      gl.domElement.removeEventListener(\"touchmove\", onTouchMove);\n      // Remove camera from followCam\n      followCam.remove(camera);\n    };\n  });\n\n  return { pivot, followCam, cameraCollisionDetect, joystickCamMove };\n};\n\nexport type UseFollowCamProps = {\n  disableFollowCam?: boolean;\n  disableFollowCamPos?: { x: number, y: number, z: number };\n  disableFollowCamTarget?: { x: number, y: number, z: number };\n  camInitDis?: number;\n  camMaxDis?: number;\n  camMinDis?: number;\n  camInitDir?: { x: number, y: number};\n  camMoveSpeed?: number;\n  camZoomSpeed?: number;\n  camCollisionOffset?: number;\n};\n","import * as THREE from \"three\";\nimport { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\n\nexport const useGame = /* @__PURE__ */ create(\n  /* @__PURE__ */ subscribeWithSelector<State>((set, get) => {\n    return {\n      /**\n       * Point to move point\n       */\n      moveToPoint: null as THREE.Vector3,\n\n      /**\n       * Check is camera based movement\n       */\n      isCameraBased: false as boolean,\n\n      /**\n       * Character animations state manegement\n       */\n      // Initial animation\n      curAnimation: null as string,\n      animationSet: {} as AnimationSet,\n\n      initializeAnimationSet: (animationSet: AnimationSet) => {\n        set((state) => {\n          if (Object.keys(state.animationSet).length === 0) {\n            return { animationSet };\n          }\n          return {};\n        });\n      },\n\n      reset: () => {\n        set((state) => {\n          return { curAnimation: state.animationSet.idle };\n        });\n      },\n\n      idle: () => {\n        set((state) => {\n          if (state.curAnimation === state.animationSet.jumpIdle) {\n            return { curAnimation: state.animationSet.jumpLand };\n          } else if (\n            state.curAnimation !== state.animationSet.action1 &&\n            state.curAnimation !== state.animationSet.action2 &&\n            state.curAnimation !== state.animationSet.action3 &&\n            state.curAnimation !== state.animationSet.action4\n          ) {\n            return { curAnimation: state.animationSet.idle };\n          }\n          return {};\n        });\n      },\n\n      walk: () => {\n        set((state) => {\n          if (state.curAnimation !== state.animationSet.action4) {\n            return { curAnimation: state.animationSet.walk };\n          }\n          return {};\n        });\n      },\n\n      run: () => {\n        set((state) => {\n          if (state.curAnimation !== state.animationSet.action4) {\n            return { curAnimation: state.animationSet.run };\n          }\n          return {};\n        });\n      },\n\n      jump: () => {\n        set((state) => {\n          return { curAnimation: state.animationSet.jump };\n        });\n      },\n\n      jumpIdle: () => {\n        set((state) => {\n          if (state.curAnimation === state.animationSet.jump) {\n            return { curAnimation: state.animationSet.jumpIdle };\n          }\n          return {};\n        });\n      },\n\n      jumpLand: () => {\n        set((state) => {\n          if (state.curAnimation === state.animationSet.jumpIdle) {\n            return { curAnimation: state.animationSet.jumpLand };\n          }\n          return {};\n        });\n      },\n\n      fall: () => {\n        set((state) => {\n          return { curAnimation: state.animationSet.fall };\n        });\n      },\n\n      action1: () => {\n        set((state) => {\n          if (state.curAnimation === state.animationSet.idle) {\n            return { curAnimation: state.animationSet.action1 };\n          }\n          return {};\n        });\n      },\n\n      action2: () => {\n        set((state) => {\n          if (state.curAnimation === state.animationSet.idle) {\n            return { curAnimation: state.animationSet.action2 };\n          }\n          return {};\n        });\n      },\n\n      action3: () => {\n        set((state) => {\n          if (state.curAnimation === state.animationSet.idle) {\n            return { curAnimation: state.animationSet.action3 };\n          }\n          return {};\n        });\n      },\n\n      action4: () => {\n        set((state) => {\n          if (\n            state.curAnimation === state.animationSet.idle ||\n            state.curAnimation === state.animationSet.walk ||\n            state.curAnimation === state.animationSet.run\n          ) {\n            return { curAnimation: state.animationSet.action4 };\n          }\n          return {};\n        });\n      },\n\n      /**\n       * Additional animations\n       */\n      // triggerFunction: ()=>{\n      //    set((state) => {\n      //        return { curAnimation: state.animationSet.additionalAnimation };\n      //    });\n      // }\n\n      /**\n       * Set/get point to move point\n       */\n      setMoveToPoint: (point: THREE.Vector3) => {\n        set(() => {\n          return { moveToPoint: point };\n        });\n      },\n\n      getMoveToPoint: () => {\n        return {\n          moveToPoint: get().moveToPoint,\n        };\n      },\n\n      /**\n       * Set/get camera based movement\n       */\n      setCameraBased: (isCameraBased: boolean) => {\n        set(() => {\n          return { isCameraBased: isCameraBased };\n        });\n      },\n\n      getCameraBased: () => {\n        return {\n          isCameraBased: get().isCameraBased,\n        };\n      },\n    };\n  })\n);\n\nexport type AnimationSet = {\n  idle?: string;\n  walk?: string;\n  run?: string;\n  jump?: string;\n  jumpIdle?: string;\n  jumpLand?: string;\n  fall?: string;\n  // Currently support four additional animations\n  action1?: string;\n  action2?: string;\n  action3?: string;\n  action4?: string;\n};\n\ntype State = {\n  moveToPoint: THREE.Vector3;\n  isCameraBased: boolean;\n  curAnimation: string;\n  animationSet: AnimationSet;\n  initializeAnimationSet: (animationSet: AnimationSet) => void;\n  reset: () => void;\n  setMoveToPoint: (point: THREE.Vector3) => void;\n  getMoveToPoint: () => {\n    moveToPoint: THREE.Vector3;\n  }\n  setCameraBased: (isCameraBased: boolean) => void;\n  getCameraBased: () => {\n    isCameraBased: boolean;\n  }\n} & {\n  [key in keyof AnimationSet]: () => void;\n};\n","import { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\n\nexport const useJoystickControls = /* @__PURE__ */ create(\n  /* @__PURE__ */ subscribeWithSelector<State>((set, get) => {\n    return {\n      /**\n       * Joystick state manegement\n       */\n      // Initial joystick/button state\n      curJoystickDis: 0 as number,\n      curJoystickAng: 0 as number,\n      curRunState: false as boolean,\n      curButton1Pressed: false as boolean,\n      curButton2Pressed: false as boolean,\n      curButton3Pressed: false as boolean,\n      curButton4Pressed: false as boolean,\n      curButton5Pressed: false as boolean,\n\n      setJoystick: (\n        joystickDis: number,\n        joystickAng: number,\n        runState: boolean\n      ) => {\n        set(() => {\n          return {\n            curJoystickDis: joystickDis,\n            curJoystickAng: joystickAng,\n            curRunState: runState,\n          };\n        });\n      },\n\n      resetJoystick: () => {\n        set((state) => {\n          if (state.curJoystickDis !== 0 || state.curJoystickAng !== 0) {\n            return {\n              curJoystickDis: 0,\n              curJoystickAng: 0,\n              curRunState: false,\n            };\n          }\n          return {};\n        });\n      },\n\n      pressButton1: () => {\n        set((state) => {\n          if (!state.curButton1Pressed) {\n            return {\n              curButton1Pressed: true,\n            };\n          }\n          return {};\n        });\n      },\n\n      pressButton2: () => {\n        set((state) => {\n          if (!state.curButton2Pressed) {\n            return {\n              curButton2Pressed: true,\n            };\n          }\n          return {};\n        });\n      },\n\n      pressButton3: () => {\n        set((state) => {\n          if (!state.curButton3Pressed) {\n            return {\n              curButton3Pressed: true,\n            };\n          }\n          return {};\n        });\n      },\n\n      pressButton4: () => {\n        set((state) => {\n          if (!state.curButton4Pressed) {\n            return {\n              curButton4Pressed: true,\n            };\n          }\n          return {};\n        });\n      },\n\n      pressButton5: () => {\n        set((state) => {\n          if (!state.curButton5Pressed) {\n            return {\n              curButton5Pressed: true,\n            };\n          }\n          return {};\n        });\n      },\n\n      releaseAllButtons: () => {\n        set((state) => {\n          if (state.curButton1Pressed) {\n            return {\n              curButton1Pressed: false,\n            };\n          }\n          if (state.curButton2Pressed) {\n            return {\n              curButton2Pressed: false,\n            };\n          }\n          if (state.curButton3Pressed) {\n            return {\n              curButton3Pressed: false,\n            };\n          }\n          if (state.curButton4Pressed) {\n            return {\n              curButton4Pressed: false,\n            };\n          }\n          if (state.curButton5Pressed) {\n            return {\n              curButton5Pressed: false,\n            };\n          }\n          return {};\n        });\n      },\n\n      getJoystickValues: () => {\n        return {\n          joystickDis: get().curJoystickDis,\n          joystickAng: get().curJoystickAng,\n          runState: get().curRunState,\n          button1Pressed: get().curButton1Pressed,\n          button2Pressed: get().curButton2Pressed,\n          button3Pressed: get().curButton3Pressed,\n          button4Pressed: get().curButton4Pressed,\n          button5Pressed: get().curButton5Pressed,\n        };\n      },\n    };\n  })\n);\n\ntype State = {\n  curJoystickDis: number;\n  curJoystickAng: number;\n  curRunState: boolean;\n  curButton1Pressed: boolean;\n  curButton2Pressed: boolean;\n  curButton3Pressed: boolean;\n  curButton4Pressed: boolean;\n  curButton5Pressed: boolean;\n  setJoystick: (\n    joystickDis: number,\n    joystickAng: number,\n    runState: boolean\n  ) => void;\n  resetJoystick: () => void;\n  pressButton1: () => void;\n  pressButton2: () => void;\n  pressButton3: () => void;\n  pressButton4: () => void;\n  pressButton5: () => void;\n  releaseAllButtons: () => void;\n  getJoystickValues: () => {\n    joystickDis: number;\n    joystickAng: number;\n    runState: boolean;\n    button1Pressed: boolean;\n    button2Pressed: boolean;\n    button3Pressed: boolean;\n    button4Pressed: boolean;\n    button5Pressed: boolean;\n  };\n};\n","import { useGLTF, useAnimations } from \"@react-three/drei\";\nimport { useEffect, useRef, Suspense } from \"react\";\nimport * as THREE from \"three\";\nimport { useGame, type AnimationSet } from \"./stores/useGame\";\nimport React from \"react\";\n\nexport function EcctrlAnimation(props: EcctrlAnimationProps) {\n  // Change the character src to yours\n  const group = useRef();\n  const { animations } = useGLTF(props.characterURL);\n  const { actions } = useAnimations(animations, group);\n\n  /**\n   * Character animations setup\n   */\n  const curAnimation = useGame((state) => state.curAnimation);\n  const resetAnimation = useGame((state) => state.reset);\n  const initializeAnimationSet = useGame(\n    (state) => state.initializeAnimationSet\n  );\n\n  useEffect(() => {\n    // Initialize animation set\n    initializeAnimationSet(props.animationSet);\n  }, []);\n\n  useEffect(() => {\n    // Play animation\n    const action =\n      actions[curAnimation ? curAnimation : props.animationSet.jumpIdle];\n\n    // For jump and jump land animation, only play once and clamp when finish\n    if (\n      curAnimation === props.animationSet.jump ||\n      curAnimation === props.animationSet.jumpLand ||\n      curAnimation === props.animationSet.action1 ||\n      curAnimation === props.animationSet.action2 ||\n      curAnimation === props.animationSet.action3 ||\n      curAnimation === props.animationSet.action4\n    ) {\n      action\n        .reset()\n        .fadeIn(0.2)\n        .setLoop(THREE.LoopOnce, undefined as number)\n        .play();\n      action.clampWhenFinished = true;\n    } else {\n      action.reset().fadeIn(0.2).play();\n    }\n\n    // When any action is clamp and finished reset animation\n    (action as any)._mixer.addEventListener(\"finished\", () => resetAnimation());\n\n    return () => {\n      // Fade out previous action\n      action.fadeOut(0.2);\n\n      // Clean up mixer listener, and empty the _listeners array\n      (action as any)._mixer.removeEventListener(\"finished\", () =>\n        resetAnimation()\n      );\n      (action as any)._mixer._listeners = [];\n    };\n  }, [curAnimation]);\n\n  return (\n    <Suspense fallback={null}>\n      <group ref={group} dispose={null} userData={{ camExcludeCollision: true }}>\n        {/* Replace character model here */}\n        {props.children}\n      </group>\n    </Suspense>\n  );\n}\n\nexport type EcctrlAnimationProps = {\n  characterURL: string;\n  animationSet: AnimationSet;\n  children: React.ReactNode;\n};\n","import * as THREE from \"three\"\nimport { Canvas, type ThreeElements } from \"@react-three/fiber\";\nimport React, { useEffect, useState, forwardRef, useMemo, type ReactNode, useCallback, Suspense } from \"react\";\nimport { useSpring, animated } from '@react-spring/three'\nimport { useJoystickControls } from \"./stores/useJoystickControls\";\n\nconst JoystickComponents = (props: EcctrlJoystickProps) => {\n    /**\n     * Preset values/components\n     */\n    let joystickCenterX: number = 0\n    let joystickCenterY: number = 0\n    let joystickHalfWidth: number = 0\n    let joystickHalfHeight: number = 0\n    let joystickMaxDis: number = 0\n    let joystickDis: number = 0\n    let joystickAng: number = 0\n    const touch1MovementVec2 = useMemo(() => new THREE.Vector2(), [])\n    const joystickMovementVec2 = useMemo(() => new THREE.Vector2(), [])\n\n    const [windowSize, setWindowSize] = useState({ innerHeight, innerWidth })\n    const joystickDiv: HTMLDivElement = document.querySelector(\"#ecctrl-joystick\")\n\n    /**\n     * Animation preset\n     */\n    const [springs, api] = useSpring(\n        () => ({\n            topRotationX: 0,\n            topRotationY: 0,\n            basePositionX: 0,\n            basePositionY: 0,\n            config: {\n                tension: 600\n            }\n        })\n    )\n\n    /**\n     * Joystick component geometries\n     */\n    const joystickBaseGeo = useMemo(() => new THREE.CylinderGeometry(2.3, 2.1, 0.3, 16), [])\n    const joystickStickGeo = useMemo(() => new THREE.CylinderGeometry(0.3, 0.3, 3, 6), [])\n    const joystickHandleGeo = useMemo(() => new THREE.SphereGeometry(1.4, 8, 8), [])\n\n    /**\n     * Joystick component materials\n     */\n    const joystickBaseMaterial = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.3 }), [])\n    const joystickStickMaterial = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.3 }), [])\n    const joystickHandleMaterial = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.7 }), [])\n\n    /**\n     * Joystick store setup\n     */\n    const setJoystick = useJoystickControls((state) => state.setJoystick)\n    const resetJoystick = useJoystickControls((state) => state.resetJoystick)\n\n    // Touch move function\n    const onTouchMove = useCallback((e: TouchEvent) => {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        const touch1 = e.targetTouches[0];\n\n        const touch1MovementX = touch1.pageX - joystickCenterX\n        const touch1MovementY = -(touch1.pageY - joystickCenterY)\n        touch1MovementVec2.set(touch1MovementX, touch1MovementY)\n\n        joystickDis = Math.min(Math.sqrt(Math.pow(touch1MovementX, 2) + Math.pow(touch1MovementY, 2)), joystickMaxDis)\n        joystickAng = touch1MovementVec2.angle()\n        joystickMovementVec2.set(joystickDis * Math.cos(joystickAng), joystickDis * Math.sin(joystickAng))\n        const runState = joystickDis > joystickMaxDis * 0.7\n\n        // Apply animations\n        api.start({\n            topRotationX: -joystickMovementVec2.y / joystickHalfHeight,\n            topRotationY: joystickMovementVec2.x / joystickHalfWidth,\n            basePositionX: joystickMovementVec2.x * 0.002,\n            basePositionY: joystickMovementVec2.y * 0.002,\n        })\n\n        // Pass valus to joystick store\n        setJoystick(joystickDis, joystickAng, runState)\n    }, [api, windowSize])\n\n    // Touch end function\n    const onTouchEnd = (e: TouchEvent) => {\n        // Reset animations\n        api.start({\n            topRotationX: 0,\n            topRotationY: 0,\n            basePositionX: 0,\n            basePositionY: 0,\n        })\n\n        // Reset joystick store values\n        resetJoystick()\n    }\n\n    // Reset window size function\n    const onWindowResize = () => {\n        setWindowSize({ innerHeight: window.innerHeight, innerWidth: window.innerWidth })\n    }\n\n    useEffect(() => {\n        const joystickPositionX = joystickDiv.getBoundingClientRect().x\n        const joystickPositionY = joystickDiv.getBoundingClientRect().y\n        joystickHalfWidth = joystickDiv.getBoundingClientRect().width / 2\n        joystickHalfHeight = joystickDiv.getBoundingClientRect().height / 2\n\n        joystickMaxDis = joystickHalfWidth * 0.65\n\n        joystickCenterX = joystickPositionX + joystickHalfWidth\n        joystickCenterY = joystickPositionY + joystickHalfHeight\n\n        joystickDiv.addEventListener(\"touchmove\", onTouchMove, { passive: false })\n        joystickDiv.addEventListener(\"touchend\", onTouchEnd)\n\n        window.visualViewport.addEventListener(\"resize\", onWindowResize)\n\n        return () => {\n            joystickDiv.removeEventListener(\"touchmove\", onTouchMove)\n            joystickDiv.removeEventListener(\"touchend\", onTouchEnd)\n            window.visualViewport.removeEventListener(\"resize\", onWindowResize)\n        }\n    })\n\n    return (\n        <Suspense fallback=\"null\">\n            <animated.group position-x={springs.basePositionX} position-y={springs.basePositionY}>\n                <mesh geometry={joystickBaseGeo} material={joystickBaseMaterial} rotation={[-Math.PI / 2, 0, 0]} {...props.joystickBaseProps} />\n            </animated.group>\n            <animated.group rotation-x={springs.topRotationX} rotation-y={springs.topRotationY}>\n                <mesh geometry={joystickStickGeo} material={joystickStickMaterial} rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 1.5]} {...props.joystickStickProps} />\n                <mesh geometry={joystickHandleGeo} material={joystickHandleMaterial} position={[0, 0, 4]} {...props.joystickHandleProps} />\n            </animated.group>\n        </Suspense>\n    )\n}\n\nconst ButtonComponents = ({ buttonNumber = 1, ...props }: EcctrlJoystickProps) => {\n    /**\n    * Button component geometries\n    */\n    const buttonLargeBaseGeo = useMemo(() => new THREE.CylinderGeometry(1.1, 1, 0.3, 16), [])\n    const buttonSmallBaseGeo = useMemo(() => new THREE.CylinderGeometry(0.9, 0.8, 0.3, 16), [])\n    const buttonTop1Geo = useMemo(() => new THREE.CylinderGeometry(0.9, 0.9, 0.5, 16), [])\n    const buttonTop2Geo = useMemo(() => new THREE.CylinderGeometry(0.9, 0.9, 0.5, 16), [])\n    const buttonTop3Geo = useMemo(() => new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16), [])\n    const buttonTop4Geo = useMemo(() => new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16), [])\n    const buttonTop5Geo = useMemo(() => new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16), [])\n\n    /**\n    * Button component materials\n    */\n    const buttonBaseMaterial = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.3 }), [])\n    const buttonTop1Material = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.5 }), [])\n    const buttonTop2Material = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.5 }), [])\n    const buttonTop3Material = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.5 }), [])\n    const buttonTop4Material = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.5 }), [])\n    const buttonTop5Material = useMemo(() => new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.5 }), [])\n\n    const buttonDiv: HTMLDivElement = document.querySelector(\"#ecctrl-button\")\n\n    /**\n    * Animation preset\n    */\n    const [springs, api] = useSpring(\n        () => ({\n            buttonTop1BaseScaleY: 1,\n            buttonTop1BaseScaleXAndZ: 1,\n            buttonTop2BaseScaleY: 1,\n            buttonTop2BaseScaleXAndZ: 1,\n            buttonTop3BaseScaleY: 1,\n            buttonTop3BaseScaleXAndZ: 1,\n            buttonTop4BaseScaleY: 1,\n            buttonTop4BaseScaleXAndZ: 1,\n            buttonTop5BaseScaleY: 1,\n            buttonTop5BaseScaleXAndZ: 1,\n            config: {\n                tension: 600\n            }\n        })\n    )\n\n    /**\n    * Button store setup\n    */\n    const pressButton1 = useJoystickControls((state) => state.pressButton1)\n    const pressButton2 = useJoystickControls((state) => state.pressButton2)\n    const pressButton3 = useJoystickControls((state) => state.pressButton3)\n    const pressButton4 = useJoystickControls((state) => state.pressButton4)\n    const pressButton5 = useJoystickControls((state) => state.pressButton5)\n    const releaseAllButtons = useJoystickControls((state) => state.releaseAllButtons)\n\n    // Pointer down function\n    const onPointerDown = (number: number) => {\n        switch (number) {\n            case 1:\n                pressButton1()\n                api.start({\n                    buttonTop1BaseScaleY: 0.5,\n                    buttonTop1BaseScaleXAndZ: 1.15,\n                })\n                break;\n            case 2:\n                pressButton2()\n                api.start({\n                    buttonTop2BaseScaleY: 0.5,\n                    buttonTop2BaseScaleXAndZ: 1.15,\n                })\n                break;\n            case 3:\n                pressButton3()\n                api.start({\n                    buttonTop3BaseScaleY: 0.5,\n                    buttonTop3BaseScaleXAndZ: 1.15,\n                })\n                break;\n            case 4:\n                pressButton4()\n                api.start({\n                    buttonTop4BaseScaleY: 0.5,\n                    buttonTop4BaseScaleXAndZ: 1.15,\n                })\n                break;\n            case 5:\n                pressButton5()\n                api.start({\n                    buttonTop5BaseScaleY: 0.5,\n                    buttonTop5BaseScaleXAndZ: 1.15,\n                })\n                break;\n            default:\n                break;\n        }\n    }\n\n    // Pointer up function\n    const onPointerUp = () => {\n        releaseAllButtons();\n        api.start({\n            buttonTop1BaseScaleY: 1,\n            buttonTop1BaseScaleXAndZ: 1,\n            buttonTop2BaseScaleY: 1,\n            buttonTop2BaseScaleXAndZ: 1,\n            buttonTop3BaseScaleY: 1,\n            buttonTop3BaseScaleXAndZ: 1,\n            buttonTop4BaseScaleY: 1,\n            buttonTop4BaseScaleXAndZ: 1,\n            buttonTop5BaseScaleY: 1,\n            buttonTop5BaseScaleXAndZ: 1,\n        })\n    }\n\n    useEffect(() => {\n        buttonDiv.addEventListener(\"pointerup\", onPointerUp)\n\n        return () => {\n            buttonDiv.removeEventListener(\"pointerup\", onPointerUp)\n        }\n    })\n\n    return (\n        <Suspense fallback=\"null\">\n            {/* Button 1 */}\n            {buttonNumber > 0 &&\n                <animated.group\n                    scale-x={springs.buttonTop1BaseScaleXAndZ}\n                    scale-y={springs.buttonTop1BaseScaleY}\n                    scale-z={springs.buttonTop1BaseScaleXAndZ}\n                    rotation={[-Math.PI / 2, 0, 0]}\n                    position={props.buttonGroup1Position || (buttonNumber === 1 ? [0, 0, 0] : [2, 1, 0])}>\n                    <mesh geometry={buttonLargeBaseGeo} material={buttonBaseMaterial} {...props.buttonLargeBaseProps} onPointerDown={() => onPointerDown(1)} />\n                    <mesh geometry={buttonTop1Geo} material={buttonTop1Material} position={[0, -0.3, 0]} {...props.buttonTop1Props} />\n                </animated.group>}\n            {/* Button 2 */}\n            {buttonNumber > 1 &&\n                <animated.group\n                    scale-x={springs.buttonTop2BaseScaleXAndZ}\n                    scale-y={springs.buttonTop2BaseScaleY}\n                    scale-z={springs.buttonTop2BaseScaleXAndZ}\n                    rotation={[-Math.PI / 2, 0, 0]}\n                    position={props.buttonGroup2Position || [0.5, -1.3, 0]}>\n                    <mesh geometry={buttonLargeBaseGeo} material={buttonBaseMaterial} {...props.buttonLargeBaseProps} onPointerDown={() => onPointerDown(2)} />\n                    <mesh geometry={buttonTop2Geo} material={buttonTop2Material} position={[0, -0.3, 0]} {...props.buttonTop2Props} />\n                </animated.group>}\n            {/* Button 3 */}\n            {buttonNumber > 2 &&\n                <animated.group\n                    scale-x={springs.buttonTop3BaseScaleXAndZ}\n                    scale-y={springs.buttonTop3BaseScaleY}\n                    scale-z={springs.buttonTop3BaseScaleXAndZ}\n                    rotation={[-Math.PI / 2, 0, 0]}\n                    position={props.buttonGroup3Position || [-1, 1, 0]}>\n                    <mesh geometry={buttonSmallBaseGeo} material={buttonBaseMaterial} {...props.buttonSmallBaseProps} onPointerDown={() => onPointerDown(3)} />\n                    <mesh geometry={buttonTop3Geo} material={buttonTop3Material} position={[0, -0.3, 0]} {...props.buttonTop3Props} />\n                </animated.group>}\n            {/* Button 4 */}\n            {buttonNumber > 3 &&\n                <animated.group\n                    scale-x={springs.buttonTop4BaseScaleXAndZ}\n                    scale-y={springs.buttonTop4BaseScaleY}\n                    scale-z={springs.buttonTop4BaseScaleXAndZ}\n                    rotation={[-Math.PI / 2, 0, 0]}\n                    position={props.buttonGroup4Position || [-2, -1.3, 0]}>\n                    <mesh geometry={buttonSmallBaseGeo} material={buttonBaseMaterial} {...props.buttonSmallBaseProps} onPointerDown={() => onPointerDown(4)} />\n                    <mesh geometry={buttonTop4Geo} material={buttonTop4Material} position={[0, -0.3, 0]} {...props.buttonTop4Props} />\n                </animated.group>}\n            {/* Button 5 */}\n            {buttonNumber > 4 &&\n                <animated.group\n                    scale-x={springs.buttonTop5BaseScaleXAndZ}\n                    scale-y={springs.buttonTop5BaseScaleY}\n                    scale-z={springs.buttonTop5BaseScaleXAndZ}\n                    rotation={[-Math.PI / 2, 0, 0]}\n                    position={props.buttonGroup5Position || [0.4, 2.9, 0]}>\n                    <mesh geometry={buttonSmallBaseGeo} material={buttonBaseMaterial} {...props.buttonSmallBaseProps} onPointerDown={() => onPointerDown(5)} />\n                    <mesh geometry={buttonTop5Geo} material={buttonTop5Material} position={[0, -0.3, 0]} {...props.buttonTop5Props} />\n                </animated.group>}\n        </Suspense>\n    )\n}\n\nexport const EcctrlJoystick = forwardRef<HTMLDivElement, EcctrlJoystickProps>((props, ref) => {\n    const joystickWrapperStyle: React.CSSProperties = {\n        userSelect: \"none\",\n        MozUserSelect: \"none\",\n        WebkitUserSelect: \"none\",\n        msUserSelect: \"none\",\n        touchAction: \"none\",\n        pointerEvents: \"none\",\n        overscrollBehavior: \"none\",\n        position: 'fixed',\n        zIndex: '9999',\n        height: props.joystickHeightAndWidth || '200px',\n        width: props.joystickHeightAndWidth || '200px',\n        left: props.joystickPositionLeft || '0',\n        bottom: props.joystickPositionBottom || '0',\n    }\n\n    const buttonWrapperStyle: React.CSSProperties = {\n        userSelect: \"none\",\n        MozUserSelect: \"none\",\n        WebkitUserSelect: \"none\",\n        msUserSelect: \"none\",\n        touchAction: \"none\",\n        pointerEvents: \"none\",\n        overscrollBehavior: \"none\",\n        position: 'fixed',\n        zIndex: '9999',\n        height: props.buttonHeightAndWidth || '200px',\n        width: props.buttonHeightAndWidth || '200px',\n        right: props.buttonPositionRight || '0',\n        bottom: props.buttonPositionBottom || '0',\n    }\n\n    return (\n        <div ref={ref}>\n            <div id=\"ecctrl-joystick\" style={joystickWrapperStyle} onContextMenu={(e) => e.preventDefault()}>\n                <Canvas\n                    shadows\n                    orthographic\n                    camera={{\n                        zoom: props.joystickCamZoom || 26,\n                        position: props.joystickCamPosition || [0, 0, 50],\n                    }}\n                >\n                    <JoystickComponents {...props} />\n                    {props.children}\n                </Canvas>\n            </div>\n            <div id=\"ecctrl-button\" style={buttonWrapperStyle} onContextMenu={(e) => e.preventDefault()}>\n                <Canvas\n                    shadows\n                    orthographic\n                    camera={{\n                        zoom: props.buttonCamZoom || 26,\n                        position: props.buttonCamPosition || [0, 0, 50],\n                    }}>\n                    <ButtonComponents {...props} />\n                    {props.children}\n                </Canvas>\n            </div>\n        </div>\n    )\n})\n\nexport type EcctrlJoystickProps = {\n    // Joystick props\n    children?: ReactNode;\n    joystickPositionLeft?: number;\n    joystickPositionBottom?: number;\n    joystickHeightAndWidth?: number;\n    joystickCamZoom?: number;\n    joystickCamPosition?: [x: number, y: number, z: number];\n    joystickBaseProps?: ThreeElements['mesh'];\n    joystickStickProps?: ThreeElements['mesh'];\n    joystickHandleProps?: ThreeElements['mesh'];\n\n    // Touch buttons props\n    buttonNumber?: number;\n    buttonPositionRight?: number;\n    buttonPositionBottom?: number;\n    buttonHeightAndWidth?: number;\n    buttonCamZoom?: number;\n    buttonCamPosition?: [x: number, y: number, z: number];\n    buttonGroup1Position?: [x: number, y: number, z: number];\n    buttonGroup2Position?: [x: number, y: number, z: number];\n    buttonGroup3Position?: [x: number, y: number, z: number];\n    buttonGroup4Position?: [x: number, y: number, z: number];\n    buttonGroup5Position?: [x: number, y: number, z: number];\n    buttonLargeBaseProps?: ThreeElements['mesh'];\n    buttonSmallBaseProps?: ThreeElements['mesh'];\n    buttonTop1Props?: ThreeElements['mesh'];\n    buttonTop2Props?: ThreeElements['mesh'];\n    buttonTop3Props?: ThreeElements['mesh'];\n    buttonTop4Props?: ThreeElements['mesh'];\n    buttonTop5Props?: ThreeElements['mesh'];\n};","import { useKeyboardControls } from \"@react-three/drei\";\nimport { useFrame } from \"@react-three/fiber\";\nimport {\n  quat,\n  RigidBody,\n  CapsuleCollider,\n  useRapier,\n  RapierRigidBody,\n  type RigidBodyProps,\n  CylinderCollider,\n} from \"@react-three/rapier\";\nimport { useEffect, useRef, useMemo, type ReactNode, forwardRef, type ForwardRefRenderFunction, type RefObject } from \"react\";\nimport * as THREE from \"three\";\nimport { useControls } from \"leva\";\nimport { useFollowCam } from \"./hooks/useFollowCam\";\nimport { useGame } from \"./stores/useGame\";\nimport { useJoystickControls } from \"./stores/useJoystickControls\";\nimport type {\n  Collider,\n  RayColliderToi,\n  Vector,\n} from \"@dimforge/rapier3d-compat\";\nimport React from \"react\";\n\nexport { EcctrlAnimation } from \"./EcctrlAnimation\";\nexport { useFollowCam } from \"./hooks/useFollowCam\";\nexport { useGame } from \"./stores/useGame\";\nexport { EcctrlJoystick } from \"../src/EcctrlJoystick\";\nexport { useJoystickControls } from \"./stores/useJoystickControls\";\n\n// Retrieve current moving direction of the character\nconst getMovingDirection = (forward: boolean,\n  backward: boolean,\n  leftward: boolean,\n  rightward: boolean,\n  pivot: THREE.Object3D)\n  : number | null => {\n  if (!forward && !backward && !leftward && !rightward) return null;\n  if (forward && leftward) return pivot.rotation.y + Math.PI / 4;\n  if (forward && rightward) return pivot.rotation.y - Math.PI / 4;\n  if (backward && leftward) return pivot.rotation.y - Math.PI / 4 + Math.PI;\n  if (backward && rightward) return pivot.rotation.y + Math.PI / 4 + Math.PI;\n  if (backward) return pivot.rotation.y + Math.PI;\n  if (leftward) return pivot.rotation.y + Math.PI / 2;\n  if (rightward) return pivot.rotation.y - Math.PI / 2;\n  if (forward) return pivot.rotation.y;\n};\n\nconst Ecctrl: ForwardRefRenderFunction<RapierRigidBody, EcctrlProps> = ({\n  children,\n  debug = false,\n  capsuleHalfHeight = 0.35,\n  capsuleRadius = 0.3,\n  floatHeight = 0.3,\n  characterInitDir = 0, // in rad\n  followLight = false,\n  disableFollowCam = false,\n  disableFollowCamPos = { x: 0, y: 0, z: -5 },\n  disableFollowCamTarget = { x: 0, y: 0, z: 0 },\n  // Follow camera setups\n  camInitDis = -5,\n  camMaxDis = -7,\n  camMinDis = -0.7,\n  camInitDir = { x: 0, y: 0 }, // in rad\n  camTargetPos = { x: 0, y: 0, z: 0 },\n  camMoveSpeed = 1,\n  camZoomSpeed = 1,\n  camCollision = true,\n  camCollisionOffset = 0.7,\n  // Follow light setups\n  followLightPos = { x: 20, y: 30, z: 10 },\n  // Base control setups\n  maxVelLimit = 2.5,\n  turnVelMultiplier = 0.2,\n  turnSpeed = 15,\n  sprintMult = 2,\n  jumpVel = 4,\n  jumpForceToGroundMult = 5,\n  slopJumpMult = 0.25,\n  sprintJumpMult = 1.2,\n  airDragMultiplier = 0.2,\n  dragDampingC = 0.15,\n  accDeltaTime = 8,\n  rejectVelMult = 4,\n  moveImpulsePointY = 0.5,\n  camFollowMult = 11,\n  fallingGravityScale = 2.5,\n  fallingMaxVel = -20,\n  wakeUpDelay = 200,\n  // Floating Ray setups\n  rayOriginOffest = { x: 0, y: -capsuleHalfHeight, z: 0 },\n  rayHitForgiveness = 0.1,\n  rayLength = capsuleRadius + 2,\n  rayDir = { x: 0, y: -1, z: 0 },\n  floatingDis = capsuleRadius + floatHeight,\n  springK = 1.2,\n  dampingC = 0.08,\n  // Slope Ray setups\n  showSlopeRayOrigin = false,\n  slopeMaxAngle = 1, // in rad\n  slopeRayOriginOffest = capsuleRadius - 0.03,\n  slopeRayLength = capsuleRadius + 3,\n  slopeRayDir = { x: 0, y: -1, z: 0 },\n  slopeUpExtraForce = 0.1,\n  slopeDownExtraForce = 0.2,\n  // AutoBalance Force setups\n  autoBalance = true,\n  autoBalanceSpringK = 0.3,\n  autoBalanceDampingC = 0.03,\n  autoBalanceSpringOnY = 0.5,\n  autoBalanceDampingOnY = 0.015,\n  // Animation temporary setups\n  animated = false,\n  // Mode setups\n  mode = null,\n  // Controller setups\n  controllerKeys = { forward: 12, backward: 13, leftward: 14, rightward: 15, jump: 2, action1: 11, action2: 3, action3: 1, action4: 0 },\n  // Other rigibody props from parent\n  ...props\n}: EcctrlProps, ref) => {\n  const characterRef = ref as RefObject<RapierRigidBody> || useRef<RapierRigidBody>()\n  const characterModelRef = useRef<THREE.Group>();\n  const characterModelIndicator = useMemo(() => new THREE.Object3D(), [])\n  const defaultControllerKeys = { forward: 12, backward: 13, leftward: 14, rightward: 15, jump: 2, action1: 11, action2: 3, action3: 1, action4: 0 }\n\n  /**\n   * Mode setup\n   */\n  let isModePointToMove = false\n  const setCameraBased = useGame((state) => state.setCameraBased);\n  const getCameraBased = useGame((state) => state.getCameraBased);\n  if (mode) {\n    if (mode === \"PointToMove\") isModePointToMove = true\n    if (mode === \"CameraBasedMovement\") setCameraBased(true)\n  }\n\n  /** \n   * Body collider setup\n   */\n  const modelFacingVec = useMemo(() => new THREE.Vector3(), []);\n  const bodyFacingVec = useMemo(() => new THREE.Vector3(), []);\n  const bodyBalanceVec = useMemo(() => new THREE.Vector3(), []);\n  const bodyBalanceVecOnX = useMemo(() => new THREE.Vector3(), []);\n  const bodyFacingVecOnY = useMemo(() => new THREE.Vector3(), []);\n  const bodyBalanceVecOnZ = useMemo(() => new THREE.Vector3(), []);\n  const vectorY = useMemo(() => new THREE.Vector3(0, 1, 0), []);\n  const vectorZ = useMemo(() => new THREE.Vector3(0, 0, 1), []);\n  const bodyContactForce = useMemo(() => new THREE.Vector3(), []);\n\n  // Animation change functions\n  const idleAnimation = !animated ? null : useGame((state) => state.idle);\n  const walkAnimation = !animated ? null : useGame((state) => state.walk);\n  const runAnimation = !animated ? null : useGame((state) => state.run);\n  const jumpAnimation = !animated ? null : useGame((state) => state.jump);\n  const jumpIdleAnimation = !animated\n    ? null\n    : useGame((state) => state.jumpIdle);\n  const fallAnimation = !animated ? null : useGame((state) => state.fall);\n  const action1Animation = !animated ? null : useGame((state) => state.action1);\n  const action2Animation = !animated ? null : useGame((state) => state.action2);\n  const action3Animation = !animated ? null : useGame((state) => state.action3);\n  const action4Animation = !animated ? null : useGame((state) => state.action4);\n\n  /**\n   * Debug settings\n   */\n  let characterControlsDebug = null;\n  let floatingRayDebug = null;\n  let slopeRayDebug = null;\n  let autoBalanceForceDebug = null;\n  if (debug) {\n    // Character Controls\n    characterControlsDebug = useControls(\n      \"Character Controls\",\n      {\n        maxVelLimit: {\n          value: maxVelLimit,\n          min: 0,\n          max: 10,\n          step: 0.01,\n        },\n        turnVelMultiplier: {\n          value: turnVelMultiplier,\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        turnSpeed: {\n          value: turnSpeed,\n          min: 5,\n          max: 30,\n          step: 0.1,\n        },\n        sprintMult: {\n          value: sprintMult,\n          min: 1,\n          max: 5,\n          step: 0.01,\n        },\n        jumpVel: {\n          value: jumpVel,\n          min: 0,\n          max: 10,\n          step: 0.01,\n        },\n        jumpForceToGroundMult: {\n          value: jumpForceToGroundMult,\n          min: 0,\n          max: 80,\n          step: 0.1,\n        },\n        slopJumpMult: {\n          value: slopJumpMult,\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        sprintJumpMult: {\n          value: sprintJumpMult,\n          min: 1,\n          max: 3,\n          step: 0.01,\n        },\n        airDragMultiplier: {\n          value: airDragMultiplier,\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        dragDampingC: {\n          value: dragDampingC,\n          min: 0,\n          max: 0.5,\n          step: 0.01,\n        },\n        accDeltaTime: {\n          value: accDeltaTime,\n          min: 0,\n          max: 50,\n          step: 1,\n        },\n        rejectVelMult: {\n          value: rejectVelMult,\n          min: 0,\n          max: 10,\n          step: 0.1,\n        },\n        moveImpulsePointY: {\n          value: moveImpulsePointY,\n          min: 0,\n          max: 3,\n          step: 0.1,\n        },\n        camFollowMult: {\n          value: camFollowMult,\n          min: 0,\n          max: 15,\n          step: 0.1,\n        },\n      },\n      { collapsed: true }\n    );\n    // Apply debug values\n    maxVelLimit = characterControlsDebug.maxVelLimit;\n    turnVelMultiplier = characterControlsDebug.turnVelMultiplier;\n    turnSpeed = characterControlsDebug.turnSpeed;\n    sprintMult = characterControlsDebug.sprintMult;\n    jumpVel = characterControlsDebug.jumpVel;\n    jumpForceToGroundMult = characterControlsDebug.jumpForceToGroundMult;\n    slopJumpMult = characterControlsDebug.slopJumpMult;\n    sprintJumpMult = characterControlsDebug.sprintJumpMult;\n    airDragMultiplier = characterControlsDebug.airDragMultiplier;\n    dragDampingC = characterControlsDebug.dragDampingC;\n    accDeltaTime = characterControlsDebug.accDeltaTime;\n    rejectVelMult = characterControlsDebug.rejectVelMult;\n    moveImpulsePointY = characterControlsDebug.moveImpulsePointY;\n    camFollowMult = characterControlsDebug.camFollowMult;\n\n    // Floating Ray\n    floatingRayDebug = useControls(\n      \"Floating Ray\",\n      {\n        rayOriginOffest: {\n          x: 0,\n          y: -capsuleHalfHeight,\n          z: 0,\n        },\n        rayHitForgiveness: {\n          value: rayHitForgiveness,\n          min: 0,\n          max: 0.5,\n          step: 0.01,\n        },\n        rayLength: {\n          value: capsuleRadius + 2,\n          min: 0,\n          max: capsuleRadius + 10,\n          step: 0.01,\n        },\n        rayDir: { x: 0, y: -1, z: 0 },\n        floatingDis: {\n          value: capsuleRadius + floatHeight,\n          min: 0,\n          max: capsuleRadius + 2,\n          step: 0.01,\n        },\n        springK: {\n          value: springK,\n          min: 0,\n          max: 5,\n          step: 0.01,\n        },\n        dampingC: {\n          value: dampingC,\n          min: 0,\n          max: 3,\n          step: 0.01,\n        },\n      },\n      { collapsed: true }\n    );\n    // Apply debug values\n    rayOriginOffest = floatingRayDebug.rayOriginOffest;\n    rayHitForgiveness = floatingRayDebug.rayHitForgiveness;\n    rayLength = floatingRayDebug.rayLength;\n    rayDir = floatingRayDebug.rayDir;\n    floatingDis = floatingRayDebug.floatingDis;\n    springK = floatingRayDebug.springK;\n    dampingC = floatingRayDebug.dampingC;\n\n    // Slope Ray\n    slopeRayDebug = useControls(\n      \"Slope Ray\",\n      {\n        showSlopeRayOrigin: false,\n        slopeMaxAngle: {\n          value: slopeMaxAngle,\n          min: 0,\n          max: 1.57,\n          step: 0.01\n        },\n        slopeRayOriginOffest: {\n          value: capsuleRadius,\n          min: 0,\n          max: capsuleRadius + 3,\n          step: 0.01,\n        },\n        slopeRayLength: {\n          value: capsuleRadius + 3,\n          min: 0,\n          max: capsuleRadius + 13,\n          step: 0.01,\n        },\n        slopeRayDir: { x: 0, y: -1, z: 0 },\n        slopeUpExtraForce: {\n          value: slopeUpExtraForce,\n          min: 0,\n          max: 5,\n          step: 0.01,\n        },\n        slopeDownExtraForce: {\n          value: slopeDownExtraForce,\n          min: 0,\n          max: 5,\n          step: 0.01,\n        },\n      },\n      { collapsed: true }\n    );\n    // Apply debug values\n    showSlopeRayOrigin = slopeRayDebug.showSlopeRayOrigin;\n    slopeMaxAngle = slopeRayDebug.slopeMaxAngle;\n    slopeRayLength = slopeRayDebug.slopeRayLength;\n    slopeRayDir = slopeRayDebug.slopeRayDir;\n    slopeUpExtraForce = slopeRayDebug.slopeUpExtraForce;\n    slopeDownExtraForce = slopeRayDebug.slopeDownExtraForce;\n\n    // AutoBalance Force\n    autoBalanceForceDebug = useControls(\n      \"AutoBalance Force\",\n      {\n        autoBalance: {\n          value: true,\n        },\n        autoBalanceSpringK: {\n          value: autoBalanceSpringK,\n          min: 0,\n          max: 5,\n          step: 0.01,\n        },\n        autoBalanceDampingC: {\n          value: autoBalanceDampingC,\n          min: 0,\n          max: 0.1,\n          step: 0.001,\n        },\n        autoBalanceSpringOnY: {\n          value: autoBalanceSpringOnY,\n          min: 0,\n          max: 5,\n          step: 0.01,\n        },\n        autoBalanceDampingOnY: {\n          value: autoBalanceDampingOnY,\n          min: 0,\n          max: 0.1,\n          step: 0.001,\n        },\n      },\n      { collapsed: true }\n    );\n    // Apply debug values\n    autoBalance = autoBalanceForceDebug.autoBalance;\n    autoBalanceSpringK = autoBalanceForceDebug.autoBalanceSpringK;\n    autoBalanceDampingC = autoBalanceForceDebug.autoBalanceDampingC;\n    autoBalanceSpringOnY = autoBalanceForceDebug.autoBalanceSpringOnY;\n    autoBalanceDampingOnY = autoBalanceForceDebug.autoBalanceDampingOnY;\n  }\n\n  /**\n   * Check if inside keyboardcontrols\n   */\n  function useIsInsideKeyboardControls() {\n    try {\n      return !!useKeyboardControls()\n    } catch {\n      return false\n    }\n  }\n  const isInsideKeyboardControls = useIsInsideKeyboardControls();\n\n  /**\n   * keyboard controls setup\n   */\n  const [subscribeKeys, getKeys] = isInsideKeyboardControls ? useKeyboardControls() : [null];\n  const presetKeys = { forward: false, backward: false, leftward: false, rightward: false, jump: false, run: false };\n  const { rapier, world } = useRapier();\n\n  /**\n   * Joystick controls setup\n   */\n  const getJoystickValues = useJoystickControls(state => state.getJoystickValues)\n  const pressButton1 = useJoystickControls((state) => state.pressButton1)\n  const pressButton2 = useJoystickControls((state) => state.pressButton2)\n  const pressButton3 = useJoystickControls((state) => state.pressButton3)\n  const pressButton4 = useJoystickControls((state) => state.pressButton4)\n  const pressButton5 = useJoystickControls((state) => state.pressButton5)\n  const releaseAllButtons = useJoystickControls((state) => state.releaseAllButtons)\n  const setJoystick = useJoystickControls((state) => state.setJoystick)\n  const resetJoystick = useJoystickControls((state) => state.resetJoystick)\n\n  /**\n   * Gamepad controls setup\n   */\n  let controllerIndex: number = null\n  const gamepadKeys = { forward: false, backward: false, leftward: false, rightward: false };\n  const gamepadJoystickVec2 = useMemo(() => new THREE.Vector2(), [])\n  let gamepadJoystickDis: number = 0\n  let gamepadJoystickAng: number = 0\n  const gamepadConnect = (e: any) => { controllerIndex = e.gamepad.index }\n  const gamepadDisconnect = () => { controllerIndex = null }\n  const mergedKeys = useMemo(() => Object.assign({}, defaultControllerKeys, controllerKeys), [controllerKeys])\n  const handleButtons = (buttons: readonly GamepadButton[]) => {\n    gamepadKeys.forward = buttons[mergedKeys.forward].pressed\n    gamepadKeys.backward = buttons[mergedKeys.backward].pressed\n    gamepadKeys.leftward = buttons[mergedKeys.leftward].pressed\n    gamepadKeys.rightward = buttons[mergedKeys.rightward].pressed\n\n    // Gamepad trigger the EcctrlJoystick buttons to play animations\n    if (buttons[mergedKeys.action4].pressed) {\n      pressButton2()\n    } else if (buttons[mergedKeys.action3].pressed) {\n      pressButton4()\n    } else if (buttons[mergedKeys.jump].pressed) {\n      pressButton1()\n    } else if (buttons[mergedKeys.action2].pressed) {\n      pressButton3()\n    } else if (buttons[mergedKeys.action1].pressed) {\n      pressButton5()\n    } else {\n      releaseAllButtons()\n    }\n  }\n  const handleSticks = (axes: readonly number[]) => {\n    // Gamepad first joystick trigger the EcctrlJoystick event to move the character\n    if (Math.abs(axes[0]) > 0 || Math.abs(axes[1]) > 0) {\n      gamepadJoystickVec2.set(axes[0], -axes[1])\n      gamepadJoystickDis = Math.min(Math.sqrt(Math.pow(gamepadJoystickVec2.x, 2) + Math.pow(gamepadJoystickVec2.y, 2)), 1)\n      gamepadJoystickAng = gamepadJoystickVec2.angle()\n      const runState = gamepadJoystickDis > 0.7\n      setJoystick(gamepadJoystickDis, gamepadJoystickAng, runState)\n    } else {\n      resetJoystick()\n    }\n    // Gamepad second joystick trigger the useFollowCam event to move the camera\n    if (Math.abs(axes[2]) > 0 || Math.abs(axes[3]) > 0) {\n      // console.log(axes[2], axes[3]);\n      joystickCamMove(axes[2], axes[3])\n    }\n  }\n\n  // can jump setup\n  let canJump = false;\n  let isFalling = false;\n  const initialGravityScale: number = useMemo(() => props.gravityScale || 1, [])\n\n  // on moving object state\n  let massRatio = 1;\n  let isOnMovingObject = false;\n  const standingForcePoint = useMemo(() => new THREE.Vector3(), []);\n  const movingObjectDragForce = useMemo(() => new THREE.Vector3(), []);\n  const movingObjectVelocity = useMemo(() => new THREE.Vector3(), []);\n  const movingObjectVelocityInCharacterDir = useMemo(() => new THREE.Vector3(), []);\n  const distanceFromCharacterToObject = useMemo(() => new THREE.Vector3(), []);\n  const objectAngvelToLinvel = useMemo(() => new THREE.Vector3(), []);\n  const velocityDiff = useMemo(() => new THREE.Vector3(), []);\n\n  /**\n   * Initial light setup\n   */\n  let dirLight: THREE.DirectionalLight = null;\n\n  /**\n   * Follow camera initial setups from props\n   */\n  const cameraSetups = {\n    disableFollowCam,\n    disableFollowCamPos,\n    disableFollowCamTarget,\n    camInitDis,\n    camMaxDis,\n    camMinDis,\n    camInitDir,\n    camMoveSpeed,\n    camZoomSpeed,\n    camCollisionOffset\n  };\n\n  /**\n   * Load camera pivot and character move preset\n   */\n  const { pivot, cameraCollisionDetect, joystickCamMove } =\n    useFollowCam(cameraSetups);\n  const pivotPosition = useMemo(() => new THREE.Vector3(), []);\n  const modelEuler = useMemo(() => new THREE.Euler(), []);\n  const modelQuat = useMemo(() => new THREE.Quaternion(), []);\n  const moveImpulse = useMemo(() => new THREE.Vector3(), []);\n  const movingDirection = useMemo(() => new THREE.Vector3(), []);\n  const moveAccNeeded = useMemo(() => new THREE.Vector3(), []);\n  const jumpVelocityVec = useMemo(() => new THREE.Vector3(), []);\n  const jumpDirection = useMemo(() => new THREE.Vector3(), []);\n  const currentVel = useMemo(() => new THREE.Vector3(), []);\n  const currentPos = useMemo(() => new THREE.Vector3(), []);\n  const dragForce = useMemo(() => new THREE.Vector3(), []);\n  const dragAngForce = useMemo(() => new THREE.Vector3(), []);\n  const wantToMoveVel = useMemo(() => new THREE.Vector3(), []);\n  const rejectVel = useMemo(() => new THREE.Vector3(), []);\n\n  /**\n   * Floating Ray setup\n   */\n  let floatingForce = null;\n  const springDirVec = useMemo(() => new THREE.Vector3(), []);\n  const characterMassForce = useMemo(() => new THREE.Vector3(), []);\n  const rayOrigin = useMemo(() => new THREE.Vector3(), []);\n  const rayCast = new rapier.Ray(rayOrigin, rayDir);\n  let rayHit: RayColliderToi = null;\n\n  /**Test shape ray */\n  // const shape = new rapier.Capsule(0.2,0.1)\n\n  /**\n   * Slope detection ray setup\n   */\n  let slopeAngle: number = null;\n  let actualSlopeNormal: Vector = null;\n  let actualSlopeAngle: number = null;\n  const actualSlopeNormalVec = useMemo(() => new THREE.Vector3(), []);\n  const floorNormal = useMemo(() => new THREE.Vector3(0, 1, 0), []);\n  const slopeRayOriginRef = useRef<THREE.Mesh>();\n  const slopeRayorigin = useMemo(() => new THREE.Vector3(), []);\n  const slopeRayCast = new rapier.Ray(slopeRayorigin, slopeRayDir);\n  let slopeRayHit: RayColliderToi = null;\n\n  /**\n   * Point to move setup\n   */\n  let isBodyHitWall = false;\n  let isPointMoving = false;\n  const crossVector = useMemo(() => new THREE.Vector3(), []);\n  const pointToPoint = useMemo(() => new THREE.Vector3(), []);\n  const getMoveToPoint = useGame((state) => state.getMoveToPoint);\n  const bodySensorRef = useRef<Collider>();\n  const handleOnIntersectionEnter = () => {\n    isBodyHitWall = true\n  }\n  const handleOnIntersectionExit = () => {\n    isBodyHitWall = false\n  }\n\n  /**\n   * Character moving function\n   */\n  let characterRotated = true;\n  const moveCharacter = (\n    _: number,\n    run: boolean,\n    slopeAngle: number,\n    movingObjectVelocity: THREE.Vector3\n  ) => {\n    /**\n     * Setup moving direction\n     */\n    // Only apply slope extra force when slope angle is between 0.2 and slopeMaxAngle, actualSlopeAngle < slopeMaxAngle\n    if (\n      actualSlopeAngle < slopeMaxAngle &&\n      Math.abs(slopeAngle) > 0.2 &&\n      Math.abs(slopeAngle) < slopeMaxAngle\n    ) {\n      movingDirection.set(0, Math.sin(slopeAngle), Math.cos(slopeAngle));\n    } else if (actualSlopeAngle >= slopeMaxAngle) {\n      movingDirection.set(\n        0,\n        Math.sin(slopeAngle) > 0 ? 0 : Math.sin(slopeAngle),\n        Math.sin(slopeAngle) > 0 ? 0.1 : 1\n      );\n    } else {\n      movingDirection.set(0, 0, 1);\n    }\n\n    // Apply character quaternion to moving direction\n    movingDirection.applyQuaternion(characterModelIndicator.quaternion);\n\n    /**\n     * Moving object conditions\n     */\n    // Calculate moving object velocity direction according to character moving direction\n    movingObjectVelocityInCharacterDir\n      .copy(movingObjectVelocity)\n      .projectOnVector(movingDirection)\n      .multiply(movingDirection);\n    // Calculate angle between moving object velocity direction and character moving direction\n    const angleBetweenCharacterDirAndObjectDir =\n      movingObjectVelocity.angleTo(movingDirection);\n\n    /**\n     * Setup rejection velocity, (currently only work on ground)\n     */\n    const wantToMoveMeg = currentVel.dot(movingDirection);\n    wantToMoveVel.set(\n      movingDirection.x * wantToMoveMeg,\n      0,\n      movingDirection.z * wantToMoveMeg\n    );\n    rejectVel.copy(currentVel).sub(wantToMoveVel);\n\n    /**\n     * Calculate required accelaration and force: a = v/t\n     * If it's on a moving/rotating platform, apply platform velocity to v accordingly\n     * Also, apply reject velocity when character is moving opposite of it's moving direction\n     */\n    moveAccNeeded.set(\n      (movingDirection.x *\n        (maxVelLimit * (run ? sprintMult : 1) +\n          movingObjectVelocityInCharacterDir.x) -\n        (currentVel.x -\n          movingObjectVelocity.x *\n          Math.sin(angleBetweenCharacterDirAndObjectDir) +\n          rejectVel.x * (isOnMovingObject ? 0 : rejectVelMult))) /\n      accDeltaTime,\n      0,\n      (movingDirection.z *\n        (maxVelLimit * (run ? sprintMult : 1) +\n          movingObjectVelocityInCharacterDir.z) -\n        (currentVel.z -\n          movingObjectVelocity.z *\n          Math.sin(angleBetweenCharacterDirAndObjectDir) +\n          rejectVel.z * (isOnMovingObject ? 0 : rejectVelMult))) /\n      accDeltaTime\n    );\n\n    // Wanted to move force function: F = ma\n    const moveForceNeeded = moveAccNeeded.multiplyScalar(\n      characterRef.current.mass()\n    );\n\n    /**\n     * Check if character complete turned to the wanted direction\n     */\n    characterRotated =\n      Math.sin(characterModelIndicator.rotation.y).toFixed(3) ==\n      Math.sin(modelEuler.y).toFixed(3);\n\n    // If character hasn't complete turning, change the impulse quaternion follow characterModelIndicator quaternion\n    if (!characterRotated) {\n      moveImpulse.set(\n        moveForceNeeded.x *\n        turnVelMultiplier *\n        (canJump ? 1 : airDragMultiplier), // if it's in the air, give it less control\n        slopeAngle === null || slopeAngle == 0 // if it's on a slope, apply extra up/down force to the body\n          ? 0\n          : movingDirection.y *\n          turnVelMultiplier *\n          (movingDirection.y > 0 // check it is on slope up or slope down\n            ? slopeUpExtraForce\n            : slopeDownExtraForce) *\n          (run ? sprintMult : 1),\n        moveForceNeeded.z *\n        turnVelMultiplier *\n        (canJump ? 1 : airDragMultiplier) // if it's in the air, give it less control\n      );\n    }\n    // If character complete turning, change the impulse quaternion default\n    else {\n      moveImpulse.set(\n        moveForceNeeded.x * (canJump ? 1 : airDragMultiplier),\n        slopeAngle === null || slopeAngle == 0 // if it's on a slope, apply extra up/down force to the body\n          ? 0\n          : movingDirection.y *\n          (movingDirection.y > 0 // check it is on slope up or slope down\n            ? slopeUpExtraForce\n            : slopeDownExtraForce) *\n          (run ? sprintMult : 1),\n        moveForceNeeded.z * (canJump ? 1 : airDragMultiplier)\n      );\n    }\n\n    // Move character at proper direction and impulse\n    characterRef.current.applyImpulseAtPoint(\n      moveImpulse,\n      {\n        x: currentPos.x,\n        y: currentPos.y + moveImpulsePointY,\n        z: currentPos.z,\n      },\n      true\n    );\n  };\n\n  /**\n   * Character auto balance function\n   */\n  const autoBalanceCharacter = () => {\n    // Match body component to character model rotation on Y\n    bodyFacingVec.set(0, 0, 1).applyQuaternion(quat(characterRef.current.rotation()))\n    bodyBalanceVec.set(0, 1, 0).applyQuaternion(quat(characterRef.current.rotation()))\n\n    bodyBalanceVecOnX.set(0, bodyBalanceVec.y, bodyBalanceVec.z)\n    bodyFacingVecOnY.set(bodyFacingVec.x, 0, bodyFacingVec.z)\n    bodyBalanceVecOnZ.set(bodyBalanceVec.x, bodyBalanceVec.y, 0)\n\n    // Check if is camera based movement\n    if (getCameraBased().isCameraBased) {\n      modelEuler.y = pivot.rotation.y\n      pivot.getWorldDirection(modelFacingVec)\n    } else {\n      characterModelIndicator.getWorldDirection(modelFacingVec)\n    }\n    const crossVecOnX = vectorY.clone().cross(bodyBalanceVecOnX);\n    const crossVecOnY = modelFacingVec.clone().cross(bodyFacingVecOnY);\n    const crossVecOnZ = vectorY.clone().cross(bodyBalanceVecOnZ);\n\n    dragAngForce.set(\n      (crossVecOnX.x < 0 ? 1 : -1) *\n      autoBalanceSpringK * (bodyBalanceVecOnX.angleTo(vectorY))\n      - characterRef.current.angvel().x * autoBalanceDampingC,\n      (crossVecOnY.y < 0 ? 1 : -1) *\n      autoBalanceSpringOnY * (modelFacingVec.angleTo(bodyFacingVecOnY))\n      - characterRef.current.angvel().y * autoBalanceDampingOnY,\n      (crossVecOnZ.z < 0 ? 1 : -1) *\n      autoBalanceSpringK * (bodyBalanceVecOnZ.angleTo(vectorY))\n      - characterRef.current.angvel().z * autoBalanceDampingC,\n    );\n\n    // Apply balance torque impulse\n    characterRef.current.applyTorqueImpulse(dragAngForce, true)\n  };\n\n  /**\n   * Character sleep function\n   */\n  const sleepCharacter = () => {\n    if (characterRef.current) {\n      if (document.visibilityState === \"hidden\") {\n        characterRef.current.sleep()\n      } else {\n        setTimeout(() => {\n          characterRef.current.wakeUp()\n        }, wakeUpDelay)\n      }\n    }\n  }\n\n  /**\n   * Point-to-move function\n   */\n  const pointToMove = (delta: number, slopeAngle: number, movingObjectVelocity: THREE.Vector3) => {\n    const moveToPoint = getMoveToPoint().moveToPoint;\n    if (moveToPoint) {\n      pointToPoint.set(moveToPoint.x - currentPos.x, 0, moveToPoint.z - currentPos.z)\n      crossVector.crossVectors(pointToPoint, vectorZ)\n      // Rotate character to moving direction\n      modelEuler.y = (crossVector.y > 0 ? -1 : 1) * pointToPoint.angleTo(vectorZ);\n      // Once character close to the target point (distance<0.3),\n      // Or character close to the wall (bodySensor intersects) \n      // stop moving\n      if (characterRef.current) {\n        if (pointToPoint.length() > 0.3 && !isBodyHitWall) {\n          moveCharacter(delta, false, slopeAngle, movingObjectVelocity)\n          isPointMoving = true\n        } else {\n          isPointMoving = false\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    // Initialize directional light\n    if (followLight) {\n      dirLight = characterModelRef.current.parent.parent.children.find(\n        (item) => {\n          return item.name === \"followLight\";\n        }\n      ) as THREE.DirectionalLight;\n    }\n  });\n\n  /**\n   * Keyboard controls subscribe setup\n   */\n  // If inside keyboardcontrols, active subscribeKeys\n  if (isInsideKeyboardControls) {\n    useEffect(() => {\n      // Action 1 key subscribe for special animation\n      const unSubscribeAction1 = subscribeKeys(\n        (state) => state.action1,\n        (value) => {\n          if (value) {\n            animated && action1Animation();\n          }\n        }\n      );\n\n      // Action 2 key subscribe for special animation\n      const unSubscribeAction2 = subscribeKeys(\n        (state) => state.action2,\n        (value) => {\n          if (value) {\n            animated && action2Animation();\n          }\n        }\n      );\n\n      // Action 3 key subscribe for special animation\n      const unSubscribeAction3 = subscribeKeys(\n        (state) => state.action3,\n        (value) => {\n          if (value) {\n            animated && action3Animation();\n          }\n        }\n      );\n\n      // Trigger key subscribe for special animation\n      const unSubscribeAction4 = subscribeKeys(\n        (state) => state.action4,\n        (value) => {\n          if (value) {\n            animated && action4Animation();\n          }\n        }\n      );\n\n      return () => {\n        unSubscribeAction1();\n        unSubscribeAction2();\n        unSubscribeAction3();\n        unSubscribeAction4();\n      };\n    });\n  }\n\n  /**\n   * Joystick subscribe setup\n   */\n  useEffect(() => {\n    // Subscribe button 2\n    const unSubPressButton2 = useJoystickControls.subscribe(\n      (state) => state.curButton2Pressed,\n      (value) => {\n        if (value) {\n          animated && action4Animation();\n        }\n      }\n    )\n\n    // Subscribe button 3\n    const unSubPressButton3 = useJoystickControls.subscribe(\n      (state) => state.curButton3Pressed,\n      (value) => {\n        if (value) {\n          animated && action2Animation();\n        }\n      }\n    )\n\n    // Subscribe button 4\n    const unSubPressButton4 = useJoystickControls.subscribe(\n      (state) => state.curButton4Pressed,\n      (value) => {\n        if (value) {\n          animated && action3Animation();\n        }\n      }\n    )\n\n    // Subscribe button 5\n    const unSubPressButton5 = useJoystickControls.subscribe(\n      (state) => state.curButton5Pressed,\n      (value) => {\n        if (value) {\n          animated && action1Animation();\n        }\n      }\n    )\n\n    return () => {\n      unSubPressButton2();\n      unSubPressButton3();\n      unSubPressButton4();\n      unSubPressButton5();\n    };\n  })\n\n  useEffect(() => {\n    // Lock character rotations at Y axis\n    characterRef.current.setEnabledRotations(\n      autoBalance ? true : false,\n      autoBalance ? true : false,\n      autoBalance ? true : false,\n      false\n    );\n\n    // Reset character quaternion\n    return (() => {\n      if (characterRef.current && characterModelRef.current) {\n        characterModelRef.current.quaternion.set(0, 0, 0, 1);\n        characterRef.current.setRotation({ x: 0, y: 0, z: 0, w: 1 }, false);\n      }\n    })\n  }, [autoBalance]);\n\n  useEffect(() => {\n    // Initialize character facing direction\n    modelEuler.y = characterInitDir\n\n    window.addEventListener(\"visibilitychange\", sleepCharacter);\n    window.addEventListener(\"gamepadconnected\", gamepadConnect);\n    window.addEventListener(\"gamepaddisconnected\", gamepadDisconnect);\n\n    return () => {\n      window.removeEventListener(\"visibilitychange\", sleepCharacter);\n      window.removeEventListener(\"gamepadconnected\", gamepadConnect);\n      window.removeEventListener(\"gamepaddisconnected\", gamepadDisconnect);\n    }\n  }, [])\n\n  useFrame((state, delta) => {\n    if (delta > 1) delta %= 1;\n\n    // Character current position\n    if (characterRef.current) {\n      currentPos.copy(characterRef.current.translation() as THREE.Vector3);\n      // Assign userDate properties\n      (characterRef.current.userData as userDataType).canJump = canJump;\n      (characterRef.current.userData as userDataType).slopeAngle = slopeAngle;\n      (characterRef.current.userData as userDataType).characterRotated = characterRotated;\n      (characterRef.current.userData as userDataType).isOnMovingObject = isOnMovingObject;\n    }\n\n    /**\n     * Apply character position to directional light\n     */\n    if (followLight && dirLight) {\n      dirLight.position.x = currentPos.x + followLightPos.x;\n      dirLight.position.y = currentPos.y + followLightPos.y;\n      dirLight.position.z = currentPos.z + followLightPos.z;\n      dirLight.target = characterModelRef.current;\n    }\n\n    /**\n     * Getting all gamepad control values\n     */\n    if (controllerIndex !== null) {\n      const gamepad = navigator.getGamepads()[controllerIndex]\n      handleButtons(gamepad.buttons)\n      handleSticks(gamepad.axes)\n      // Getting moving directions (IIFE)\n      modelEuler.y = ((movingDirection) => movingDirection === null ? modelEuler.y : movingDirection)\n        (getMovingDirection(gamepadKeys.forward, gamepadKeys.backward, gamepadKeys.leftward, gamepadKeys.rightward, pivot))\n    }\n\n    /**\n     * Getting all joystick control values\n     */\n    const {\n      joystickDis,\n      joystickAng,\n      runState,\n      button1Pressed,\n    } = getJoystickValues()\n\n    // Move character to the moving direction (joystick controls)\n    if (joystickDis > 0) {\n      // Apply camera rotation to character model\n      modelEuler.y = pivot.rotation.y + (joystickAng - Math.PI / 2)\n      moveCharacter(delta, runState, slopeAngle, movingObjectVelocity);\n    }\n\n    /**\n     * Getting all the useful keys from useKeyboardControls\n     */\n    const { forward, backward, leftward, rightward, jump, run } = isInsideKeyboardControls ? getKeys() : presetKeys;\n\n    // Getting moving directions (IIFE)\n    modelEuler.y = ((movingDirection) => movingDirection === null ? modelEuler.y : movingDirection)\n      (getMovingDirection(forward, backward, leftward, rightward, pivot))\n\n    // Move character to the moving direction\n    if (forward || backward || leftward || rightward || gamepadKeys.forward || gamepadKeys.backward || gamepadKeys.leftward || gamepadKeys.rightward)\n      moveCharacter(delta, run, slopeAngle, movingObjectVelocity);\n\n    // Character current velocity\n    if (characterRef.current)\n      currentVel.copy(characterRef.current.linvel() as THREE.Vector3);\n\n    // Jump impulse\n    if ((jump || button1Pressed) && canJump) {\n      // characterRef.current.applyImpulse(jumpDirection.set(0, 0.5, 0), true);\n      jumpVelocityVec.set(\n        currentVel.x,\n        run ? sprintJumpMult * jumpVel : jumpVel,\n        currentVel.z\n      );\n      // Apply slope normal to jump direction\n      characterRef.current.setLinvel(\n        jumpDirection\n          .set(0, (run ? sprintJumpMult * jumpVel : jumpVel) * slopJumpMult, 0)\n          .projectOnVector(actualSlopeNormalVec)\n          .add(jumpVelocityVec),\n        true\n      );\n      // Apply jump force downward to the standing platform\n      characterMassForce.y *= jumpForceToGroundMult;\n      rayHit.collider\n        .parent()\n        ?.applyImpulseAtPoint(characterMassForce, standingForcePoint, true);\n    }\n\n    // Rotate character Indicator\n    modelQuat.setFromEuler(modelEuler);\n    characterModelIndicator.quaternion.rotateTowards(\n      modelQuat,\n      delta * turnSpeed\n    );\n\n    // If autobalance is off, rotate character model itself\n    if (!autoBalance) {\n      if (getCameraBased().isCameraBased) {\n        characterModelRef.current.quaternion.copy(pivot.quaternion)\n      } else {\n        characterModelRef.current.quaternion.copy(characterModelIndicator.quaternion)\n      }\n    }\n\n    /**\n     *  Camera movement\n     */\n    pivotPosition.set(\n      currentPos.x + camTargetPos.x,\n      currentPos.y + (camTargetPos.y || (capsuleHalfHeight + capsuleRadius / 2)),\n      currentPos.z + camTargetPos.z\n    );\n    pivot.position.lerp(pivotPosition, 1 - Math.exp(-camFollowMult * delta));\n    !disableFollowCam && state.camera.lookAt(pivot.position);\n\n    /**\n     * Ray casting detect if on ground\n     */\n    rayOrigin.addVectors(currentPos, rayOriginOffest as THREE.Vector3);\n    rayHit = world.castRay(\n      rayCast,\n      rayLength,\n      true,\n      // this exclude sensor \n      16,\n      null,\n      null,\n      characterRef.current,\n      // this exclude any collider with userData: excludeEcctrlRay\n      ((collider: Collider) => (\n        collider.parent().userData && !(collider.parent().userData as userDataType).excludeEcctrlRay\n      ))\n    );\n    /**Test shape ray */\n    // rayHit = world.castShape(\n    //   currentPos,\n    //   { w: 0, x: 0, y: 0, z: 0 },\n    //   {x:0,y:-1,z:0},\n    //   shape,\n    //   rayLength,\n    //   true,\n    //   null,\n    //   null,\n    //   characterRef.current\n    // );\n\n    if (rayHit && rayHit.toi < floatingDis + rayHitForgiveness) {\n      if (slopeRayHit && actualSlopeAngle < slopeMaxAngle) {\n        canJump = true;\n      }\n    } else {\n      canJump = false;\n    }\n\n    /**\n     * Ray detect if on rigid body or dynamic platform, then apply the linear velocity and angular velocity to character\n     */\n    if (rayHit && canJump) {\n      if (rayHit.collider.parent()) {\n        // Getting the standing force apply point\n        standingForcePoint.set(\n          rayOrigin.x,\n          rayOrigin.y - rayHit.toi,\n          rayOrigin.z\n        );\n        const rayHitObjectBodyType = rayHit.collider.parent().bodyType();\n        const rayHitObjectBodyMass = rayHit.collider.parent().mass();\n        massRatio = characterRef.current.mass() / rayHitObjectBodyMass;\n        // Body type 0 is rigid body, body type 1 is fixed body, body type 2 is kinematic body\n        if (rayHitObjectBodyType === 0 || rayHitObjectBodyType === 2) {\n          isOnMovingObject = true;\n          // Calculate distance between character and moving object\n          distanceFromCharacterToObject\n            .copy(currentPos)\n            .sub(rayHit.collider.parent().translation() as THREE.Vector3);\n          // Moving object linear velocity\n          const movingObjectLinvel = rayHit.collider\n            .parent()\n            .linvel() as THREE.Vector3;\n          // Moving object angular velocity\n          const movingObjectAngvel = rayHit.collider\n            .parent()\n            .angvel() as THREE.Vector3;\n          // Combine object linear velocity and angular velocity to movingObjectVelocity\n          movingObjectVelocity.set(\n            movingObjectLinvel.x +\n            objectAngvelToLinvel.crossVectors(\n              movingObjectAngvel,\n              distanceFromCharacterToObject\n            ).x,\n            movingObjectLinvel.y,\n            movingObjectLinvel.z +\n            objectAngvelToLinvel.crossVectors(\n              movingObjectAngvel,\n              distanceFromCharacterToObject\n            ).z\n          ).multiplyScalar(Math.min(1, 1 / massRatio));\n          // If the velocity diff is too high (> 30), ignore movingObjectVelocity\n          velocityDiff.subVectors(movingObjectVelocity, currentVel);\n          if (velocityDiff.length() > 30) movingObjectVelocity.multiplyScalar(1 / velocityDiff.length());\n\n          // Apply opposite drage force to the stading rigid body, body type 0\n          // Character moving and unmoving should provide different drag force to the platform\n          if (rayHitObjectBodyType === 0) {\n            if (\n              !forward && !backward && !leftward && !rightward &&\n              canJump &&\n              joystickDis === 0 &&\n              !isPointMoving &&\n              !gamepadKeys.forward && !gamepadKeys.backward && !gamepadKeys.leftward && !gamepadKeys.rightward\n            ) {\n              movingObjectDragForce.copy(bodyContactForce)\n                .multiplyScalar(delta)\n                .multiplyScalar(Math.min(1, 1 / massRatio)) // Scale up/down base on different masses ratio\n                .negate()\n              bodyContactForce.set(0, 0, 0);\n            } else {\n              movingObjectDragForce.copy(moveImpulse)\n                .multiplyScalar(Math.min(1, 1 / massRatio)) // Scale up/down base on different masses ratio\n                .negate();\n            }\n            rayHit.collider\n              .parent()\n              .applyImpulseAtPoint(\n                movingObjectDragForce,\n                standingForcePoint,\n                true\n              );\n          }\n        } else { // on fixed body\n          massRatio = 1;\n          isOnMovingObject = false;\n          bodyContactForce.set(0, 0, 0);\n          movingObjectVelocity.set(0, 0, 0);\n        }\n      }\n    } else { // in the air\n      massRatio = 1;\n      isOnMovingObject = false;\n      bodyContactForce.set(0, 0, 0);\n      movingObjectVelocity.set(0, 0, 0);\n    }\n\n    /**\n     * Slope ray casting detect if on slope\n     */\n    slopeRayOriginRef.current.getWorldPosition(slopeRayorigin);\n    slopeRayorigin.y = rayOrigin.y;\n    slopeRayHit = world.castRay(\n      slopeRayCast,\n      slopeRayLength,\n      true,\n      // this exclude sensor \n      16,\n      null,\n      null,\n      characterRef.current,\n      // this exclude any collider with userData: excludeEcctrlRay\n      ((collider: Collider) => (\n        collider.parent().userData && !(collider.parent().userData as userDataType).excludeEcctrlRay\n      ))\n    );\n\n    // Calculate slope angle\n    if (slopeRayHit) {\n      actualSlopeNormal = slopeRayHit.collider.castRayAndGetNormal(\n        slopeRayCast,\n        slopeRayLength,\n        false\n      )?.normal;\n      if (actualSlopeNormal) {\n        actualSlopeNormalVec?.set(\n          actualSlopeNormal.x,\n          actualSlopeNormal.y,\n          actualSlopeNormal.z\n        );\n        actualSlopeAngle = actualSlopeNormalVec?.angleTo(floorNormal);\n      }\n    }\n    if (slopeRayHit && rayHit && slopeRayHit.toi < floatingDis + 0.5) {\n      if (canJump) {\n        // Round the slope angle to 2 decimal places\n        slopeAngle = Number(\n          Math.atan(\n            (rayHit.toi - slopeRayHit.toi) / slopeRayOriginOffest\n          ).toFixed(2)\n        );\n      } else {\n        slopeAngle = null;\n      }\n    } else {\n      slopeAngle = null;\n    }\n\n    /**\n     * Apply floating force\n     */\n    if (rayHit != null) {\n      if (canJump && rayHit.collider.parent()) {\n        floatingForce =\n          springK * (floatingDis - rayHit.toi) -\n          characterRef.current.linvel().y * dampingC;\n        characterRef.current.applyImpulse(\n          springDirVec.set(0, floatingForce, 0),\n          false\n        );\n\n        // Apply opposite force to standing object (gravity g in rapier is 0.11 ?_?)\n        characterMassForce.set(0, floatingForce > 0 ? -floatingForce : 0, 0);\n        rayHit.collider\n          .parent()\n          ?.applyImpulseAtPoint(characterMassForce, standingForcePoint, true);\n      }\n    }\n\n    /**\n     * Apply drag force if it's not moving\n     */\n    if (\n      !forward && !backward && !leftward && !rightward &&\n      canJump &&\n      joystickDis === 0 &&\n      !isPointMoving &&\n      !gamepadKeys.forward && !gamepadKeys.backward && !gamepadKeys.leftward && !gamepadKeys.rightward\n    ) {\n      // not on a moving object\n      if (!isOnMovingObject) {\n        dragForce.set(\n          -currentVel.x * dragDampingC,\n          0,\n          -currentVel.z * dragDampingC\n        );\n        characterRef.current.applyImpulse(dragForce, false);\n      }\n      // on a moving object\n      else {\n        dragForce.set(\n          (movingObjectVelocity.x - currentVel.x) * dragDampingC,\n          0,\n          (movingObjectVelocity.z - currentVel.z) * dragDampingC\n        );\n        characterRef.current.applyImpulse(dragForce, true);\n      }\n    }\n\n    /**\n     * Detect character falling state\n     */\n    isFalling = (currentVel.y < 0 && !canJump) ? true : false\n\n    /**\n     * Setup max falling speed && extra falling gravity\n     * Remove gravity if falling speed higher than fallingMaxVel (negetive number so use \"<\")\n     */\n    if (characterRef.current) {\n      if (currentVel.y < fallingMaxVel) {\n        if (characterRef.current.gravityScale() !== 0) {\n          characterRef.current.setGravityScale(0, true)\n        }\n      } else {\n        if (!isFalling && characterRef.current.gravityScale() !== initialGravityScale) {\n          // Apply initial gravity after landed\n          characterRef.current.setGravityScale(initialGravityScale, true)\n        } else if (isFalling && characterRef.current.gravityScale() !== fallingGravityScale) {\n          // Apply larger gravity when falling (if initialGravityScale === fallingGravityScale, won't trigger this)\n          characterRef.current.setGravityScale(fallingGravityScale, true)\n        }\n      }\n    }\n\n    /**\n     * Apply auto balance force to the character\n     */\n    if (autoBalance && characterRef.current) autoBalanceCharacter();\n\n    /**\n     * Camera collision detect\n     */\n    camCollision && cameraCollisionDetect(delta);\n\n    /**\n     * Point to move feature\n     */\n    isModePointToMove && pointToMove(delta, slopeAngle, movingObjectVelocity)\n\n    /**\n     * Apply all the animations\n     */\n    if (animated) {\n      if (!forward && !backward && !leftward && !rightward && !jump &&\n        !button1Pressed && joystickDis === 0 &&\n        !isPointMoving &&\n        !gamepadKeys.forward && !gamepadKeys.backward && !gamepadKeys.leftward && !gamepadKeys.rightward &&\n        canJump\n      ) {\n        idleAnimation();\n      } else if ((jump || button1Pressed) && canJump) {\n        jumpAnimation();\n      } else if (canJump &&\n        (\n          forward || backward || leftward || rightward ||\n          joystickDis > 0 ||\n          isPointMoving ||\n          gamepadKeys.forward || gamepadKeys.backward || gamepadKeys.leftward || gamepadKeys.rightward\n        )) {\n        (run || runState) ? runAnimation() : walkAnimation();\n      } else if (!canJump) {\n        jumpIdleAnimation();\n      }\n      // On high sky, play falling animation\n      if (rayHit == null && isFalling) {\n        fallAnimation();\n      }\n    }\n  });\n\n  return (\n    <RigidBody\n      colliders={false}\n      ref={characterRef}\n      position={props.position || [0, 5, 0]}\n      friction={props.friction || -0.5}\n      onContactForce={(e) => bodyContactForce.set(e.totalForce.x, e.totalForce.y, e.totalForce.z)}\n      onCollisionExit={() => bodyContactForce.set(0, 0, 0)}\n      userData={{ canJump: false }}\n      {...props}\n    >\n      <CapsuleCollider\n        name=\"character-capsule-collider\"\n        args={[capsuleHalfHeight, capsuleRadius]}\n      />\n      {/* Body collide sensor (only for point to move mode) */}\n      {isModePointToMove &&\n        <CylinderCollider\n          ref={bodySensorRef}\n          sensor\n          args={[capsuleHalfHeight / 2, capsuleRadius]}\n          position={[0, 0, capsuleRadius / 2]}\n          onIntersectionEnter={handleOnIntersectionEnter}\n          onIntersectionExit={handleOnIntersectionExit}\n        />}\n      <group ref={characterModelRef} userData={{ camExcludeCollision: true }}>\n        {/* This mesh is used for positioning the slope ray origin */}\n        <mesh\n          position={[\n            rayOriginOffest.x,\n            rayOriginOffest.y,\n            rayOriginOffest.z + slopeRayOriginOffest,\n          ]}\n          ref={slopeRayOriginRef}\n          visible={showSlopeRayOrigin}\n          userData={{ camExcludeCollision: true }} // this won't be collide by camera ray\n        >\n          <boxGeometry args={[0.15, 0.15, 0.15]} />\n        </mesh>\n        {/* Character model */}\n        {children}\n      </group>\n    </RigidBody>\n  );\n}\n\nexport default forwardRef(Ecctrl);\n\nexport interface EcctrlProps extends RigidBodyProps {\n  children?: ReactNode;\n  debug?: boolean;\n  capsuleHalfHeight?: number;\n  capsuleRadius?: number;\n  floatHeight?: number;\n  characterInitDir?: number;\n  followLight?: boolean;\n  disableFollowCam?: boolean;\n  disableFollowCamPos?: { x: number, y: number, z: number };\n  disableFollowCamTarget?: { x: number, y: number, z: number };\n  // Follow camera setups\n  camInitDis?: number;\n  camMaxDis?: number;\n  camMinDis?: number;\n  camInitDir?: { x: number, y: number };\n  camTargetPos?: { x: number, y: number, z: number };\n  camMoveSpeed?: number;\n  camZoomSpeed?: number;\n  camCollision?: boolean;\n  camCollisionOffset?: number;\n  // Follow light setups\n  followLightPos?: { x: number, y: number, z: number };\n  // Base control setups\n  maxVelLimit?: number;\n  turnVelMultiplier?: number;\n  turnSpeed?: number;\n  sprintMult?: number;\n  jumpVel?: number;\n  jumpForceToGroundMult?: number;\n  slopJumpMult?: number;\n  sprintJumpMult?: number;\n  airDragMultiplier?: number;\n  dragDampingC?: number;\n  accDeltaTime?: number;\n  rejectVelMult?: number;\n  moveImpulsePointY?: number;\n  camFollowMult?: number;\n  fallingGravityScale?: number;\n  fallingMaxVel?: number;\n  wakeUpDelay?: number;\n  // Floating Ray setups\n  rayOriginOffest?: { x: number; y: number; z: number };\n  rayHitForgiveness?: number;\n  rayLength?: number;\n  rayDir?: { x: number; y: number; z: number };\n  floatingDis?: number;\n  springK?: number;\n  dampingC?: number;\n  // Slope Ray setups\n  showSlopeRayOrigin?: boolean;\n  slopeMaxAngle?: number;\n  slopeRayOriginOffest?: number;\n  slopeRayLength?: number;\n  slopeRayDir?: { x: number; y: number; z: number };\n  slopeUpExtraForce?: number;\n  slopeDownExtraForce?: number;\n  // Head Ray setups\n  showHeadRayOrigin?: boolean;\n  headRayOriginOffest?: number;\n  headRayLength?: number;\n  headRayDir?: { x: number; y: number; z: number };\n  // AutoBalance Force setups\n  autoBalance?: boolean;\n  autoBalanceSpringK?: number;\n  autoBalanceDampingC?: number;\n  autoBalanceSpringOnY?: number;\n  autoBalanceDampingOnY?: number;\n  // Animation temporary setups\n  animated?: boolean;\n  // Mode setups\n  mode?: string;\n  // Controller setups\n  controllerKeys?: { forward?: number, backward?: number, leftward?: number, rightward?: number, jump?: number, action1?: number, action2?: number, action3?: number, action4?: number }\n  // Other rigibody props from parent\n  props?: RigidBodyProps;\n};\n\nexport interface userDataType {\n  canJump?: boolean;\n  slopeAngle?: number | null;\n  characterRotated?: boolean;\n  isOnMovingObject?: boolean;\n  excludeEcctrlRay?: boolean;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}