{"ast":null,"code":"import * as THREE from 'three';\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nconst ZAXIS = /* @__PURE__ */new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n\n    // Unused\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    this._onConnected = this._onConnected.bind(this);\n    this._onDisconnected = this._onDisconnected.bind(this);\n    this.hand.addEventListener('connected', this._onConnected);\n    this.hand.addEventListener('disconnected', this._onDisconnected);\n  }\n  _onConnected(event) {\n    const xrInputSource = event.data;\n    if (xrInputSource.hand) {\n      this.visible = true;\n      this.xrInputSource = xrInputSource;\n      this.createPointer();\n    }\n  }\n  _onDisconnected() {\n    this.visible = false;\n    this.xrInputSource = null;\n    if (this.pointerGeometry) this.pointerGeometry.dispose();\n    if (this.pointerMesh && this.pointerMesh.material) this.pointerMesh.material.dispose();\n    this.clear();\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (let i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    // first ring for front face\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n\n    // rings for rear hemisphere\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n    for (let i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n\n    // front and rear face center vertices\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    // verticesNeedUpdate = true;\n  }\n  createPointer() {\n    let i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    // const vertices = [];\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n    // construct faces to connect rings\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n\n    // construct front and rear face\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster();\n\n    // create cursor\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n  dispose() {\n    this._onDisconnected();\n    this.hand.removeEventListener('connected', this._onConnected);\n    this.hand.removeEventListener('disconnected', this._onDisconnected);\n  }\n}\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","Object3D","constructor","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","_onConnected","bind","_onDisconnected","addEventListener","event","xrInputSource","data","visible","createPointer","dispose","material","clear","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","isPinched","setAttached","isAttached","intersectObject","object","recursive","intersectObjects","objects","checkIntersections","intersections","length","intersection","setCursor","removeEventListener"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */ new THREE.Vector3( 0, 1, 0 );\nconst ZAXIS = /* @__PURE__ */ new THREE.Vector3( 0, 0, 1 );\n\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n\n\tconstructor( hand, controller ) {\n\n\t\tsuper();\n\n\t\tthis.hand = hand;\n\t\tthis.controller = controller;\n\n\t\t// Unused\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\t\tthis.mesh = null;\n\n\t\tthis.pointerGeometry = null;\n\t\tthis.pointerMesh = null;\n\t\tthis.pointerObject = null;\n\n\t\tthis.pinched = false;\n\t\tthis.attached = false;\n\n\t\tthis.cursorObject = null;\n\n\t\tthis.raycaster = null;\n\n\t\tthis._onConnected = this._onConnected.bind( this );\n\t\tthis._onDisconnected = this._onDisconnected.bind( this );\n\t\tthis.hand.addEventListener( 'connected', this._onConnected );\n\t\tthis.hand.addEventListener( 'disconnected', this._onDisconnected );\n\n\t}\n\n\t_onConnected( event ) {\n\n\t\tconst xrInputSource = event.data;\n\t\tif ( xrInputSource.hand ) {\n\n\t\t\tthis.visible = true;\n\t\t\tthis.xrInputSource = xrInputSource;\n\n\t\t\tthis.createPointer();\n\n\t\t}\n\n\t}\n\n\t_onDisconnected() {\n\n\t\tthis.visible = false;\n\t\tthis.xrInputSource = null;\n\n\t\tif ( this.pointerGeometry ) this.pointerGeometry.dispose();\n\t\tif ( this.pointerMesh && this.pointerMesh.material ) this.pointerMesh.material.dispose();\n\n\t\tthis.clear();\n\n\t}\n\n\t_drawVerticesRing( vertices, baseVector, ringIndex ) {\n\n\t\tconst segmentVector = baseVector.clone();\n\t\tfor ( let i = 0; i < POINTER_SEGMENTS; i ++ ) {\n\n\t\t\tsegmentVector.applyAxisAngle( ZAXIS, ( Math.PI * 2 ) / POINTER_SEGMENTS );\n\t\t\tconst vid = ringIndex * POINTER_SEGMENTS + i;\n\t\t\tvertices[ 3 * vid ] = segmentVector.x;\n\t\t\tvertices[ 3 * vid + 1 ] = segmentVector.y;\n\t\t\tvertices[ 3 * vid + 2 ] = segmentVector.z;\n\n\t\t}\n\n\t}\n\n\t_updatePointerVertices( rearRadius ) {\n\n\t\tconst vertices = this.pointerGeometry.attributes.position.array;\n\t\t// first ring for front face\n\t\tconst frontFaceBase = new THREE.Vector3(\n\t\t\tPOINTER_FRONT_RADIUS,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tthis._drawVerticesRing( vertices, frontFaceBase, 0 );\n\n\t\t// rings for rear hemisphere\n\t\tconst rearBase = new THREE.Vector3(\n\t\t\tMath.sin( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\tMath.cos( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\t0\n\t\t);\n\t\tfor ( let i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tthis._drawVerticesRing( vertices, rearBase, i + 1 );\n\t\t\trearBase.applyAxisAngle(\n\t\t\t\tYAXIS,\n\t\t\t\t( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 / ( POINTER_RINGS * - 2 )\n\t\t\t);\n\n\t\t}\n\n\t\t// front and rear face center vertices\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\t\tconst frontCenter = new THREE.Vector3(\n\t\t\t0,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tvertices[ frontCenterIndex * 3 ] = frontCenter.x;\n\t\tvertices[ frontCenterIndex * 3 + 1 ] = frontCenter.y;\n\t\tvertices[ frontCenterIndex * 3 + 2 ] = frontCenter.z;\n\t\tconst rearCenter = new THREE.Vector3( 0, 0, rearRadius );\n\t\tvertices[ rearCenterIndex * 3 ] = rearCenter.x;\n\t\tvertices[ rearCenterIndex * 3 + 1 ] = rearCenter.y;\n\t\tvertices[ rearCenterIndex * 3 + 2 ] = rearCenter.z;\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew THREE.Float32BufferAttribute( vertices, 3 )\n\t\t);\n\t\t// verticesNeedUpdate = true;\n\n\t}\n\n\tcreatePointer() {\n\n\t\tlet i, j;\n\t\tconst vertices = new Array(\n\t\t\t( ( POINTER_RINGS + 1 ) * POINTER_SEGMENTS + 2 ) * 3\n\t\t).fill( 0 );\n\t\t// const vertices = [];\n\t\tconst indices = [];\n\t\tthis.pointerGeometry = new THREE.BufferGeometry();\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew THREE.Float32BufferAttribute( vertices, 3 )\n\t\t);\n\n\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\n\t\t// construct faces to connect rings\n\t\tfor ( i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tfor ( j = 0; j < POINTER_SEGMENTS - 1; j ++ ) {\n\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j,\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tindices.push(\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS - 1,\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\t\t\tindices.push(\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\n\t\t}\n\n\t\t// construct front and rear face\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\n\t\tfor ( i = 0; i < POINTER_SEGMENTS - 1; i ++ ) {\n\n\t\t\tindices.push( frontCenterIndex, i + 1, i );\n\t\t\tindices.push(\n\t\t\t\trearCenterIndex,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS + 1\n\t\t\t);\n\n\t\t}\n\n\t\tindices.push( frontCenterIndex, 0, POINTER_SEGMENTS - 1 );\n\t\tindices.push(\n\t\t\trearCenterIndex,\n\t\t\tPOINTER_SEGMENTS * ( POINTER_RINGS + 1 ) - 1,\n\t\t\tPOINTER_SEGMENTS * POINTER_RINGS\n\t\t);\n\n\t\tconst material = new THREE.MeshBasicMaterial();\n\t\tmaterial.transparent = true;\n\t\tmaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.pointerGeometry.setIndex( indices );\n\n\t\tthis.pointerMesh = new THREE.Mesh( this.pointerGeometry, material );\n\n\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\tthis.pointerObject = new THREE.Object3D();\n\t\tthis.pointerObject.add( this.pointerMesh );\n\n\t\tthis.raycaster = new THREE.Raycaster();\n\n\t\t// create cursor\n\t\tconst cursorGeometry = new THREE.SphereGeometry( CURSOR_RADIUS, 10, 10 );\n\t\tconst cursorMaterial = new THREE.MeshBasicMaterial();\n\t\tcursorMaterial.transparent = true;\n\t\tcursorMaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.cursorObject = new THREE.Mesh( cursorGeometry, cursorMaterial );\n\t\tthis.pointerObject.add( this.cursorObject );\n\n\t\tthis.add( this.pointerObject );\n\n\t}\n\n\t_updateRaycaster() {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\tconst pointerMatrix = this.pointerObject.matrixWorld;\n\t\t\tconst tempMatrix = new THREE.Matrix4();\n\t\t\ttempMatrix.identity().extractRotation( pointerMatrix );\n\t\t\tthis.raycaster.ray.origin.setFromMatrixPosition( pointerMatrix );\n\t\t\tthis.raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t}\n\n\t}\n\n\t_updatePointer() {\n\n\t\tthis.pointerObject.visible = this.controller.visible;\n\t\tconst indexTip = this.hand.joints[ 'index-finger-tip' ];\n\t\tconst thumbTip = this.hand.joints[ 'thumb-tip' ];\n\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\t\tconst position = indexTip.position\n\t\t\t.clone()\n\t\t\t.add( thumbTip.position )\n\t\t\t.multiplyScalar( 0.5 );\n\t\tthis.pointerObject.position.copy( position );\n\t\tthis.pointerObject.quaternion.copy( this.controller.quaternion );\n\n\t\tthis.pinched = distance <= PINCH_THRESHOLD;\n\n\t\tconst pinchScale = ( distance - PINCH_MIN ) / ( PINCH_MAX - PINCH_MIN );\n\t\tconst focusScale = ( distance - PINCH_MIN ) / ( PINCH_THRESHOLD - PINCH_MIN );\n\t\tif ( pinchScale > 1 ) {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t} else if ( pinchScale > 0 ) {\n\n\t\t\tconst rearRadius =\n        ( POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN ) * pinchScale +\n        POINTER_REAR_RADIUS_MIN;\n\t\t\tthis._updatePointerVertices( rearRadius );\n\t\t\tif ( focusScale < 1 ) {\n\n\t\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t- 1 * rearRadius - ( 1 - focusScale ) * POINTER_ADVANCE_MAX\n\t\t\t\t);\n\t\t\t\tthis.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN +\n          ( 1 - focusScale ) * ( POINTER_OPACITY_MAX - POINTER_OPACITY_MIN );\n\n\t\t\t} else {\n\n\t\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * rearRadius );\n\t\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS_MIN );\n\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t- 1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX\n\t\t\t);\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n\n\t\t}\n\n\t\tthis.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\t\tif ( this.pointerGeometry ) {\n\n\t\t\tthis._updatePointer();\n\t\t\tthis._updateRaycaster();\n\n\t\t}\n\n\t}\n\n\tisPinched() {\n\n\t\treturn this.pinched;\n\n\t}\n\n\tsetAttached( attached ) {\n\n\t\tthis.attached = attached;\n\n\t}\n\n\tisAttached() {\n\n\t\treturn this.attached;\n\n\t}\n\n\tintersectObject( object, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObject( object, recursive );\n\n\t\t}\n\n\t}\n\n\tintersectObjects( objects, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObjects( objects, recursive );\n\n\t\t}\n\n\t}\n\n\tcheckIntersections( objects, recursive = false ) {\n\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tconst intersections = this.raycaster.intersectObjects( objects, recursive );\n\t\t\tconst direction = new THREE.Vector3( 0, 0, - 1 );\n\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\tconst intersection = intersections[ 0 ];\n\t\t\t\tconst distance = intersection.distance;\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t\t} else {\n\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( CURSOR_MAX_DISTANCE ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetCursor( distance ) {\n\n\t\tconst direction = new THREE.Vector3( 0, 0, - 1 );\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis._onDisconnected();\n\t\tthis.hand.removeEventListener( 'connected', this._onConnected );\n\t\tthis.hand.removeEventListener( 'disconnected', this._onDisconnected );\n\n\t}\n\n}\n\nexport { OculusHandPointerModel };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,MAAMC,SAAS,GAAG,IAAI;AACtB,MAAMC,eAAe,GAAG,IAAI;AAC5B,MAAMC,SAAS,GAAG,IAAI;AACtB,MAAMC,mBAAmB,GAAG,IAAI;AAChC,MAAMC,mBAAmB,GAAG,CAAC;AAC7B,MAAMC,mBAAmB,GAAG,GAAG;AAC/B,MAAMC,oBAAoB,GAAG,KAAK;AAClC,MAAMC,mBAAmB,GAAG,IAAI;AAChC,MAAMC,uBAAuB,GAAG,KAAK;AACrC,MAAMC,cAAc,GAAG,KAAK;AAC5B,MAAMC,gBAAgB,GAAG,EAAE;AAC3B,MAAMC,aAAa,GAAG,EAAE;AACxB,MAAMC,wBAAwB,GAAG,GAAG;AACpC,MAAMC,KAAK,GAAG,eAAgB,IAAId,KAAK,CAACe,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;AAC1D,MAAMC,KAAK,GAAG,eAAgB,IAAIhB,KAAK,CAACe,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;AAE1D,MAAME,aAAa,GAAG,IAAI;AAC1B,MAAMC,mBAAmB,GAAG,GAAG;AAE/B,MAAMC,sBAAsB,SAASnB,KAAK,CAACoB,QAAQ,CAAC;EAEnDC,WAAWA,CAAEC,IAAI,EAAEC,UAAU,EAAG;IAE/B,KAAK,CAAC,CAAC;IAEP,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,UAAU,GAAGA,UAAU;;IAE5B;IACA,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,IAAI,GAAG,IAAI;IAEhB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,aAAa,GAAG,IAAI;IAEzB,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,QAAQ,GAAG,KAAK;IAErB,IAAI,CAACC,YAAY,GAAG,IAAI;IAExB,IAAI,CAACC,SAAS,GAAG,IAAI;IAErB,IAAI,CAACC,YAAY,GAAG,IAAI,CAACA,YAAY,CAACC,IAAI,CAAE,IAAK,CAAC;IAClD,IAAI,CAACC,eAAe,GAAG,IAAI,CAACA,eAAe,CAACD,IAAI,CAAE,IAAK,CAAC;IACxD,IAAI,CAACb,IAAI,CAACe,gBAAgB,CAAE,WAAW,EAAE,IAAI,CAACH,YAAa,CAAC;IAC5D,IAAI,CAACZ,IAAI,CAACe,gBAAgB,CAAE,cAAc,EAAE,IAAI,CAACD,eAAgB,CAAC;EAEnE;EAEAF,YAAYA,CAAEI,KAAK,EAAG;IAErB,MAAMC,aAAa,GAAGD,KAAK,CAACE,IAAI;IAChC,IAAKD,aAAa,CAACjB,IAAI,EAAG;MAEzB,IAAI,CAACmB,OAAO,GAAG,IAAI;MACnB,IAAI,CAACF,aAAa,GAAGA,aAAa;MAElC,IAAI,CAACG,aAAa,CAAC,CAAC;IAErB;EAED;EAEAN,eAAeA,CAAA,EAAG;IAEjB,IAAI,CAACK,OAAO,GAAG,KAAK;IACpB,IAAI,CAACF,aAAa,GAAG,IAAI;IAEzB,IAAK,IAAI,CAACZ,eAAe,EAAG,IAAI,CAACA,eAAe,CAACgB,OAAO,CAAC,CAAC;IAC1D,IAAK,IAAI,CAACf,WAAW,IAAI,IAAI,CAACA,WAAW,CAACgB,QAAQ,EAAG,IAAI,CAAChB,WAAW,CAACgB,QAAQ,CAACD,OAAO,CAAC,CAAC;IAExF,IAAI,CAACE,KAAK,CAAC,CAAC;EAEb;EAEAC,iBAAiBA,CAAEC,QAAQ,EAAEC,UAAU,EAAEC,SAAS,EAAG;IAEpD,MAAMC,aAAa,GAAGF,UAAU,CAACG,KAAK,CAAC,CAAC;IACxC,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzC,gBAAgB,EAAEyC,CAAC,EAAG,EAAG;MAE7CF,aAAa,CAACG,cAAc,CAAErC,KAAK,EAAIsC,IAAI,CAACC,EAAE,GAAG,CAAC,GAAK5C,gBAAiB,CAAC;MACzE,MAAM6C,GAAG,GAAGP,SAAS,GAAGtC,gBAAgB,GAAGyC,CAAC;MAC5CL,QAAQ,CAAE,CAAC,GAAGS,GAAG,CAAE,GAAGN,aAAa,CAACO,CAAC;MACrCV,QAAQ,CAAE,CAAC,GAAGS,GAAG,GAAG,CAAC,CAAE,GAAGN,aAAa,CAACQ,CAAC;MACzCX,QAAQ,CAAE,CAAC,GAAGS,GAAG,GAAG,CAAC,CAAE,GAAGN,aAAa,CAACS,CAAC;IAE1C;EAED;EAEAC,sBAAsBA,CAAEC,UAAU,EAAG;IAEpC,MAAMd,QAAQ,GAAG,IAAI,CAACpB,eAAe,CAACmC,UAAU,CAACC,QAAQ,CAACC,KAAK;IAC/D;IACA,MAAMC,aAAa,GAAG,IAAIjE,KAAK,CAACe,OAAO,CACtCR,oBAAoB,EACpB,CAAC,EACD,CAAE,CAAC,IAAKG,cAAc,GAAGmD,UAAU,CACpC,CAAC;IACD,IAAI,CAACf,iBAAiB,CAAEC,QAAQ,EAAEkB,aAAa,EAAE,CAAE,CAAC;;IAEpD;IACA,MAAMC,QAAQ,GAAG,IAAIlE,KAAK,CAACe,OAAO,CACjCuC,IAAI,CAACa,GAAG,CAAIb,IAAI,CAACC,EAAE,GAAG1C,wBAAwB,GAAK,GAAI,CAAC,GAAGgD,UAAU,EACrEP,IAAI,CAACc,GAAG,CAAId,IAAI,CAACC,EAAE,GAAG1C,wBAAwB,GAAK,GAAI,CAAC,GAAGgD,UAAU,EACrE,CACD,CAAC;IACD,KAAM,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxC,aAAa,EAAEwC,CAAC,EAAG,EAAG;MAE1C,IAAI,CAACN,iBAAiB,CAAEC,QAAQ,EAAEmB,QAAQ,EAAEd,CAAC,GAAG,CAAE,CAAC;MACnDc,QAAQ,CAACb,cAAc,CACtBvC,KAAK,EACHwC,IAAI,CAACC,EAAE,GAAG1C,wBAAwB,GAAK,GAAG,IAAKD,aAAa,GAAG,CAAE,CAAC,CACrE,CAAC;IAEF;;IAEA;IACA,MAAMyD,gBAAgB,GAAG1D,gBAAgB,IAAK,CAAC,GAAGC,aAAa,CAAE;IACjE,MAAM0D,eAAe,GAAG3D,gBAAgB,IAAK,CAAC,GAAGC,aAAa,CAAE,GAAG,CAAC;IACpE,MAAM2D,WAAW,GAAG,IAAIvE,KAAK,CAACe,OAAO,CACpC,CAAC,EACD,CAAC,EACD,CAAE,CAAC,IAAKL,cAAc,GAAGmD,UAAU,CACpC,CAAC;IACDd,QAAQ,CAAEsB,gBAAgB,GAAG,CAAC,CAAE,GAAGE,WAAW,CAACd,CAAC;IAChDV,QAAQ,CAAEsB,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGE,WAAW,CAACb,CAAC;IACpDX,QAAQ,CAAEsB,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGE,WAAW,CAACZ,CAAC;IACpD,MAAMa,UAAU,GAAG,IAAIxE,KAAK,CAACe,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE8C,UAAW,CAAC;IACxDd,QAAQ,CAAEuB,eAAe,GAAG,CAAC,CAAE,GAAGE,UAAU,CAACf,CAAC;IAC9CV,QAAQ,CAAEuB,eAAe,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGE,UAAU,CAACd,CAAC;IAClDX,QAAQ,CAAEuB,eAAe,GAAG,CAAC,GAAG,CAAC,CAAE,GAAGE,UAAU,CAACb,CAAC;IAElD,IAAI,CAAChC,eAAe,CAAC8C,YAAY,CAChC,UAAU,EACV,IAAIzE,KAAK,CAAC0E,sBAAsB,CAAE3B,QAAQ,EAAE,CAAE,CAC/C,CAAC;IACD;EAED;EAEAL,aAAaA,CAAA,EAAG;IAEf,IAAIU,CAAC,EAAEuB,CAAC;IACR,MAAM5B,QAAQ,GAAG,IAAI6B,KAAK,CACzB,CAAE,CAAEhE,aAAa,GAAG,CAAC,IAAKD,gBAAgB,GAAG,CAAC,IAAK,CACpD,CAAC,CAACkE,IAAI,CAAE,CAAE,CAAC;IACX;IACA,MAAMC,OAAO,GAAG,EAAE;IAClB,IAAI,CAACnD,eAAe,GAAG,IAAI3B,KAAK,CAAC+E,cAAc,CAAC,CAAC;IAEjD,IAAI,CAACpD,eAAe,CAAC8C,YAAY,CAChC,UAAU,EACV,IAAIzE,KAAK,CAAC0E,sBAAsB,CAAE3B,QAAQ,EAAE,CAAE,CAC/C,CAAC;IAED,IAAI,CAACa,sBAAsB,CAAEpD,mBAAoB,CAAC;;IAElD;IACA,KAAM4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxC,aAAa,EAAEwC,CAAC,EAAG,EAAG;MAEtC,KAAMuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhE,gBAAgB,GAAG,CAAC,EAAEgE,CAAC,EAAG,EAAG;QAE7CG,OAAO,CAACE,IAAI,CACX5B,CAAC,GAAGzC,gBAAgB,GAAGgE,CAAC,EACxBvB,CAAC,GAAGzC,gBAAgB,GAAGgE,CAAC,GAAG,CAAC,EAC5B,CAAEvB,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,GAAGgE,CAChC,CAAC;QACDG,OAAO,CAACE,IAAI,CACX5B,CAAC,GAAGzC,gBAAgB,GAAGgE,CAAC,GAAG,CAAC,EAC5B,CAAEvB,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,GAAGgE,CAAC,GAAG,CAAC,EACpC,CAAEvB,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,GAAGgE,CAChC,CAAC;MAEF;MAEAG,OAAO,CAACE,IAAI,CACX,CAAE5B,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,GAAG,CAAC,EAChCyC,CAAC,GAAGzC,gBAAgB,EACpB,CAAEyC,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,GAAG,CAChC,CAAC;MACDmE,OAAO,CAACE,IAAI,CACX5B,CAAC,GAAGzC,gBAAgB,EACpB,CAAEyC,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,EAC5B,CAAEyC,CAAC,GAAG,CAAC,IAAKzC,gBAAgB,GAAG,CAChC,CAAC;IAEF;;IAEA;IACA,MAAM0D,gBAAgB,GAAG1D,gBAAgB,IAAK,CAAC,GAAGC,aAAa,CAAE;IACjE,MAAM0D,eAAe,GAAG3D,gBAAgB,IAAK,CAAC,GAAGC,aAAa,CAAE,GAAG,CAAC;IAEpE,KAAMwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzC,gBAAgB,GAAG,CAAC,EAAEyC,CAAC,EAAG,EAAG;MAE7C0B,OAAO,CAACE,IAAI,CAAEX,gBAAgB,EAAEjB,CAAC,GAAG,CAAC,EAAEA,CAAE,CAAC;MAC1C0B,OAAO,CAACE,IAAI,CACXV,eAAe,EACflB,CAAC,GAAGzC,gBAAgB,GAAGC,aAAa,EACpCwC,CAAC,GAAGzC,gBAAgB,GAAGC,aAAa,GAAG,CACxC,CAAC;IAEF;IAEAkE,OAAO,CAACE,IAAI,CAAEX,gBAAgB,EAAE,CAAC,EAAE1D,gBAAgB,GAAG,CAAE,CAAC;IACzDmE,OAAO,CAACE,IAAI,CACXV,eAAe,EACf3D,gBAAgB,IAAKC,aAAa,GAAG,CAAC,CAAE,GAAG,CAAC,EAC5CD,gBAAgB,GAAGC,aACpB,CAAC;IAED,MAAMgC,QAAQ,GAAG,IAAI5C,KAAK,CAACiF,iBAAiB,CAAC,CAAC;IAC9CrC,QAAQ,CAACsC,WAAW,GAAG,IAAI;IAC3BtC,QAAQ,CAACuC,OAAO,GAAG7E,mBAAmB;IAEtC,IAAI,CAACqB,eAAe,CAACyD,QAAQ,CAAEN,OAAQ,CAAC;IAExC,IAAI,CAAClD,WAAW,GAAG,IAAI5B,KAAK,CAACqF,IAAI,CAAE,IAAI,CAAC1D,eAAe,EAAEiB,QAAS,CAAC;IAEnE,IAAI,CAAChB,WAAW,CAACmC,QAAQ,CAACuB,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,GAAG9E,mBAAoB,CAAC;IAChE,IAAI,CAACqB,aAAa,GAAG,IAAI7B,KAAK,CAACoB,QAAQ,CAAC,CAAC;IACzC,IAAI,CAACS,aAAa,CAAC0D,GAAG,CAAE,IAAI,CAAC3D,WAAY,CAAC;IAE1C,IAAI,CAACK,SAAS,GAAG,IAAIjC,KAAK,CAACwF,SAAS,CAAC,CAAC;;IAEtC;IACA,MAAMC,cAAc,GAAG,IAAIzF,KAAK,CAAC0F,cAAc,CAAEzE,aAAa,EAAE,EAAE,EAAE,EAAG,CAAC;IACxE,MAAM0E,cAAc,GAAG,IAAI3F,KAAK,CAACiF,iBAAiB,CAAC,CAAC;IACpDU,cAAc,CAACT,WAAW,GAAG,IAAI;IACjCS,cAAc,CAACR,OAAO,GAAG7E,mBAAmB;IAE5C,IAAI,CAAC0B,YAAY,GAAG,IAAIhC,KAAK,CAACqF,IAAI,CAAEI,cAAc,EAAEE,cAAe,CAAC;IACpE,IAAI,CAAC9D,aAAa,CAAC0D,GAAG,CAAE,IAAI,CAACvD,YAAa,CAAC;IAE3C,IAAI,CAACuD,GAAG,CAAE,IAAI,CAAC1D,aAAc,CAAC;EAE/B;EAEA+D,gBAAgBA,CAAA,EAAG;IAElB,IAAK,IAAI,CAAC3D,SAAS,EAAG;MAErB,MAAM4D,aAAa,GAAG,IAAI,CAAChE,aAAa,CAACiE,WAAW;MACpD,MAAMC,UAAU,GAAG,IAAI/F,KAAK,CAACgG,OAAO,CAAC,CAAC;MACtCD,UAAU,CAACE,QAAQ,CAAC,CAAC,CAACC,eAAe,CAAEL,aAAc,CAAC;MACtD,IAAI,CAAC5D,SAAS,CAACkE,GAAG,CAACC,MAAM,CAACC,qBAAqB,CAAER,aAAc,CAAC;MAChE,IAAI,CAAC5D,SAAS,CAACkE,GAAG,CAACG,SAAS,CAAChB,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC,CAACiB,YAAY,CAAER,UAAW,CAAC;IAEzE;EAED;EAEAS,cAAcA,CAAA,EAAG;IAEhB,IAAI,CAAC3E,aAAa,CAACY,OAAO,GAAG,IAAI,CAAClB,UAAU,CAACkB,OAAO;IACpD,MAAMgE,QAAQ,GAAG,IAAI,CAACnF,IAAI,CAACoF,MAAM,CAAE,kBAAkB,CAAE;IACvD,MAAMC,QAAQ,GAAG,IAAI,CAACrF,IAAI,CAACoF,MAAM,CAAE,WAAW,CAAE;IAChD,MAAME,QAAQ,GAAGH,QAAQ,CAAC1C,QAAQ,CAAC8C,UAAU,CAAEF,QAAQ,CAAC5C,QAAS,CAAC;IAClE,MAAMA,QAAQ,GAAG0C,QAAQ,CAAC1C,QAAQ,CAChCZ,KAAK,CAAC,CAAC,CACPoC,GAAG,CAAEoB,QAAQ,CAAC5C,QAAS,CAAC,CACxB+C,cAAc,CAAE,GAAI,CAAC;IACvB,IAAI,CAACjF,aAAa,CAACkC,QAAQ,CAACgD,IAAI,CAAEhD,QAAS,CAAC;IAC5C,IAAI,CAAClC,aAAa,CAACmF,UAAU,CAACD,IAAI,CAAE,IAAI,CAACxF,UAAU,CAACyF,UAAW,CAAC;IAEhE,IAAI,CAAClF,OAAO,GAAG8E,QAAQ,IAAI1G,eAAe;IAE1C,MAAM+G,UAAU,GAAG,CAAEL,QAAQ,GAAGzG,SAAS,KAAOF,SAAS,GAAGE,SAAS,CAAE;IACvE,MAAM+G,UAAU,GAAG,CAAEN,QAAQ,GAAGzG,SAAS,KAAOD,eAAe,GAAGC,SAAS,CAAE;IAC7E,IAAK8G,UAAU,GAAG,CAAC,EAAG;MAErB,IAAI,CAACrD,sBAAsB,CAAEpD,mBAAoB,CAAC;MAClD,IAAI,CAACoB,WAAW,CAACmC,QAAQ,CAACuB,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,GAAG9E,mBAAoB,CAAC;MAChE,IAAI,CAACoB,WAAW,CAACgB,QAAQ,CAACuC,OAAO,GAAG7E,mBAAmB;IAExD,CAAC,MAAM,IAAK2G,UAAU,GAAG,CAAC,EAAG;MAE5B,MAAMpD,UAAU,GACX,CAAErD,mBAAmB,GAAGC,uBAAuB,IAAKwG,UAAU,GAC9DxG,uBAAuB;MAC5B,IAAI,CAACmD,sBAAsB,CAAEC,UAAW,CAAC;MACzC,IAAKqD,UAAU,GAAG,CAAC,EAAG;QAErB,IAAI,CAACtF,WAAW,CAACmC,QAAQ,CAACuB,GAAG,CAC5B,CAAC,EACD,CAAC,EACD,CAAE,CAAC,GAAGzB,UAAU,GAAG,CAAE,CAAC,GAAGqD,UAAU,IAAK9G,mBACzC,CAAC;QACD,IAAI,CAACwB,WAAW,CAACgB,QAAQ,CAACuC,OAAO,GAC3B7E,mBAAmB,GACnB,CAAE,CAAC,GAAG4G,UAAU,KAAO7G,mBAAmB,GAAGC,mBAAmB,CAAE;MAEzE,CAAC,MAAM;QAEN,IAAI,CAACsB,WAAW,CAACmC,QAAQ,CAACuB,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,GAAGzB,UAAW,CAAC;QACvD,IAAI,CAACjC,WAAW,CAACgB,QAAQ,CAACuC,OAAO,GAAG7E,mBAAmB;MAExD;IAED,CAAC,MAAM;MAEN,IAAI,CAACsD,sBAAsB,CAAEnD,uBAAwB,CAAC;MACtD,IAAI,CAACmB,WAAW,CAACmC,QAAQ,CAACuB,GAAG,CAC5B,CAAC,EACD,CAAC,EACD,CAAE,CAAC,GAAG7E,uBAAuB,GAAGL,mBACjC,CAAC;MACD,IAAI,CAACwB,WAAW,CAACgB,QAAQ,CAACuC,OAAO,GAAG9E,mBAAmB;IAExD;IAEA,IAAI,CAAC2B,YAAY,CAACY,QAAQ,CAACuC,OAAO,GAAG,IAAI,CAACvD,WAAW,CAACgB,QAAQ,CAACuC,OAAO;EAEvE;EAEAgC,iBAAiBA,CAAEC,KAAK,EAAG;IAE1B,KAAK,CAACD,iBAAiB,CAAEC,KAAM,CAAC;IAChC,IAAK,IAAI,CAACzF,eAAe,EAAG;MAE3B,IAAI,CAAC6E,cAAc,CAAC,CAAC;MACrB,IAAI,CAACZ,gBAAgB,CAAC,CAAC;IAExB;EAED;EAEAyB,SAASA,CAAA,EAAG;IAEX,OAAO,IAAI,CAACvF,OAAO;EAEpB;EAEAwF,WAAWA,CAAEvF,QAAQ,EAAG;IAEvB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAEzB;EAEAwF,UAAUA,CAAA,EAAG;IAEZ,OAAO,IAAI,CAACxF,QAAQ;EAErB;EAEAyF,eAAeA,CAAEC,MAAM,EAAEC,SAAS,GAAG,IAAI,EAAG;IAE3C,IAAK,IAAI,CAACzF,SAAS,EAAG;MAErB,OAAO,IAAI,CAACA,SAAS,CAACuF,eAAe,CAAEC,MAAM,EAAEC,SAAU,CAAC;IAE3D;EAED;EAEAC,gBAAgBA,CAAEC,OAAO,EAAEF,SAAS,GAAG,IAAI,EAAG;IAE7C,IAAK,IAAI,CAACzF,SAAS,EAAG;MAErB,OAAO,IAAI,CAACA,SAAS,CAAC0F,gBAAgB,CAAEC,OAAO,EAAEF,SAAU,CAAC;IAE7D;EAED;EAEAG,kBAAkBA,CAAED,OAAO,EAAEF,SAAS,GAAG,KAAK,EAAG;IAEhD,IAAK,IAAI,CAACzF,SAAS,IAAI,CAAE,IAAI,CAACF,QAAQ,EAAG;MAExC,MAAM+F,aAAa,GAAG,IAAI,CAAC7F,SAAS,CAAC0F,gBAAgB,CAAEC,OAAO,EAAEF,SAAU,CAAC;MAC3E,MAAMpB,SAAS,GAAG,IAAItG,KAAK,CAACe,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC;MAChD,IAAK+G,aAAa,CAACC,MAAM,GAAG,CAAC,EAAG;QAE/B,MAAMC,YAAY,GAAGF,aAAa,CAAE,CAAC,CAAE;QACvC,MAAMlB,QAAQ,GAAGoB,YAAY,CAACpB,QAAQ;QACtC,IAAI,CAAC5E,YAAY,CAAC+B,QAAQ,CAACgD,IAAI,CAAET,SAAS,CAACQ,cAAc,CAAEF,QAAS,CAAE,CAAC;MAExE,CAAC,MAAM;QAEN,IAAI,CAAC5E,YAAY,CAAC+B,QAAQ,CAACgD,IAAI,CAAET,SAAS,CAACQ,cAAc,CAAE5F,mBAAoB,CAAE,CAAC;MAEnF;IAED;EAED;EAEA+G,SAASA,CAAErB,QAAQ,EAAG;IAErB,MAAMN,SAAS,GAAG,IAAItG,KAAK,CAACe,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC;IAChD,IAAK,IAAI,CAACkB,SAAS,IAAI,CAAE,IAAI,CAACF,QAAQ,EAAG;MAExC,IAAI,CAACC,YAAY,CAAC+B,QAAQ,CAACgD,IAAI,CAAET,SAAS,CAACQ,cAAc,CAAEF,QAAS,CAAE,CAAC;IAExE;EAED;EAEAjE,OAAOA,CAAA,EAAG;IAET,IAAI,CAACP,eAAe,CAAC,CAAC;IACtB,IAAI,CAACd,IAAI,CAAC4G,mBAAmB,CAAE,WAAW,EAAE,IAAI,CAAChG,YAAa,CAAC;IAC/D,IAAI,CAACZ,IAAI,CAAC4G,mBAAmB,CAAE,cAAc,EAAE,IAAI,CAAC9F,eAAgB,CAAC;EAEtE;AAED;AAEA,SAASjB,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}