{"ast":null,"code":"/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\n\nimport { BufferAttribute, Matrix3, Matrix4, Vector3 } from 'three';\nimport { PackedPhongMaterial } from './PackedPhongMaterial.js';\n\n/**\n * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n *\n * @param {THREE.Mesh} mesh\n * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n *\n */\nfunction compressNormals(mesh, encodeMethod) {\n  if (!mesh.geometry) {\n    console.error('Mesh must contain geometry. ');\n  }\n  const normal = mesh.geometry.attributes.normal;\n  if (!normal) {\n    console.error('Geometry must contain normal attribute. ');\n  }\n  if (normal.isPacked) return;\n  if (normal.itemSize != 3) {\n    console.error('normal.itemSize is not 3, which cannot be encoded. ');\n  }\n  const array = normal.array;\n  const count = normal.count;\n  let result;\n  if (encodeMethod == 'DEFAULT') {\n    // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n    result = new Uint8Array(count * 3);\n    for (let idx = 0; idx < array.length; idx += 3) {\n      const encoded = defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n      result[idx + 0] = encoded[0];\n      result[idx + 1] = encoded[1];\n      result[idx + 2] = encoded[2];\n    }\n    mesh.geometry.setAttribute('normal', new BufferAttribute(result, 3, true));\n    mesh.geometry.attributes.normal.bytes = result.length * 1;\n  } else if (encodeMethod == 'OCT1Byte') {\n    /**\n    * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n    * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n    * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n    */\n\n    result = new Int8Array(count * 2);\n    for (let idx = 0; idx < array.length; idx += 3) {\n      const encoded = octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);\n      result[idx / 3 * 2 + 0] = encoded[0];\n      result[idx / 3 * 2 + 1] = encoded[1];\n    }\n    mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n    mesh.geometry.attributes.normal.bytes = result.length * 1;\n  } else if (encodeMethod == 'OCT2Byte') {\n    result = new Int16Array(count * 2);\n    for (let idx = 0; idx < array.length; idx += 3) {\n      const encoded = octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);\n      result[idx / 3 * 2 + 0] = encoded[0];\n      result[idx / 3 * 2 + 1] = encoded[1];\n    }\n    mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n    mesh.geometry.attributes.normal.bytes = result.length * 2;\n  } else if (encodeMethod == 'ANGLES') {\n    result = new Uint16Array(count * 2);\n    for (let idx = 0; idx < array.length; idx += 3) {\n      const encoded = anglesEncode(array[idx], array[idx + 1], array[idx + 2]);\n      result[idx / 3 * 2 + 0] = encoded[0];\n      result[idx / 3 * 2 + 1] = encoded[1];\n    }\n    mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n    mesh.geometry.attributes.normal.bytes = result.length * 2;\n  } else {\n    console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n  }\n  mesh.geometry.attributes.normal.needsUpdate = true;\n  mesh.geometry.attributes.normal.isPacked = true;\n  mesh.geometry.attributes.normal.packingMethod = encodeMethod;\n\n  // modify material\n  if (!(mesh.material instanceof PackedPhongMaterial)) {\n    mesh.material = new PackedPhongMaterial().copy(mesh.material);\n  }\n  if (encodeMethod == 'ANGLES') {\n    mesh.material.defines.USE_PACKED_NORMAL = 0;\n  }\n  if (encodeMethod == 'OCT1Byte') {\n    mesh.material.defines.USE_PACKED_NORMAL = 1;\n  }\n  if (encodeMethod == 'OCT2Byte') {\n    mesh.material.defines.USE_PACKED_NORMAL = 1;\n  }\n  if (encodeMethod == 'DEFAULT') {\n    mesh.material.defines.USE_PACKED_NORMAL = 2;\n  }\n}\n\n/**\n\t * Make the input mesh.geometry's position attribute encoded and compressed.\n\t * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n\t *\n\t * @param {THREE.Mesh} mesh\n\t *\n\t */\nfunction compressPositions(mesh) {\n  if (!mesh.geometry) {\n    console.error('Mesh must contain geometry. ');\n  }\n  const position = mesh.geometry.attributes.position;\n  if (!position) {\n    console.error('Geometry must contain position attribute. ');\n  }\n  if (position.isPacked) return;\n  if (position.itemSize != 3) {\n    console.error('position.itemSize is not 3, which cannot be packed. ');\n  }\n  const array = position.array;\n  const encodingBytes = 2;\n  const result = quantizedEncode(array, encodingBytes);\n  const quantized = result.quantized;\n  const decodeMat = result.decodeMat;\n\n  // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n  if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n  if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n  mesh.geometry.setAttribute('position', new BufferAttribute(quantized, 3));\n  mesh.geometry.attributes.position.isPacked = true;\n  mesh.geometry.attributes.position.needsUpdate = true;\n  mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;\n\n  // modify material\n  if (!(mesh.material instanceof PackedPhongMaterial)) {\n    mesh.material = new PackedPhongMaterial().copy(mesh.material);\n  }\n  mesh.material.defines.USE_PACKED_POSITION = 0;\n  mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n  mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n}\n\n/**\n * Make the input mesh.geometry's uv attribute encoded and compressed.\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n *\n * @param {THREE.Mesh} mesh\n *\n */\nfunction compressUvs(mesh) {\n  if (!mesh.geometry) {\n    console.error('Mesh must contain geometry property. ');\n  }\n  const uvs = mesh.geometry.attributes.uv;\n  if (!uvs) {\n    console.error('Geometry must contain uv attribute. ');\n  }\n  if (uvs.isPacked) return;\n  const range = {\n    min: Infinity,\n    max: -Infinity\n  };\n  const array = uvs.array;\n  for (let i = 0; i < array.length; i++) {\n    range.min = Math.min(range.min, array[i]);\n    range.max = Math.max(range.max, array[i]);\n  }\n  let result;\n  if (range.min >= -1.0 && range.max <= 1.0) {\n    // use default encoding method\n    result = new Uint16Array(array.length);\n    for (let i = 0; i < array.length; i += 2) {\n      const encoded = defaultEncode(array[i], array[i + 1], 0, 2);\n      result[i] = encoded[0];\n      result[i + 1] = encoded[1];\n    }\n    mesh.geometry.setAttribute('uv', new BufferAttribute(result, 2, true));\n    mesh.geometry.attributes.uv.isPacked = true;\n    mesh.geometry.attributes.uv.needsUpdate = true;\n    mesh.geometry.attributes.uv.bytes = result.length * 2;\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n    mesh.material.defines.USE_PACKED_UV = 0;\n  } else {\n    // use quantized encoding method\n    result = quantizedEncodeUV(array, 2);\n    mesh.geometry.setAttribute('uv', new BufferAttribute(result.quantized, 2));\n    mesh.geometry.attributes.uv.isPacked = true;\n    mesh.geometry.attributes.uv.needsUpdate = true;\n    mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n    mesh.material.defines.USE_PACKED_UV = 1;\n    mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n    mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n  }\n}\n\n// Encoding functions\n\nfunction defaultEncode(x, y, z, bytes) {\n  if (bytes == 1) {\n    const tmpx = Math.round((x + 1) * 0.5 * 255);\n    const tmpy = Math.round((y + 1) * 0.5 * 255);\n    const tmpz = Math.round((z + 1) * 0.5 * 255);\n    return new Uint8Array([tmpx, tmpy, tmpz]);\n  } else if (bytes == 2) {\n    const tmpx = Math.round((x + 1) * 0.5 * 65535);\n    const tmpy = Math.round((y + 1) * 0.5 * 65535);\n    const tmpz = Math.round((z + 1) * 0.5 * 65535);\n    return new Uint16Array([tmpx, tmpy, tmpz]);\n  } else {\n    console.error('number of bytes must be 1 or 2');\n  }\n}\n\n// for `Angles` encoding\nfunction anglesEncode(x, y, z) {\n  const normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n  const normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n  return new Uint16Array([normal0, normal1]);\n}\n\n// for `Octahedron` encoding\nfunction octEncodeBest(x, y, z, bytes) {\n  let oct, dec, best, currentCos, bestCos;\n\n  // Test various combinations of ceil and floor\n  // to minimize rounding errors\n  best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n  dec = octDecodeVec2(oct);\n  bestCos = dot(x, y, z, dec);\n  oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n  dec = octDecodeVec2(oct);\n  currentCos = dot(x, y, z, dec);\n  if (currentCos > bestCos) {\n    best = oct;\n    bestCos = currentCos;\n  }\n  oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n  dec = octDecodeVec2(oct);\n  currentCos = dot(x, y, z, dec);\n  if (currentCos > bestCos) {\n    best = oct;\n    bestCos = currentCos;\n  }\n  oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n  dec = octDecodeVec2(oct);\n  currentCos = dot(x, y, z, dec);\n  if (currentCos > bestCos) {\n    best = oct;\n  }\n  return best;\n  function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n    let x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n    let y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n    if (z < 0) {\n      const tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n      const tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n      x = tempx;\n      y = tempy;\n      let diff = 1 - Math.abs(x) - Math.abs(y);\n      if (diff > 0) {\n        diff += 0.001;\n        x += x > 0 ? diff / 2 : -diff / 2;\n        y += y > 0 ? diff / 2 : -diff / 2;\n      }\n    }\n    if (bytes == 1) {\n      return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n    }\n    if (bytes == 2) {\n      return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n    }\n  }\n  function octDecodeVec2(oct) {\n    let x = oct[0];\n    let y = oct[1];\n    if (bytes == 1) {\n      x /= x < 0 ? 127 : 128;\n      y /= y < 0 ? 127 : 128;\n    } else if (bytes == 2) {\n      x /= x < 0 ? 32767 : 32768;\n      y /= y < 0 ? 32767 : 32768;\n    }\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n      const tmpx = x;\n      x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n      y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    return [x / length, y / length, z / length];\n  }\n  function dot(x, y, z, vec3) {\n    return x * vec3[0] + y * vec3[1] + z * vec3[2];\n  }\n}\nfunction quantizedEncode(array, bytes) {\n  let quantized, segments;\n  if (bytes == 1) {\n    quantized = new Uint8Array(array.length);\n    segments = 255;\n  } else if (bytes == 2) {\n    quantized = new Uint16Array(array.length);\n    segments = 65535;\n  } else {\n    console.error('number of bytes error! ');\n  }\n  const decodeMat = new Matrix4();\n  const min = new Float32Array(3);\n  const max = new Float32Array(3);\n  min[0] = min[1] = min[2] = Number.MAX_VALUE;\n  max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n  for (let i = 0; i < array.length; i += 3) {\n    min[0] = Math.min(min[0], array[i + 0]);\n    min[1] = Math.min(min[1], array[i + 1]);\n    min[2] = Math.min(min[2], array[i + 2]);\n    max[0] = Math.max(max[0], array[i + 0]);\n    max[1] = Math.max(max[1], array[i + 1]);\n    max[2] = Math.max(max[2], array[i + 2]);\n  }\n  decodeMat.scale(new Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n  decodeMat.elements[12] = min[0];\n  decodeMat.elements[13] = min[1];\n  decodeMat.elements[14] = min[2];\n  decodeMat.transpose();\n  const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n  for (let i = 0; i < array.length; i += 3) {\n    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n    quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n  }\n  return {\n    quantized: quantized,\n    decodeMat: decodeMat\n  };\n}\nfunction quantizedEncodeUV(array, bytes) {\n  let quantized, segments;\n  if (bytes == 1) {\n    quantized = new Uint8Array(array.length);\n    segments = 255;\n  } else if (bytes == 2) {\n    quantized = new Uint16Array(array.length);\n    segments = 65535;\n  } else {\n    console.error('number of bytes error! ');\n  }\n  const decodeMat = new Matrix3();\n  const min = new Float32Array(2);\n  const max = new Float32Array(2);\n  min[0] = min[1] = Number.MAX_VALUE;\n  max[0] = max[1] = -Number.MAX_VALUE;\n  for (let i = 0; i < array.length; i += 2) {\n    min[0] = Math.min(min[0], array[i + 0]);\n    min[1] = Math.min(min[1], array[i + 1]);\n    max[0] = Math.max(max[0], array[i + 0]);\n    max[1] = Math.max(max[1], array[i + 1]);\n  }\n  decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n  decodeMat.elements[6] = min[0];\n  decodeMat.elements[7] = min[1];\n  decodeMat.transpose();\n  const multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n  for (let i = 0; i < array.length; i += 2) {\n    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n  }\n  return {\n    quantized: quantized,\n    decodeMat: decodeMat\n  };\n}\nexport { compressNormals, compressPositions, compressUvs };","map":{"version":3,"names":["BufferAttribute","Matrix3","Matrix4","Vector3","PackedPhongMaterial","compressNormals","mesh","encodeMethod","geometry","console","error","normal","attributes","isPacked","itemSize","array","count","result","Uint8Array","idx","length","encoded","defaultEncode","setAttribute","bytes","Int8Array","octEncodeBest","Int16Array","Uint16Array","anglesEncode","needsUpdate","packingMethod","material","copy","defines","USE_PACKED_NORMAL","compressPositions","position","encodingBytes","quantizedEncode","quantized","decodeMat","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","USE_PACKED_POSITION","uniforms","quantizeMatPos","value","compressUvs","uvs","uv","range","min","Infinity","max","i","Math","USE_PACKED_UV","quantizedEncodeUV","quantizeMatUV","x","y","z","tmpx","round","tmpy","tmpz","normal0","parseInt","atan2","PI","normal1","oct","dec","best","currentCos","bestCos","octEncodeVec3","octDecodeVec2","dot","x0","y0","z0","xfunc","yfunc","abs","tempx","tempy","diff","sqrt","vec3","segments","Float32Array","Number","MAX_VALUE","scale","elements","transpose","multiplier","floor"],"sources":["/home/ervin/Escritorio/integrador/Projecto-Integrador-1-Game/node_modules/three/examples/jsm/utils/GeometryCompressionUtils.js"],"sourcesContent":["/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\n\nimport {\n\tBufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tVector3\n} from 'three';\nimport { PackedPhongMaterial } from './PackedPhongMaterial.js';\n\n\n\n/**\n * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n *\n * @param {THREE.Mesh} mesh\n * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n *\n */\nfunction compressNormals( mesh, encodeMethod ) {\n\n\tif ( ! mesh.geometry ) {\n\n\t\tconsole.error( 'Mesh must contain geometry. ' );\n\n\t}\n\n\tconst normal = mesh.geometry.attributes.normal;\n\n\tif ( ! normal ) {\n\n\t\tconsole.error( 'Geometry must contain normal attribute. ' );\n\n\t}\n\n\tif ( normal.isPacked ) return;\n\n\tif ( normal.itemSize != 3 ) {\n\n\t\tconsole.error( 'normal.itemSize is not 3, which cannot be encoded. ' );\n\n\t}\n\n\tconst array = normal.array;\n\tconst count = normal.count;\n\n\tlet result;\n\tif ( encodeMethod == 'DEFAULT' ) {\n\n\t\t// TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n\t\tresult = new Uint8Array( count * 3 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = defaultEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\n\n\t\t\tresult[ idx + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx + 1 ] = encoded[ 1 ];\n\t\t\tresult[ idx + 2 ] = encoded[ 2 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 3, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 1;\n\n\t} else if ( encodeMethod == 'OCT1Byte' ) {\n\n\t\t/**\n\t\t* It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n\t\t* As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n\t\t* Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n\t\t*/\n\n\t\tresult = new Int8Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 1;\n\n\t} else if ( encodeMethod == 'OCT2Byte' ) {\n\n\t\tresult = new Int16Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 2 );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 2;\n\n\t} else if ( encodeMethod == 'ANGLES' ) {\n\n\t\tresult = new Uint16Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = anglesEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ] );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 2;\n\n\t} else {\n\n\t\tconsole.error( 'Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ' );\n\n\t}\n\n\tmesh.geometry.attributes.normal.needsUpdate = true;\n\tmesh.geometry.attributes.normal.isPacked = true;\n\tmesh.geometry.attributes.normal.packingMethod = encodeMethod;\n\n\t// modify material\n\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t}\n\n\tif ( encodeMethod == 'ANGLES' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 0;\n\n\t}\n\n\tif ( encodeMethod == 'OCT1Byte' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 1;\n\n\t}\n\n\tif ( encodeMethod == 'OCT2Byte' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 1;\n\n\t}\n\n\tif ( encodeMethod == 'DEFAULT' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 2;\n\n\t}\n\n}\n\n\n/**\n\t * Make the input mesh.geometry's position attribute encoded and compressed.\n\t * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n\t *\n\t * @param {THREE.Mesh} mesh\n\t *\n\t */\nfunction compressPositions( mesh ) {\n\n\tif ( ! mesh.geometry ) {\n\n\t\tconsole.error( 'Mesh must contain geometry. ' );\n\n\t}\n\n\tconst position = mesh.geometry.attributes.position;\n\n\tif ( ! position ) {\n\n\t\tconsole.error( 'Geometry must contain position attribute. ' );\n\n\t}\n\n\tif ( position.isPacked ) return;\n\n\tif ( position.itemSize != 3 ) {\n\n\t\tconsole.error( 'position.itemSize is not 3, which cannot be packed. ' );\n\n\t}\n\n\tconst array = position.array;\n\tconst encodingBytes = 2;\n\n\tconst result = quantizedEncode( array, encodingBytes );\n\n\tconst quantized = result.quantized;\n\tconst decodeMat = result.decodeMat;\n\n\t// IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\tif ( mesh.geometry.boundingBox == null ) mesh.geometry.computeBoundingBox();\n\tif ( mesh.geometry.boundingSphere == null ) mesh.geometry.computeBoundingSphere();\n\n\tmesh.geometry.setAttribute( 'position', new BufferAttribute( quantized, 3 ) );\n\tmesh.geometry.attributes.position.isPacked = true;\n\tmesh.geometry.attributes.position.needsUpdate = true;\n\tmesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;\n\n\t// modify material\n\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t}\n\n\tmesh.material.defines.USE_PACKED_POSITION = 0;\n\n\tmesh.material.uniforms.quantizeMatPos.value = decodeMat;\n\tmesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n\n}\n\n/**\n * Make the input mesh.geometry's uv attribute encoded and compressed.\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n *\n * @param {THREE.Mesh} mesh\n *\n */\nfunction compressUvs( mesh ) {\n\n\tif ( ! mesh.geometry ) {\n\n\t\tconsole.error( 'Mesh must contain geometry property. ' );\n\n\t}\n\n\tconst uvs = mesh.geometry.attributes.uv;\n\n\tif ( ! uvs ) {\n\n\t\tconsole.error( 'Geometry must contain uv attribute. ' );\n\n\t}\n\n\tif ( uvs.isPacked ) return;\n\n\tconst range = { min: Infinity, max: - Infinity };\n\n\tconst array = uvs.array;\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\trange.min = Math.min( range.min, array[ i ] );\n\t\trange.max = Math.max( range.max, array[ i ] );\n\n\t}\n\n\tlet result;\n\n\tif ( range.min >= - 1.0 && range.max <= 1.0 ) {\n\n\t\t// use default encoding method\n\t\tresult = new Uint16Array( array.length );\n\n\t\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\t\tconst encoded = defaultEncode( array[ i ], array[ i + 1 ], 0, 2 );\n\n\t\t\tresult[ i ] = encoded[ 0 ];\n\t\t\tresult[ i + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'uv', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.uv.isPacked = true;\n\t\tmesh.geometry.attributes.uv.needsUpdate = true;\n\t\tmesh.geometry.attributes.uv.bytes = result.length * 2;\n\n\t\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t\t}\n\n\t\tmesh.material.defines.USE_PACKED_UV = 0;\n\n\t} else {\n\n\t\t// use quantized encoding method\n\t\tresult = quantizedEncodeUV( array, 2 );\n\n\t\tmesh.geometry.setAttribute( 'uv', new BufferAttribute( result.quantized, 2 ) );\n\t\tmesh.geometry.attributes.uv.isPacked = true;\n\t\tmesh.geometry.attributes.uv.needsUpdate = true;\n\t\tmesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n\n\t\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t\t}\n\n\t\tmesh.material.defines.USE_PACKED_UV = 1;\n\n\t\tmesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n\t\tmesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n\n\t}\n\n}\n\n\n// Encoding functions\n\nfunction defaultEncode( x, y, z, bytes ) {\n\n\tif ( bytes == 1 ) {\n\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 255 );\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 255 );\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 255 );\n\t\treturn new Uint8Array( [ tmpx, tmpy, tmpz ] );\n\n\t} else if ( bytes == 2 ) {\n\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 65535 );\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 65535 );\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 65535 );\n\t\treturn new Uint16Array( [ tmpx, tmpy, tmpz ] );\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes must be 1 or 2' );\n\n\t}\n\n}\n\n// for `Angles` encoding\nfunction anglesEncode( x, y, z ) {\n\n\tconst normal0 = parseInt( 0.5 * ( 1.0 + Math.atan2( y, x ) / Math.PI ) * 65535 );\n\tconst normal1 = parseInt( 0.5 * ( 1.0 + z ) * 65535 );\n\treturn new Uint16Array( [ normal0, normal1 ] );\n\n}\n\n// for `Octahedron` encoding\nfunction octEncodeBest( x, y, z, bytes ) {\n\n\tlet oct, dec, best, currentCos, bestCos;\n\n\t// Test various combinations of ceil and floor\n\t// to minimize rounding errors\n\tbest = oct = octEncodeVec3( x, y, z, 'floor', 'floor' );\n\tdec = octDecodeVec2( oct );\n\tbestCos = dot( x, y, z, dec );\n\n\toct = octEncodeVec3( x, y, z, 'ceil', 'floor' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\t\tbestCos = currentCos;\n\n\t}\n\n\toct = octEncodeVec3( x, y, z, 'floor', 'ceil' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\t\tbestCos = currentCos;\n\n\t}\n\n\toct = octEncodeVec3( x, y, z, 'ceil', 'ceil' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\n\t}\n\n\treturn best;\n\n\tfunction octEncodeVec3( x0, y0, z0, xfunc, yfunc ) {\n\n\t\tlet x = x0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\n\t\tlet y = y0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\n\n\t\tif ( z < 0 ) {\n\n\t\t\tconst tempx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\n\t\t\tconst tempy = ( 1 - Math.abs( x ) ) * ( y >= 0 ? 1 : - 1 );\n\n\t\t\tx = tempx;\n\t\t\ty = tempy;\n\n\t\t\tlet diff = 1 - Math.abs( x ) - Math.abs( y );\n\t\t\tif ( diff > 0 ) {\n\n\t\t\t\tdiff += 0.001;\n\t\t\t\tx += x > 0 ? diff / 2 : - diff / 2;\n\t\t\t\ty += y > 0 ? diff / 2 : - diff / 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bytes == 1 ) {\n\n\t\t\treturn new Int8Array( [\n\t\t\t\tMath[ xfunc ]( x * 127.5 + ( x < 0 ? 1 : 0 ) ),\n\t\t\t\tMath[ yfunc ]( y * 127.5 + ( y < 0 ? 1 : 0 ) )\n\t\t\t] );\n\n\t\t}\n\n\t\tif ( bytes == 2 ) {\n\n\t\t\treturn new Int16Array( [\n\t\t\t\tMath[ xfunc ]( x * 32767.5 + ( x < 0 ? 1 : 0 ) ),\n\t\t\t\tMath[ yfunc ]( y * 32767.5 + ( y < 0 ? 1 : 0 ) )\n\t\t\t] );\n\n\t\t}\n\n\n\t}\n\n\tfunction octDecodeVec2( oct ) {\n\n\t\tlet x = oct[ 0 ];\n\t\tlet y = oct[ 1 ];\n\n\t\tif ( bytes == 1 ) {\n\n\t\t\tx /= x < 0 ? 127 : 128;\n\t\t\ty /= y < 0 ? 127 : 128;\n\n\t\t} else if ( bytes == 2 ) {\n\n\t\t\tx /= x < 0 ? 32767 : 32768;\n\t\t\ty /= y < 0 ? 32767 : 32768;\n\n\t\t}\n\n\n\t\tconst z = 1 - Math.abs( x ) - Math.abs( y );\n\n\t\tif ( z < 0 ) {\n\n\t\t\tconst tmpx = x;\n\t\t\tx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\n\t\t\ty = ( 1 - Math.abs( tmpx ) ) * ( y >= 0 ? 1 : - 1 );\n\n\t\t}\n\n\t\tconst length = Math.sqrt( x * x + y * y + z * z );\n\n\t\treturn [\n\t\t\tx / length,\n\t\t\ty / length,\n\t\t\tz / length\n\t\t];\n\n\t}\n\n\tfunction dot( x, y, z, vec3 ) {\n\n\t\treturn x * vec3[ 0 ] + y * vec3[ 1 ] + z * vec3[ 2 ];\n\n\t}\n\n}\n\nfunction quantizedEncode( array, bytes ) {\n\n\tlet quantized, segments;\n\n\tif ( bytes == 1 ) {\n\n\t\tquantized = new Uint8Array( array.length );\n\t\tsegments = 255;\n\n\t} else if ( bytes == 2 ) {\n\n\t\tquantized = new Uint16Array( array.length );\n\t\tsegments = 65535;\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes error! ' );\n\n\t}\n\n\tconst decodeMat = new Matrix4();\n\n\tconst min = new Float32Array( 3 );\n\tconst max = new Float32Array( 3 );\n\n\tmin[ 0 ] = min[ 1 ] = min[ 2 ] = Number.MAX_VALUE;\n\tmax[ 0 ] = max[ 1 ] = max[ 2 ] = - Number.MAX_VALUE;\n\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\n\t\tmin[ 2 ] = Math.min( min[ 2 ], array[ i + 2 ] );\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\n\t\tmax[ 2 ] = Math.max( max[ 2 ], array[ i + 2 ] );\n\n\t}\n\n\tdecodeMat.scale( new Vector3(\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\n\t\t( max[ 1 ] - min[ 1 ] ) / segments,\n\t\t( max[ 2 ] - min[ 2 ] ) / segments\n\t) );\n\n\tdecodeMat.elements[ 12 ] = min[ 0 ];\n\tdecodeMat.elements[ 13 ] = min[ 1 ];\n\tdecodeMat.elements[ 14 ] = min[ 2 ];\n\n\tdecodeMat.transpose();\n\n\n\tconst multiplier = new Float32Array( [\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0,\n\t\tmax[ 2 ] !== min[ 2 ] ? segments / ( max[ 2 ] - min[ 2 ] ) : 0\n\t] );\n\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\n\t\tquantized[ i + 2 ] = Math.floor( ( array[ i + 2 ] - min[ 2 ] ) * multiplier[ 2 ] );\n\n\t}\n\n\treturn {\n\t\tquantized: quantized,\n\t\tdecodeMat: decodeMat\n\t};\n\n}\n\nfunction quantizedEncodeUV( array, bytes ) {\n\n\tlet quantized, segments;\n\n\tif ( bytes == 1 ) {\n\n\t\tquantized = new Uint8Array( array.length );\n\t\tsegments = 255;\n\n\t} else if ( bytes == 2 ) {\n\n\t\tquantized = new Uint16Array( array.length );\n\t\tsegments = 65535;\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes error! ' );\n\n\t}\n\n\tconst decodeMat = new Matrix3();\n\n\tconst min = new Float32Array( 2 );\n\tconst max = new Float32Array( 2 );\n\n\tmin[ 0 ] = min[ 1 ] = Number.MAX_VALUE;\n\tmax[ 0 ] = max[ 1 ] = - Number.MAX_VALUE;\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\n\n\t}\n\n\tdecodeMat.scale(\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\n\t\t( max[ 1 ] - min[ 1 ] ) / segments\n\t);\n\n\tdecodeMat.elements[ 6 ] = min[ 0 ];\n\tdecodeMat.elements[ 7 ] = min[ 1 ];\n\n\tdecodeMat.transpose();\n\n\tconst multiplier = new Float32Array( [\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0\n\t] );\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\n\n\t}\n\n\treturn {\n\t\tquantized: quantized,\n\t\tdecodeMat: decodeMat\n\t};\n\n}\n\n\n\nexport {\n\tcompressNormals,\n\tcompressPositions,\n\tcompressUvs,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}